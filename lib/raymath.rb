# Yet another raylib wrapper for Ruby
#
# * https://github.com/vaiorabbit/raylib-bindings
#
# [NOTICE] Autogenerated. Do not edit.

require 'ffi'

module Raylib
  extend FFI::Library

  # Define/Macro

  EPSILON = 0.000001

  # Typedef


  # Struct

  # NOTE: Helper types to be used instead of array return types for *ToFloat functions
  class Float3 < FFI::Struct
    layout(
      :v, [:float, 3],
    )
    def v = self[:v]
    def v=(v) self[:v] = v end
  end

  class Float16 < FFI::Struct
    layout(
      :v, [:float, 16],
    )
    def v = self[:v]
    def v=(v) self[:v] = v end
  end


  # Function

  def self.setup_raymath_symbols(method_naming: :original)
    entries = [

      # @!method Clamp(value, min, max)
      #   Clamp
      #   @param value [float]
      #   @param min [float]
      #   @param max [float]
      #   @return [float]
      [:Clamp, :Clamp, [:float, :float, :float], :float],

      # @!method Lerp(start, end, amount)
      #   Lerp
      #   @param start [float]
      #   @param end [float]
      #   @param amount [float]
      #   @return [float]
      [:Lerp, :Lerp, [:float, :float, :float], :float],

      # @!method Normalize(value, start, end)
      #   Normalize
      #   @param value [float]
      #   @param start [float]
      #   @param end [float]
      #   @return [float]
      [:Normalize, :Normalize, [:float, :float, :float], :float],

      # @!method Remap(value, inputStart, inputEnd, outputStart, outputEnd)
      #   Remap
      #   @param value [float]
      #   @param inputStart [float]
      #   @param inputEnd [float]
      #   @param outputStart [float]
      #   @param outputEnd [float]
      #   @return [float]
      [:Remap, :Remap, [:float, :float, :float, :float, :float], :float],

      # @!method Wrap(value, min, max)
      #   Wrap
      #   @param value [float]
      #   @param min [float]
      #   @param max [float]
      #   @return [float]
      [:Wrap, :Wrap, [:float, :float, :float], :float],

      # @!method FloatEquals(x, y)
      #   FloatEquals
      #   @param x [float]
      #   @param y [float]
      #   @return [int]
      [:FloatEquals, :FloatEquals, [:float, :float], :int],

      # @!method Vector2Zero()
      #   Vector2Zero
      #   @return [Vector2]
      [:Vector2Zero, :Vector2Zero, [], Vector2.by_value],

      # @!method Vector2One()
      #   Vector2One
      #   @return [Vector2]
      [:Vector2One, :Vector2One, [], Vector2.by_value],

      # @!method Vector2Add(v1, v2)
      #   Vector2Add
      #   @param v1 [Vector2]
      #   @param v2 [Vector2]
      #   @return [Vector2]
      [:Vector2Add, :Vector2Add, [Vector2.by_value, Vector2.by_value], Vector2.by_value],

      # @!method Vector2AddValue(v, add)
      #   Vector2AddValue
      #   @param v [Vector2]
      #   @param add [float]
      #   @return [Vector2]
      [:Vector2AddValue, :Vector2AddValue, [Vector2.by_value, :float], Vector2.by_value],

      # @!method Vector2Subtract(v1, v2)
      #   Vector2Subtract
      #   @param v1 [Vector2]
      #   @param v2 [Vector2]
      #   @return [Vector2]
      [:Vector2Subtract, :Vector2Subtract, [Vector2.by_value, Vector2.by_value], Vector2.by_value],

      # @!method Vector2SubtractValue(v, sub)
      #   Vector2SubtractValue
      #   @param v [Vector2]
      #   @param sub [float]
      #   @return [Vector2]
      [:Vector2SubtractValue, :Vector2SubtractValue, [Vector2.by_value, :float], Vector2.by_value],

      # @!method Vector2Length(v)
      #   Vector2Length
      #   @param v [Vector2]
      #   @return [float]
      [:Vector2Length, :Vector2Length, [Vector2.by_value], :float],

      # @!method Vector2LengthSqr(v)
      #   Vector2LengthSqr
      #   @param v [Vector2]
      #   @return [float]
      [:Vector2LengthSqr, :Vector2LengthSqr, [Vector2.by_value], :float],

      # @!method Vector2DotProduct(v1, v2)
      #   Vector2DotProduct
      #   @param v1 [Vector2]
      #   @param v2 [Vector2]
      #   @return [float]
      [:Vector2DotProduct, :Vector2DotProduct, [Vector2.by_value, Vector2.by_value], :float],

      # @!method Vector2Distance(v1, v2)
      #   Vector2Distance
      #   @param v1 [Vector2]
      #   @param v2 [Vector2]
      #   @return [float]
      [:Vector2Distance, :Vector2Distance, [Vector2.by_value, Vector2.by_value], :float],

      # @!method Vector2DistanceSqr(v1, v2)
      #   Vector2DistanceSqr
      #   @param v1 [Vector2]
      #   @param v2 [Vector2]
      #   @return [float]
      [:Vector2DistanceSqr, :Vector2DistanceSqr, [Vector2.by_value, Vector2.by_value], :float],

      # @!method Vector2Angle(v1, v2)
      #   Vector2Angle
      #   @param v1 [Vector2]
      #   @param v2 [Vector2]
      #   @return [float]
      [:Vector2Angle, :Vector2Angle, [Vector2.by_value, Vector2.by_value], :float],

      # @!method Vector2LineAngle(start, end)
      #   Vector2LineAngle
      #   @param start [Vector2]
      #   @param end [Vector2]
      #   @return [float]
      [:Vector2LineAngle, :Vector2LineAngle, [Vector2.by_value, Vector2.by_value], :float],

      # @!method Vector2Scale(v, scale)
      #   Vector2Scale
      #   @param v [Vector2]
      #   @param scale [float]
      #   @return [Vector2]
      [:Vector2Scale, :Vector2Scale, [Vector2.by_value, :float], Vector2.by_value],

      # @!method Vector2Multiply(v1, v2)
      #   Vector2Multiply
      #   @param v1 [Vector2]
      #   @param v2 [Vector2]
      #   @return [Vector2]
      [:Vector2Multiply, :Vector2Multiply, [Vector2.by_value, Vector2.by_value], Vector2.by_value],

      # @!method Vector2Negate(v)
      #   Vector2Negate
      #   @param v [Vector2]
      #   @return [Vector2]
      [:Vector2Negate, :Vector2Negate, [Vector2.by_value], Vector2.by_value],

      # @!method Vector2Divide(v1, v2)
      #   Vector2Divide
      #   @param v1 [Vector2]
      #   @param v2 [Vector2]
      #   @return [Vector2]
      [:Vector2Divide, :Vector2Divide, [Vector2.by_value, Vector2.by_value], Vector2.by_value],

      # @!method Vector2Normalize(v)
      #   Vector2Normalize
      #   @param v [Vector2]
      #   @return [Vector2]
      [:Vector2Normalize, :Vector2Normalize, [Vector2.by_value], Vector2.by_value],

      # @!method Vector2Transform(v, mat)
      #   Vector2Transform
      #   @param v [Vector2]
      #   @param mat [Matrix]
      #   @return [Vector2]
      [:Vector2Transform, :Vector2Transform, [Vector2.by_value, Matrix.by_value], Vector2.by_value],

      # @!method Vector2Lerp(v1, v2, amount)
      #   Vector2Lerp
      #   @param v1 [Vector2]
      #   @param v2 [Vector2]
      #   @param amount [float]
      #   @return [Vector2]
      [:Vector2Lerp, :Vector2Lerp, [Vector2.by_value, Vector2.by_value, :float], Vector2.by_value],

      # @!method Vector2Reflect(v, normal)
      #   Vector2Reflect
      #   @param v [Vector2]
      #   @param normal [Vector2]
      #   @return [Vector2]
      [:Vector2Reflect, :Vector2Reflect, [Vector2.by_value, Vector2.by_value], Vector2.by_value],

      # @!method Vector2Min(v1, v2)
      #   Vector2Min
      #   @param v1 [Vector2]
      #   @param v2 [Vector2]
      #   @return [Vector2]
      [:Vector2Min, :Vector2Min, [Vector2.by_value, Vector2.by_value], Vector2.by_value],

      # @!method Vector2Max(v1, v2)
      #   Vector2Max
      #   @param v1 [Vector2]
      #   @param v2 [Vector2]
      #   @return [Vector2]
      [:Vector2Max, :Vector2Max, [Vector2.by_value, Vector2.by_value], Vector2.by_value],

      # @!method Vector2Rotate(v, angle)
      #   Vector2Rotate
      #   @param v [Vector2]
      #   @param angle [float]
      #   @return [Vector2]
      [:Vector2Rotate, :Vector2Rotate, [Vector2.by_value, :float], Vector2.by_value],

      # @!method Vector2MoveTowards(v, target, maxDistance)
      #   Vector2MoveTowards
      #   @param v [Vector2]
      #   @param target [Vector2]
      #   @param maxDistance [float]
      #   @return [Vector2]
      [:Vector2MoveTowards, :Vector2MoveTowards, [Vector2.by_value, Vector2.by_value, :float], Vector2.by_value],

      # @!method Vector2Invert(v)
      #   Vector2Invert
      #   @param v [Vector2]
      #   @return [Vector2]
      [:Vector2Invert, :Vector2Invert, [Vector2.by_value], Vector2.by_value],

      # @!method Vector2Clamp(v, min, max)
      #   Vector2Clamp
      #   @param v [Vector2]
      #   @param min [Vector2]
      #   @param max [Vector2]
      #   @return [Vector2]
      [:Vector2Clamp, :Vector2Clamp, [Vector2.by_value, Vector2.by_value, Vector2.by_value], Vector2.by_value],

      # @!method Vector2ClampValue(v, min, max)
      #   Vector2ClampValue
      #   @param v [Vector2]
      #   @param min [float]
      #   @param max [float]
      #   @return [Vector2]
      [:Vector2ClampValue, :Vector2ClampValue, [Vector2.by_value, :float, :float], Vector2.by_value],

      # @!method Vector2Equals(p, q)
      #   Vector2Equals
      #   @param p [Vector2]
      #   @param q [Vector2]
      #   @return [int]
      [:Vector2Equals, :Vector2Equals, [Vector2.by_value, Vector2.by_value], :int],

      # @!method Vector2Refract(v, n, r)
      #   Vector2Refract
      #   @param v [Vector2]
      #   @param n [Vector2]
      #   @param r [float]
      #   @return [Vector2]
      [:Vector2Refract, :Vector2Refract, [Vector2.by_value, Vector2.by_value, :float], Vector2.by_value],

      # @!method Vector3Zero()
      #   Vector3Zero
      #   @return [Vector3]
      [:Vector3Zero, :Vector3Zero, [], Vector3.by_value],

      # @!method Vector3One()
      #   Vector3One
      #   @return [Vector3]
      [:Vector3One, :Vector3One, [], Vector3.by_value],

      # @!method Vector3Add(v1, v2)
      #   Vector3Add
      #   @param v1 [Vector3]
      #   @param v2 [Vector3]
      #   @return [Vector3]
      [:Vector3Add, :Vector3Add, [Vector3.by_value, Vector3.by_value], Vector3.by_value],

      # @!method Vector3AddValue(v, add)
      #   Vector3AddValue
      #   @param v [Vector3]
      #   @param add [float]
      #   @return [Vector3]
      [:Vector3AddValue, :Vector3AddValue, [Vector3.by_value, :float], Vector3.by_value],

      # @!method Vector3Subtract(v1, v2)
      #   Vector3Subtract
      #   @param v1 [Vector3]
      #   @param v2 [Vector3]
      #   @return [Vector3]
      [:Vector3Subtract, :Vector3Subtract, [Vector3.by_value, Vector3.by_value], Vector3.by_value],

      # @!method Vector3SubtractValue(v, sub)
      #   Vector3SubtractValue
      #   @param v [Vector3]
      #   @param sub [float]
      #   @return [Vector3]
      [:Vector3SubtractValue, :Vector3SubtractValue, [Vector3.by_value, :float], Vector3.by_value],

      # @!method Vector3Scale(v, scalar)
      #   Vector3Scale
      #   @param v [Vector3]
      #   @param scalar [float]
      #   @return [Vector3]
      [:Vector3Scale, :Vector3Scale, [Vector3.by_value, :float], Vector3.by_value],

      # @!method Vector3Multiply(v1, v2)
      #   Vector3Multiply
      #   @param v1 [Vector3]
      #   @param v2 [Vector3]
      #   @return [Vector3]
      [:Vector3Multiply, :Vector3Multiply, [Vector3.by_value, Vector3.by_value], Vector3.by_value],

      # @!method Vector3CrossProduct(v1, v2)
      #   Vector3CrossProduct
      #   @param v1 [Vector3]
      #   @param v2 [Vector3]
      #   @return [Vector3]
      [:Vector3CrossProduct, :Vector3CrossProduct, [Vector3.by_value, Vector3.by_value], Vector3.by_value],

      # @!method Vector3Perpendicular(v)
      #   Vector3Perpendicular
      #   @param v [Vector3]
      #   @return [Vector3]
      [:Vector3Perpendicular, :Vector3Perpendicular, [Vector3.by_value], Vector3.by_value],

      # @!method Vector3Length(v)
      #   Vector3Length
      #   @param v [const Vector3]
      #   @return [float]
      [:Vector3Length, :Vector3Length, [Vector3.by_value], :float],

      # @!method Vector3LengthSqr(v)
      #   Vector3LengthSqr
      #   @param v [const Vector3]
      #   @return [float]
      [:Vector3LengthSqr, :Vector3LengthSqr, [Vector3.by_value], :float],

      # @!method Vector3DotProduct(v1, v2)
      #   Vector3DotProduct
      #   @param v1 [Vector3]
      #   @param v2 [Vector3]
      #   @return [float]
      [:Vector3DotProduct, :Vector3DotProduct, [Vector3.by_value, Vector3.by_value], :float],

      # @!method Vector3Distance(v1, v2)
      #   Vector3Distance
      #   @param v1 [Vector3]
      #   @param v2 [Vector3]
      #   @return [float]
      [:Vector3Distance, :Vector3Distance, [Vector3.by_value, Vector3.by_value], :float],

      # @!method Vector3DistanceSqr(v1, v2)
      #   Vector3DistanceSqr
      #   @param v1 [Vector3]
      #   @param v2 [Vector3]
      #   @return [float]
      [:Vector3DistanceSqr, :Vector3DistanceSqr, [Vector3.by_value, Vector3.by_value], :float],

      # @!method Vector3Angle(v1, v2)
      #   Vector3Angle
      #   @param v1 [Vector3]
      #   @param v2 [Vector3]
      #   @return [float]
      [:Vector3Angle, :Vector3Angle, [Vector3.by_value, Vector3.by_value], :float],

      # @!method Vector3Negate(v)
      #   Vector3Negate
      #   @param v [Vector3]
      #   @return [Vector3]
      [:Vector3Negate, :Vector3Negate, [Vector3.by_value], Vector3.by_value],

      # @!method Vector3Divide(v1, v2)
      #   Vector3Divide
      #   @param v1 [Vector3]
      #   @param v2 [Vector3]
      #   @return [Vector3]
      [:Vector3Divide, :Vector3Divide, [Vector3.by_value, Vector3.by_value], Vector3.by_value],

      # @!method Vector3Normalize(v)
      #   Vector3Normalize
      #   @param v [Vector3]
      #   @return [Vector3]
      [:Vector3Normalize, :Vector3Normalize, [Vector3.by_value], Vector3.by_value],

      # @!method Vector3Project(v1, v2)
      #   Vector3Project
      #   @param v1 [Vector3]
      #   @param v2 [Vector3]
      #   @return [Vector3]
      [:Vector3Project, :Vector3Project, [Vector3.by_value, Vector3.by_value], Vector3.by_value],

      # @!method Vector3Reject(v1, v2)
      #   Vector3Reject
      #   @param v1 [Vector3]
      #   @param v2 [Vector3]
      #   @return [Vector3]
      [:Vector3Reject, :Vector3Reject, [Vector3.by_value, Vector3.by_value], Vector3.by_value],

      # @!method Vector3OrthoNormalize(v1, v2)
      #   Vector3OrthoNormalize
      #   @param v1 [Vector3 *]
      #   @param v2 [Vector3 *]
      #   @return [void]
      [:Vector3OrthoNormalize, :Vector3OrthoNormalize, [:pointer, :pointer], :void],

      # @!method Vector3Transform(v, mat)
      #   Vector3Transform
      #   @param v [Vector3]
      #   @param mat [Matrix]
      #   @return [Vector3]
      [:Vector3Transform, :Vector3Transform, [Vector3.by_value, Matrix.by_value], Vector3.by_value],

      # @!method Vector3RotateByQuaternion(v, q)
      #   Vector3RotateByQuaternion
      #   @param v [Vector3]
      #   @param q [Quaternion]
      #   @return [Vector3]
      [:Vector3RotateByQuaternion, :Vector3RotateByQuaternion, [Vector3.by_value, Quaternion.by_value], Vector3.by_value],

      # @!method Vector3RotateByAxisAngle(v, axis, angle)
      #   Vector3RotateByAxisAngle
      #   @param v [Vector3]
      #   @param axis [Vector3]
      #   @param angle [float]
      #   @return [Vector3]
      [:Vector3RotateByAxisAngle, :Vector3RotateByAxisAngle, [Vector3.by_value, Vector3.by_value, :float], Vector3.by_value],

      # @!method Vector3MoveTowards(v, target, maxDistance)
      #   Vector3MoveTowards
      #   @param v [Vector3]
      #   @param target [Vector3]
      #   @param maxDistance [float]
      #   @return [Vector3]
      [:Vector3MoveTowards, :Vector3MoveTowards, [Vector3.by_value, Vector3.by_value, :float], Vector3.by_value],

      # @!method Vector3Lerp(v1, v2, amount)
      #   Vector3Lerp
      #   @param v1 [Vector3]
      #   @param v2 [Vector3]
      #   @param amount [float]
      #   @return [Vector3]
      [:Vector3Lerp, :Vector3Lerp, [Vector3.by_value, Vector3.by_value, :float], Vector3.by_value],

      # @!method Vector3Reflect(v, normal)
      #   Vector3Reflect
      #   @param v [Vector3]
      #   @param normal [Vector3]
      #   @return [Vector3]
      [:Vector3Reflect, :Vector3Reflect, [Vector3.by_value, Vector3.by_value], Vector3.by_value],

      # @!method Vector3Min(v1, v2)
      #   Vector3Min
      #   @param v1 [Vector3]
      #   @param v2 [Vector3]
      #   @return [Vector3]
      [:Vector3Min, :Vector3Min, [Vector3.by_value, Vector3.by_value], Vector3.by_value],

      # @!method Vector3Max(v1, v2)
      #   Vector3Max
      #   @param v1 [Vector3]
      #   @param v2 [Vector3]
      #   @return [Vector3]
      [:Vector3Max, :Vector3Max, [Vector3.by_value, Vector3.by_value], Vector3.by_value],

      # @!method Vector3Barycenter(p, a, b, c)
      #   Vector3Barycenter
      #   @param p [Vector3]
      #   @param a [Vector3]
      #   @param b [Vector3]
      #   @param c [Vector3]
      #   @return [Vector3]
      [:Vector3Barycenter, :Vector3Barycenter, [Vector3.by_value, Vector3.by_value, Vector3.by_value, Vector3.by_value], Vector3.by_value],

      # @!method Vector3Unproject(source, projection, view)
      #   Vector3Unproject
      #   @param source [Vector3]
      #   @param projection [Matrix]
      #   @param view [Matrix]
      #   @return [Vector3]
      [:Vector3Unproject, :Vector3Unproject, [Vector3.by_value, Matrix.by_value, Matrix.by_value], Vector3.by_value],

      # @!method Vector3ToFloatV(v)
      #   Vector3ToFloatV
      #   @param v [Vector3]
      #   @return [float3]
      [:Vector3ToFloatV, :Vector3ToFloatV, [Vector3.by_value], Float3.by_value],

      # @!method Vector3Invert(v)
      #   Vector3Invert
      #   @param v [Vector3]
      #   @return [Vector3]
      [:Vector3Invert, :Vector3Invert, [Vector3.by_value], Vector3.by_value],

      # @!method Vector3Clamp(v, min, max)
      #   Vector3Clamp
      #   @param v [Vector3]
      #   @param min [Vector3]
      #   @param max [Vector3]
      #   @return [Vector3]
      [:Vector3Clamp, :Vector3Clamp, [Vector3.by_value, Vector3.by_value, Vector3.by_value], Vector3.by_value],

      # @!method Vector3ClampValue(v, min, max)
      #   Vector3ClampValue
      #   @param v [Vector3]
      #   @param min [float]
      #   @param max [float]
      #   @return [Vector3]
      [:Vector3ClampValue, :Vector3ClampValue, [Vector3.by_value, :float, :float], Vector3.by_value],

      # @!method Vector3Equals(p, q)
      #   Vector3Equals
      #   @param p [Vector3]
      #   @param q [Vector3]
      #   @return [int]
      [:Vector3Equals, :Vector3Equals, [Vector3.by_value, Vector3.by_value], :int],

      # @!method Vector3Refract(v, n, r)
      #   Vector3Refract
      #   @param v [Vector3]
      #   @param n [Vector3]
      #   @param r [float]
      #   @return [Vector3]
      [:Vector3Refract, :Vector3Refract, [Vector3.by_value, Vector3.by_value, :float], Vector3.by_value],

      # @!method Vector4Zero()
      #   Vector4Zero
      #   @return [Vector4]
      [:Vector4Zero, :Vector4Zero, [], Vector4.by_value],

      # @!method Vector4One()
      #   Vector4One
      #   @return [Vector4]
      [:Vector4One, :Vector4One, [], Vector4.by_value],

      # @!method Vector4Add(v1, v2)
      #   Vector4Add
      #   @param v1 [Vector4]
      #   @param v2 [Vector4]
      #   @return [Vector4]
      [:Vector4Add, :Vector4Add, [Vector4.by_value, Vector4.by_value], Vector4.by_value],

      # @!method Vector4AddValue(v, add)
      #   Vector4AddValue
      #   @param v [Vector4]
      #   @param add [float]
      #   @return [Vector4]
      [:Vector4AddValue, :Vector4AddValue, [Vector4.by_value, :float], Vector4.by_value],

      # @!method Vector4Subtract(v1, v2)
      #   Vector4Subtract
      #   @param v1 [Vector4]
      #   @param v2 [Vector4]
      #   @return [Vector4]
      [:Vector4Subtract, :Vector4Subtract, [Vector4.by_value, Vector4.by_value], Vector4.by_value],

      # @!method Vector4SubtractValue(v, add)
      #   Vector4SubtractValue
      #   @param v [Vector4]
      #   @param add [float]
      #   @return [Vector4]
      [:Vector4SubtractValue, :Vector4SubtractValue, [Vector4.by_value, :float], Vector4.by_value],

      # @!method Vector4Length(v)
      #   Vector4Length
      #   @param v [Vector4]
      #   @return [float]
      [:Vector4Length, :Vector4Length, [Vector4.by_value], :float],

      # @!method Vector4LengthSqr(v)
      #   Vector4LengthSqr
      #   @param v [Vector4]
      #   @return [float]
      [:Vector4LengthSqr, :Vector4LengthSqr, [Vector4.by_value], :float],

      # @!method Vector4DotProduct(v1, v2)
      #   Vector4DotProduct
      #   @param v1 [Vector4]
      #   @param v2 [Vector4]
      #   @return [float]
      [:Vector4DotProduct, :Vector4DotProduct, [Vector4.by_value, Vector4.by_value], :float],

      # @!method Vector4Distance(v1, v2)
      #   Vector4Distance
      #   @param v1 [Vector4]
      #   @param v2 [Vector4]
      #   @return [float]
      [:Vector4Distance, :Vector4Distance, [Vector4.by_value, Vector4.by_value], :float],

      # @!method Vector4DistanceSqr(v1, v2)
      #   Vector4DistanceSqr
      #   @param v1 [Vector4]
      #   @param v2 [Vector4]
      #   @return [float]
      [:Vector4DistanceSqr, :Vector4DistanceSqr, [Vector4.by_value, Vector4.by_value], :float],

      # @!method Vector4Scale(v, scale)
      #   Vector4Scale
      #   @param v [Vector4]
      #   @param scale [float]
      #   @return [Vector4]
      [:Vector4Scale, :Vector4Scale, [Vector4.by_value, :float], Vector4.by_value],

      # @!method Vector4Multiply(v1, v2)
      #   Vector4Multiply
      #   @param v1 [Vector4]
      #   @param v2 [Vector4]
      #   @return [Vector4]
      [:Vector4Multiply, :Vector4Multiply, [Vector4.by_value, Vector4.by_value], Vector4.by_value],

      # @!method Vector4Negate(v)
      #   Vector4Negate
      #   @param v [Vector4]
      #   @return [Vector4]
      [:Vector4Negate, :Vector4Negate, [Vector4.by_value], Vector4.by_value],

      # @!method Vector4Divide(v1, v2)
      #   Vector4Divide
      #   @param v1 [Vector4]
      #   @param v2 [Vector4]
      #   @return [Vector4]
      [:Vector4Divide, :Vector4Divide, [Vector4.by_value, Vector4.by_value], Vector4.by_value],

      # @!method Vector4Normalize(v)
      #   Vector4Normalize
      #   @param v [Vector4]
      #   @return [Vector4]
      [:Vector4Normalize, :Vector4Normalize, [Vector4.by_value], Vector4.by_value],

      # @!method Vector4Min(v1, v2)
      #   Vector4Min
      #   @param v1 [Vector4]
      #   @param v2 [Vector4]
      #   @return [Vector4]
      [:Vector4Min, :Vector4Min, [Vector4.by_value, Vector4.by_value], Vector4.by_value],

      # @!method Vector4Max(v1, v2)
      #   Vector4Max
      #   @param v1 [Vector4]
      #   @param v2 [Vector4]
      #   @return [Vector4]
      [:Vector4Max, :Vector4Max, [Vector4.by_value, Vector4.by_value], Vector4.by_value],

      # @!method Vector4Lerp(v1, v2, amount)
      #   Vector4Lerp
      #   @param v1 [Vector4]
      #   @param v2 [Vector4]
      #   @param amount [float]
      #   @return [Vector4]
      [:Vector4Lerp, :Vector4Lerp, [Vector4.by_value, Vector4.by_value, :float], Vector4.by_value],

      # @!method Vector4MoveTowards(v, target, maxDistance)
      #   Vector4MoveTowards
      #   @param v [Vector4]
      #   @param target [Vector4]
      #   @param maxDistance [float]
      #   @return [Vector4]
      [:Vector4MoveTowards, :Vector4MoveTowards, [Vector4.by_value, Vector4.by_value, :float], Vector4.by_value],

      # @!method Vector4Invert(v)
      #   Vector4Invert
      #   @param v [Vector4]
      #   @return [Vector4]
      [:Vector4Invert, :Vector4Invert, [Vector4.by_value], Vector4.by_value],

      # @!method Vector4Equals(p, q)
      #   Vector4Equals
      #   @param p [Vector4]
      #   @param q [Vector4]
      #   @return [int]
      [:Vector4Equals, :Vector4Equals, [Vector4.by_value, Vector4.by_value], :int],

      # @!method MatrixDeterminant(mat)
      #   MatrixDeterminant
      #   @param mat [Matrix]
      #   @return [float]
      [:MatrixDeterminant, :MatrixDeterminant, [Matrix.by_value], :float],

      # @!method MatrixTrace(mat)
      #   MatrixTrace
      #   @param mat [Matrix]
      #   @return [float]
      [:MatrixTrace, :MatrixTrace, [Matrix.by_value], :float],

      # @!method MatrixTranspose(mat)
      #   MatrixTranspose
      #   @param mat [Matrix]
      #   @return [Matrix]
      [:MatrixTranspose, :MatrixTranspose, [Matrix.by_value], Matrix.by_value],

      # @!method MatrixInvert(mat)
      #   MatrixInvert
      #   @param mat [Matrix]
      #   @return [Matrix]
      [:MatrixInvert, :MatrixInvert, [Matrix.by_value], Matrix.by_value],

      # @!method MatrixIdentity()
      #   MatrixIdentity
      #   @return [Matrix]
      [:MatrixIdentity, :MatrixIdentity, [], Matrix.by_value],

      # @!method MatrixAdd(left, right)
      #   MatrixAdd
      #   @param left [Matrix]
      #   @param right [Matrix]
      #   @return [Matrix]
      [:MatrixAdd, :MatrixAdd, [Matrix.by_value, Matrix.by_value], Matrix.by_value],

      # @!method MatrixSubtract(left, right)
      #   MatrixSubtract
      #   @param left [Matrix]
      #   @param right [Matrix]
      #   @return [Matrix]
      [:MatrixSubtract, :MatrixSubtract, [Matrix.by_value, Matrix.by_value], Matrix.by_value],

      # @!method MatrixMultiply(left, right)
      #   MatrixMultiply
      #   @param left [Matrix]
      #   @param right [Matrix]
      #   @return [Matrix]
      [:MatrixMultiply, :MatrixMultiply, [Matrix.by_value, Matrix.by_value], Matrix.by_value],

      # @!method MatrixTranslate(x, y, z)
      #   MatrixTranslate
      #   @param x [float]
      #   @param y [float]
      #   @param z [float]
      #   @return [Matrix]
      [:MatrixTranslate, :MatrixTranslate, [:float, :float, :float], Matrix.by_value],

      # @!method MatrixRotate(axis, angle)
      #   MatrixRotate
      #   @param axis [Vector3]
      #   @param angle [float]
      #   @return [Matrix]
      [:MatrixRotate, :MatrixRotate, [Vector3.by_value, :float], Matrix.by_value],

      # @!method MatrixRotateX(angle)
      #   MatrixRotateX
      #   @param angle [float]
      #   @return [Matrix]
      [:MatrixRotateX, :MatrixRotateX, [:float], Matrix.by_value],

      # @!method MatrixRotateY(angle)
      #   MatrixRotateY
      #   @param angle [float]
      #   @return [Matrix]
      [:MatrixRotateY, :MatrixRotateY, [:float], Matrix.by_value],

      # @!method MatrixRotateZ(angle)
      #   MatrixRotateZ
      #   @param angle [float]
      #   @return [Matrix]
      [:MatrixRotateZ, :MatrixRotateZ, [:float], Matrix.by_value],

      # @!method MatrixRotateXYZ(angle)
      #   MatrixRotateXYZ
      #   @param angle [Vector3]
      #   @return [Matrix]
      [:MatrixRotateXYZ, :MatrixRotateXYZ, [Vector3.by_value], Matrix.by_value],

      # @!method MatrixRotateZYX(angle)
      #   MatrixRotateZYX
      #   @param angle [Vector3]
      #   @return [Matrix]
      [:MatrixRotateZYX, :MatrixRotateZYX, [Vector3.by_value], Matrix.by_value],

      # @!method MatrixScale(x, y, z)
      #   MatrixScale
      #   @param x [float]
      #   @param y [float]
      #   @param z [float]
      #   @return [Matrix]
      [:MatrixScale, :MatrixScale, [:float, :float, :float], Matrix.by_value],

      # @!method MatrixFrustum(left, right, bottom, top, near, far)
      #   MatrixFrustum
      #   @param left [double]
      #   @param right [double]
      #   @param bottom [double]
      #   @param top [double]
      #   @param near [double]
      #   @param far [double]
      #   @return [Matrix]
      [:MatrixFrustum, :MatrixFrustum, [:double, :double, :double, :double, :double, :double], Matrix.by_value],

      # @!method MatrixPerspective(fovY, aspect, nearPlane, farPlane)
      #   MatrixPerspective
      #   @param fovY [double]
      #   @param aspect [double]
      #   @param nearPlane [double]
      #   @param farPlane [double]
      #   @return [Matrix]
      [:MatrixPerspective, :MatrixPerspective, [:double, :double, :double, :double], Matrix.by_value],

      # @!method MatrixOrtho(left, right, bottom, top, nearPlane, farPlane)
      #   MatrixOrtho
      #   @param left [double]
      #   @param right [double]
      #   @param bottom [double]
      #   @param top [double]
      #   @param nearPlane [double]
      #   @param farPlane [double]
      #   @return [Matrix]
      [:MatrixOrtho, :MatrixOrtho, [:double, :double, :double, :double, :double, :double], Matrix.by_value],

      # @!method MatrixLookAt(eye, target, up)
      #   MatrixLookAt
      #   @param eye [Vector3]
      #   @param target [Vector3]
      #   @param up [Vector3]
      #   @return [Matrix]
      [:MatrixLookAt, :MatrixLookAt, [Vector3.by_value, Vector3.by_value, Vector3.by_value], Matrix.by_value],

      # @!method MatrixToFloatV(mat)
      #   MatrixToFloatV
      #   @param mat [Matrix]
      #   @return [float16]
      [:MatrixToFloatV, :MatrixToFloatV, [Matrix.by_value], Float16.by_value],

      # @!method QuaternionAdd(q1, q2)
      #   QuaternionAdd
      #   @param q1 [Quaternion]
      #   @param q2 [Quaternion]
      #   @return [Quaternion]
      [:QuaternionAdd, :QuaternionAdd, [Quaternion.by_value, Quaternion.by_value], Quaternion.by_value],

      # @!method QuaternionAddValue(q, add)
      #   QuaternionAddValue
      #   @param q [Quaternion]
      #   @param add [float]
      #   @return [Quaternion]
      [:QuaternionAddValue, :QuaternionAddValue, [Quaternion.by_value, :float], Quaternion.by_value],

      # @!method QuaternionSubtract(q1, q2)
      #   QuaternionSubtract
      #   @param q1 [Quaternion]
      #   @param q2 [Quaternion]
      #   @return [Quaternion]
      [:QuaternionSubtract, :QuaternionSubtract, [Quaternion.by_value, Quaternion.by_value], Quaternion.by_value],

      # @!method QuaternionSubtractValue(q, sub)
      #   QuaternionSubtractValue
      #   @param q [Quaternion]
      #   @param sub [float]
      #   @return [Quaternion]
      [:QuaternionSubtractValue, :QuaternionSubtractValue, [Quaternion.by_value, :float], Quaternion.by_value],

      # @!method QuaternionIdentity()
      #   QuaternionIdentity
      #   @return [Quaternion]
      [:QuaternionIdentity, :QuaternionIdentity, [], Quaternion.by_value],

      # @!method QuaternionLength(q)
      #   QuaternionLength
      #   @param q [Quaternion]
      #   @return [float]
      [:QuaternionLength, :QuaternionLength, [Quaternion.by_value], :float],

      # @!method QuaternionNormalize(q)
      #   QuaternionNormalize
      #   @param q [Quaternion]
      #   @return [Quaternion]
      [:QuaternionNormalize, :QuaternionNormalize, [Quaternion.by_value], Quaternion.by_value],

      # @!method QuaternionInvert(q)
      #   QuaternionInvert
      #   @param q [Quaternion]
      #   @return [Quaternion]
      [:QuaternionInvert, :QuaternionInvert, [Quaternion.by_value], Quaternion.by_value],

      # @!method QuaternionMultiply(q1, q2)
      #   QuaternionMultiply
      #   @param q1 [Quaternion]
      #   @param q2 [Quaternion]
      #   @return [Quaternion]
      [:QuaternionMultiply, :QuaternionMultiply, [Quaternion.by_value, Quaternion.by_value], Quaternion.by_value],

      # @!method QuaternionScale(q, mul)
      #   QuaternionScale
      #   @param q [Quaternion]
      #   @param mul [float]
      #   @return [Quaternion]
      [:QuaternionScale, :QuaternionScale, [Quaternion.by_value, :float], Quaternion.by_value],

      # @!method QuaternionDivide(q1, q2)
      #   QuaternionDivide
      #   @param q1 [Quaternion]
      #   @param q2 [Quaternion]
      #   @return [Quaternion]
      [:QuaternionDivide, :QuaternionDivide, [Quaternion.by_value, Quaternion.by_value], Quaternion.by_value],

      # @!method QuaternionLerp(q1, q2, amount)
      #   QuaternionLerp
      #   @param q1 [Quaternion]
      #   @param q2 [Quaternion]
      #   @param amount [float]
      #   @return [Quaternion]
      [:QuaternionLerp, :QuaternionLerp, [Quaternion.by_value, Quaternion.by_value, :float], Quaternion.by_value],

      # @!method QuaternionNlerp(q1, q2, amount)
      #   QuaternionNlerp
      #   @param q1 [Quaternion]
      #   @param q2 [Quaternion]
      #   @param amount [float]
      #   @return [Quaternion]
      [:QuaternionNlerp, :QuaternionNlerp, [Quaternion.by_value, Quaternion.by_value, :float], Quaternion.by_value],

      # @!method QuaternionSlerp(q1, q2, amount)
      #   QuaternionSlerp
      #   @param q1 [Quaternion]
      #   @param q2 [Quaternion]
      #   @param amount [float]
      #   @return [Quaternion]
      [:QuaternionSlerp, :QuaternionSlerp, [Quaternion.by_value, Quaternion.by_value, :float], Quaternion.by_value],

      # @!method QuaternionFromVector3ToVector3(from, to)
      #   QuaternionFromVector3ToVector3
      #   @param from [Vector3]
      #   @param to [Vector3]
      #   @return [Quaternion]
      [:QuaternionFromVector3ToVector3, :QuaternionFromVector3ToVector3, [Vector3.by_value, Vector3.by_value], Quaternion.by_value],

      # @!method QuaternionFromMatrix(mat)
      #   QuaternionFromMatrix
      #   @param mat [Matrix]
      #   @return [Quaternion]
      [:QuaternionFromMatrix, :QuaternionFromMatrix, [Matrix.by_value], Quaternion.by_value],

      # @!method QuaternionToMatrix(q)
      #   QuaternionToMatrix
      #   @param q [Quaternion]
      #   @return [Matrix]
      [:QuaternionToMatrix, :QuaternionToMatrix, [Quaternion.by_value], Matrix.by_value],

      # @!method QuaternionFromAxisAngle(axis, angle)
      #   QuaternionFromAxisAngle
      #   @param axis [Vector3]
      #   @param angle [float]
      #   @return [Quaternion]
      [:QuaternionFromAxisAngle, :QuaternionFromAxisAngle, [Vector3.by_value, :float], Quaternion.by_value],

      # @!method QuaternionToAxisAngle(q, outAxis, outAngle)
      #   QuaternionToAxisAngle
      #   @param q [Quaternion]
      #   @param outAxis [Vector3 *]
      #   @param outAngle [float *]
      #   @return [void]
      [:QuaternionToAxisAngle, :QuaternionToAxisAngle, [Quaternion.by_value, :pointer, :pointer], :void],

      # @!method QuaternionFromEuler(pitch, yaw, roll)
      #   QuaternionFromEuler
      #   @param pitch [float]
      #   @param yaw [float]
      #   @param roll [float]
      #   @return [Quaternion]
      [:QuaternionFromEuler, :QuaternionFromEuler, [:float, :float, :float], Quaternion.by_value],

      # @!method QuaternionToEuler(q)
      #   QuaternionToEuler
      #   @param q [Quaternion]
      #   @return [Vector3]
      [:QuaternionToEuler, :QuaternionToEuler, [Quaternion.by_value], Vector3.by_value],

      # @!method QuaternionTransform(q, mat)
      #   QuaternionTransform
      #   @param q [Quaternion]
      #   @param mat [Matrix]
      #   @return [Quaternion]
      [:QuaternionTransform, :QuaternionTransform, [Quaternion.by_value, Matrix.by_value], Quaternion.by_value],

      # @!method QuaternionEquals(p, q)
      #   QuaternionEquals
      #   @param p [Quaternion]
      #   @param q [Quaternion]
      #   @return [int]
      [:QuaternionEquals, :QuaternionEquals, [Quaternion.by_value, Quaternion.by_value], :int],
    ]
    entries.each do |entry|
      api_name = if method_naming == :snake_case
                   snake_case_name = entry[0].to_s.gsub(/([A-Z]+)([A-Z0-9][a-z])/, '\1_\2').gsub(/([a-z\d])([A-Z0-9])/, '\1_\2').downcase
                   snake_case_name.gsub!('vector_3', 'vector3_') if snake_case_name.include?('vector_3')
                   snake_case_name.gsub!('vector_2', 'vector2_') if snake_case_name.include?('vector_2')
                   snake_case_name.chop! if snake_case_name.end_with?('_')
                   snake_case_name.to_sym
                 else
                   entry[0]
                 end
      attach_function api_name, entry[1], entry[2], entry[3]
    rescue FFI::NotFoundError => e
      warn "[Warning] Failed to import #{entry[0]} (#{e})."
    end
  end
end
