# Yet another raylib wrapper for Ruby
#
# * https://github.com/vaiorabbit/raylib-bindings
#
# [NOTICE] Autogenerated. Do not edit.

require 'ffi'

module Raylib
  extend FFI::Library

  # Define/Macro

  RLGL_VERSION = "5.0"
  RL_DEFAULT_BATCH_BUFFER_ELEMENTS = 8192
  RL_TEXTURE_WRAP_S = 0x2802                    # GL_TEXTURE_WRAP_S
  RL_TEXTURE_WRAP_T = 0x2803                    # GL_TEXTURE_WRAP_T
  RL_TEXTURE_MAG_FILTER = 0x2800                # GL_TEXTURE_MAG_FILTER
  RL_TEXTURE_MIN_FILTER = 0x2801                # GL_TEXTURE_MIN_FILTER
  RL_TEXTURE_FILTER_NEAREST = 0x2600            # GL_NEAREST
  RL_TEXTURE_FILTER_LINEAR = 0x2601             # GL_LINEAR
  RL_TEXTURE_FILTER_MIP_NEAREST = 0x2700        # GL_NEAREST_MIPMAP_NEAREST
  RL_TEXTURE_FILTER_NEAREST_MIP_LINEAR = 0x2702 # GL_NEAREST_MIPMAP_LINEAR
  RL_TEXTURE_FILTER_LINEAR_MIP_NEAREST = 0x2701 # GL_LINEAR_MIPMAP_NEAREST
  RL_TEXTURE_FILTER_MIP_LINEAR = 0x2703         # GL_LINEAR_MIPMAP_LINEAR
  RL_TEXTURE_FILTER_ANISOTROPIC = 0x3000        # Anisotropic filter (custom identifier)
  RL_TEXTURE_MIPMAP_BIAS_RATIO = 0x4000         # Texture mipmap bias, percentage ratio (custom identifier)
  RL_TEXTURE_WRAP_REPEAT = 0x2901               # GL_REPEAT
  RL_TEXTURE_WRAP_CLAMP = 0x812F                # GL_CLAMP_TO_EDGE
  RL_TEXTURE_WRAP_MIRROR_REPEAT = 0x8370        # GL_MIRRORED_REPEAT
  RL_TEXTURE_WRAP_MIRROR_CLAMP = 0x8742         # GL_MIRROR_CLAMP_EXT
  RL_MODELVIEW = 0x1700                         # GL_MODELVIEW
  RL_PROJECTION = 0x1701                        # GL_PROJECTION
  RL_TEXTURE = 0x1702                           # GL_TEXTURE
  RL_LINES = 0x0001                             # GL_LINES
  RL_TRIANGLES = 0x0004                         # GL_TRIANGLES
  RL_QUADS = 0x0007                             # GL_QUADS
  RL_UNSIGNED_BYTE = 0x1401                     # GL_UNSIGNED_BYTE
  RL_FLOAT = 0x1406                             # GL_FLOAT
  RL_STREAM_DRAW = 0x88E0                       # GL_STREAM_DRAW
  RL_STREAM_READ = 0x88E1                       # GL_STREAM_READ
  RL_STREAM_COPY = 0x88E2                       # GL_STREAM_COPY
  RL_STATIC_DRAW = 0x88E4                       # GL_STATIC_DRAW
  RL_STATIC_READ = 0x88E5                       # GL_STATIC_READ
  RL_STATIC_COPY = 0x88E6                       # GL_STATIC_COPY
  RL_DYNAMIC_DRAW = 0x88E8                      # GL_DYNAMIC_DRAW
  RL_DYNAMIC_READ = 0x88E9                      # GL_DYNAMIC_READ
  RL_DYNAMIC_COPY = 0x88EA                      # GL_DYNAMIC_COPY
  RL_FRAGMENT_SHADER = 0x8B30                   # GL_FRAGMENT_SHADER
  RL_VERTEX_SHADER = 0x8B31                     # GL_VERTEX_SHADER
  RL_COMPUTE_SHADER = 0x91B9                    # GL_COMPUTE_SHADER
  RL_ZERO = 0                                   # GL_ZERO
  RL_ONE = 1                                    # GL_ONE
  RL_SRC_COLOR = 0x0300                         # GL_SRC_COLOR
  RL_ONE_MINUS_SRC_COLOR = 0x0301               # GL_ONE_MINUS_SRC_COLOR
  RL_SRC_ALPHA = 0x0302                         # GL_SRC_ALPHA
  RL_ONE_MINUS_SRC_ALPHA = 0x0303               # GL_ONE_MINUS_SRC_ALPHA
  RL_DST_ALPHA = 0x0304                         # GL_DST_ALPHA
  RL_ONE_MINUS_DST_ALPHA = 0x0305               # GL_ONE_MINUS_DST_ALPHA
  RL_DST_COLOR = 0x0306                         # GL_DST_COLOR
  RL_ONE_MINUS_DST_COLOR = 0x0307               # GL_ONE_MINUS_DST_COLOR
  RL_SRC_ALPHA_SATURATE = 0x0308                # GL_SRC_ALPHA_SATURATE
  RL_CONSTANT_COLOR = 0x8001                    # GL_CONSTANT_COLOR
  RL_ONE_MINUS_CONSTANT_COLOR = 0x8002          # GL_ONE_MINUS_CONSTANT_COLOR
  RL_CONSTANT_ALPHA = 0x8003                    # GL_CONSTANT_ALPHA
  RL_ONE_MINUS_CONSTANT_ALPHA = 0x8004          # GL_ONE_MINUS_CONSTANT_ALPHA
  RL_FUNC_ADD = 0x8006                          # GL_FUNC_ADD
  RL_MIN = 0x8007                               # GL_MIN
  RL_MAX = 0x8008                               # GL_MAX
  RL_FUNC_SUBTRACT = 0x800A                     # GL_FUNC_SUBTRACT
  RL_FUNC_REVERSE_SUBTRACT = 0x800B             # GL_FUNC_REVERSE_SUBTRACT
  RL_BLEND_EQUATION = 0x8009                    # GL_BLEND_EQUATION
  RL_BLEND_EQUATION_RGB = 0x8009                # GL_BLEND_EQUATION_RGB   // (Same as BLEND_EQUATION)
  RL_BLEND_EQUATION_ALPHA = 0x883D              # GL_BLEND_EQUATION_ALPHA
  RL_BLEND_DST_RGB = 0x80C8                     # GL_BLEND_DST_RGB
  RL_BLEND_SRC_RGB = 0x80C9                     # GL_BLEND_SRC_RGB
  RL_BLEND_DST_ALPHA = 0x80CA                   # GL_BLEND_DST_ALPHA
  RL_BLEND_SRC_ALPHA = 0x80CB                   # GL_BLEND_SRC_ALPHA
  RL_BLEND_COLOR = 0x8005                       # GL_BLEND_COLOR
  RL_READ_FRAMEBUFFER = 0x8CA8                  # GL_READ_FRAMEBUFFER
  RL_DRAW_FRAMEBUFFER = 0x8CA9                  # GL_DRAW_FRAMEBUFFER

  # Enum

  # enum rlGlVersion
  # OpenGL version
  RL_OPENGL_11 = 1    # OpenGL 1.1
  RL_OPENGL_21 = 2    # OpenGL 2.1 (GLSL 120)
  RL_OPENGL_33 = 3    # OpenGL 3.3 (GLSL 330)
  RL_OPENGL_43 = 4    # OpenGL 4.3 (using GLSL 330)
  RL_OPENGL_ES_20 = 5 # OpenGL ES 2.0 (GLSL 100)
  RL_OPENGL_ES_30 = 6 # OpenGL ES 3.0 (GLSL 300 es)

  # enum rlTraceLogLevel
  # Trace log level
  RL_LOG_ALL = 0     # Display all logs
  RL_LOG_TRACE = 1   # Trace logging, intended for internal use only
  RL_LOG_DEBUG = 2   # Debug logging, used for internal debugging, it should be disabled on release builds
  RL_LOG_INFO = 3    # Info logging, used for program execution info
  RL_LOG_WARNING = 4 # Warning logging, used on recoverable failures
  RL_LOG_ERROR = 5   # Error logging, used on unrecoverable failures
  RL_LOG_FATAL = 6   # Fatal logging, used to abort program: exit(EXIT_FAILURE)
  RL_LOG_NONE = 7    # Disable logging

  # enum rlPixelFormat
  # Texture pixel formats
  RL_PIXELFORMAT_UNCOMPRESSED_GRAYSCALE = 1     # 8 bit per pixel (no alpha)
  RL_PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA = 2    # 8*2 bpp (2 channels)
  RL_PIXELFORMAT_UNCOMPRESSED_R5G6B5 = 3        # 16 bpp
  RL_PIXELFORMAT_UNCOMPRESSED_R8G8B8 = 4        # 24 bpp
  RL_PIXELFORMAT_UNCOMPRESSED_R5G5B5A1 = 5      # 16 bpp (1 bit alpha)
  RL_PIXELFORMAT_UNCOMPRESSED_R4G4B4A4 = 6      # 16 bpp (4 bit alpha)
  RL_PIXELFORMAT_UNCOMPRESSED_R8G8B8A8 = 7      # 32 bpp
  RL_PIXELFORMAT_UNCOMPRESSED_R32 = 8           # 32 bpp (1 channel - float)
  RL_PIXELFORMAT_UNCOMPRESSED_R32G32B32 = 9     # 32*3 bpp (3 channels - float)
  RL_PIXELFORMAT_UNCOMPRESSED_R32G32B32A32 = 10 # 32*4 bpp (4 channels - float)
  RL_PIXELFORMAT_UNCOMPRESSED_R16 = 11          # 16 bpp (1 channel - half float)
  RL_PIXELFORMAT_UNCOMPRESSED_R16G16B16 = 12    # 16*3 bpp (3 channels - half float)
  RL_PIXELFORMAT_UNCOMPRESSED_R16G16B16A16 = 13 # 16*4 bpp (4 channels - half float)
  RL_PIXELFORMAT_COMPRESSED_DXT1_RGB = 14       # 4 bpp (no alpha)
  RL_PIXELFORMAT_COMPRESSED_DXT1_RGBA = 15      # 4 bpp (1 bit alpha)
  RL_PIXELFORMAT_COMPRESSED_DXT3_RGBA = 16      # 8 bpp
  RL_PIXELFORMAT_COMPRESSED_DXT5_RGBA = 17      # 8 bpp
  RL_PIXELFORMAT_COMPRESSED_ETC1_RGB = 18       # 4 bpp
  RL_PIXELFORMAT_COMPRESSED_ETC2_RGB = 19       # 4 bpp
  RL_PIXELFORMAT_COMPRESSED_ETC2_EAC_RGBA = 20  # 8 bpp
  RL_PIXELFORMAT_COMPRESSED_PVRT_RGB = 21       # 4 bpp
  RL_PIXELFORMAT_COMPRESSED_PVRT_RGBA = 22      # 4 bpp
  RL_PIXELFORMAT_COMPRESSED_ASTC_4x4_RGBA = 23  # 8 bpp
  RL_PIXELFORMAT_COMPRESSED_ASTC_8x8_RGBA = 24  # 2 bpp

  # enum rlTextureFilter
  # Texture parameters: filter mode
  RL_TEXTURE_FILTER_POINT = 0           # No filter, just pixel approximation
  RL_TEXTURE_FILTER_BILINEAR = 1        # Linear filtering
  RL_TEXTURE_FILTER_TRILINEAR = 2       # Trilinear filtering (linear with mipmaps)
  RL_TEXTURE_FILTER_ANISOTROPIC_4X = 3  # Anisotropic filtering 4x
  RL_TEXTURE_FILTER_ANISOTROPIC_8X = 4  # Anisotropic filtering 8x
  RL_TEXTURE_FILTER_ANISOTROPIC_16X = 5 # Anisotropic filtering 16x

  # enum rlBlendMode
  # Color blending modes (pre-defined)
  RL_BLEND_ALPHA = 0             # Blend textures considering alpha (default)
  RL_BLEND_ADDITIVE = 1          # Blend textures adding colors
  RL_BLEND_MULTIPLIED = 2        # Blend textures multiplying colors
  RL_BLEND_ADD_COLORS = 3        # Blend textures adding colors (alternative)
  RL_BLEND_SUBTRACT_COLORS = 4   # Blend textures subtracting colors (alternative)
  RL_BLEND_ALPHA_PREMULTIPLY = 5 # Blend premultiplied textures considering alpha
  RL_BLEND_CUSTOM = 6            # Blend textures using custom src/dst factors (use rlSetBlendFactors())
  RL_BLEND_CUSTOM_SEPARATE = 7   # Blend textures using custom src/dst factors (use rlSetBlendFactorsSeparate())

  # enum rlShaderLocationIndex
  # Shader location point type
  RL_SHADER_LOC_VERTEX_POSITION = 0   # Shader location: vertex attribute: position
  RL_SHADER_LOC_VERTEX_TEXCOORD01 = 1 # Shader location: vertex attribute: texcoord01
  RL_SHADER_LOC_VERTEX_TEXCOORD02 = 2 # Shader location: vertex attribute: texcoord02
  RL_SHADER_LOC_VERTEX_NORMAL = 3     # Shader location: vertex attribute: normal
  RL_SHADER_LOC_VERTEX_TANGENT = 4    # Shader location: vertex attribute: tangent
  RL_SHADER_LOC_VERTEX_COLOR = 5      # Shader location: vertex attribute: color
  RL_SHADER_LOC_MATRIX_MVP = 6        # Shader location: matrix uniform: model-view-projection
  RL_SHADER_LOC_MATRIX_VIEW = 7       # Shader location: matrix uniform: view (camera transform)
  RL_SHADER_LOC_MATRIX_PROJECTION = 8 # Shader location: matrix uniform: projection
  RL_SHADER_LOC_MATRIX_MODEL = 9      # Shader location: matrix uniform: model (transform)
  RL_SHADER_LOC_MATRIX_NORMAL = 10    # Shader location: matrix uniform: normal
  RL_SHADER_LOC_VECTOR_VIEW = 11      # Shader location: vector uniform: view
  RL_SHADER_LOC_COLOR_DIFFUSE = 12    # Shader location: vector uniform: diffuse color
  RL_SHADER_LOC_COLOR_SPECULAR = 13   # Shader location: vector uniform: specular color
  RL_SHADER_LOC_COLOR_AMBIENT = 14    # Shader location: vector uniform: ambient color
  RL_SHADER_LOC_MAP_ALBEDO = 15       # Shader location: sampler2d texture: albedo (same as: RL_SHADER_LOC_MAP_DIFFUSE)
  RL_SHADER_LOC_MAP_METALNESS = 16    # Shader location: sampler2d texture: metalness (same as: RL_SHADER_LOC_MAP_SPECULAR)
  RL_SHADER_LOC_MAP_NORMAL = 17       # Shader location: sampler2d texture: normal
  RL_SHADER_LOC_MAP_ROUGHNESS = 18    # Shader location: sampler2d texture: roughness
  RL_SHADER_LOC_MAP_OCCLUSION = 19    # Shader location: sampler2d texture: occlusion
  RL_SHADER_LOC_MAP_EMISSION = 20     # Shader location: sampler2d texture: emission
  RL_SHADER_LOC_MAP_HEIGHT = 21       # Shader location: sampler2d texture: height
  RL_SHADER_LOC_MAP_CUBEMAP = 22      # Shader location: samplerCube texture: cubemap
  RL_SHADER_LOC_MAP_IRRADIANCE = 23   # Shader location: samplerCube texture: irradiance
  RL_SHADER_LOC_MAP_PREFILTER = 24    # Shader location: samplerCube texture: prefilter
  RL_SHADER_LOC_MAP_BRDF = 25         # Shader location: sampler2d texture: brdf

  # enum rlShaderUniformDataType
  # Shader uniform data type
  RL_SHADER_UNIFORM_FLOAT = 0      # Shader uniform type: float
  RL_SHADER_UNIFORM_VEC2 = 1       # Shader uniform type: vec2 (2 float)
  RL_SHADER_UNIFORM_VEC3 = 2       # Shader uniform type: vec3 (3 float)
  RL_SHADER_UNIFORM_VEC4 = 3       # Shader uniform type: vec4 (4 float)
  RL_SHADER_UNIFORM_INT = 4        # Shader uniform type: int
  RL_SHADER_UNIFORM_IVEC2 = 5      # Shader uniform type: ivec2 (2 int)
  RL_SHADER_UNIFORM_IVEC3 = 6      # Shader uniform type: ivec3 (3 int)
  RL_SHADER_UNIFORM_IVEC4 = 7      # Shader uniform type: ivec4 (4 int)
  RL_SHADER_UNIFORM_UINT = 8       # Shader uniform type: unsigned int
  RL_SHADER_UNIFORM_UIVEC2 = 9     # Shader uniform type: uivec2 (2 unsigned int)
  RL_SHADER_UNIFORM_UIVEC3 = 10    # Shader uniform type: uivec3 (3 unsigned int)
  RL_SHADER_UNIFORM_UIVEC4 = 11    # Shader uniform type: uivec4 (4 unsigned int)
  RL_SHADER_UNIFORM_SAMPLER2D = 12 # Shader uniform type: sampler2d

  # enum rlShaderAttributeDataType
  # Shader attribute data types
  RL_SHADER_ATTRIB_FLOAT = 0 # Shader attribute type: float
  RL_SHADER_ATTRIB_VEC2 = 1  # Shader attribute type: vec2 (2 float)
  RL_SHADER_ATTRIB_VEC3 = 2  # Shader attribute type: vec3 (3 float)
  RL_SHADER_ATTRIB_VEC4 = 3  # Shader attribute type: vec4 (4 float)

  # enum rlFramebufferAttachType
  # Framebuffer attachment type
  RL_ATTACHMENT_COLOR_CHANNEL0 = 0 # Framebuffer attachment type: color 0
  RL_ATTACHMENT_COLOR_CHANNEL1 = 1 # Framebuffer attachment type: color 1
  RL_ATTACHMENT_COLOR_CHANNEL2 = 2 # Framebuffer attachment type: color 2
  RL_ATTACHMENT_COLOR_CHANNEL3 = 3 # Framebuffer attachment type: color 3
  RL_ATTACHMENT_COLOR_CHANNEL4 = 4 # Framebuffer attachment type: color 4
  RL_ATTACHMENT_COLOR_CHANNEL5 = 5 # Framebuffer attachment type: color 5
  RL_ATTACHMENT_COLOR_CHANNEL6 = 6 # Framebuffer attachment type: color 6
  RL_ATTACHMENT_COLOR_CHANNEL7 = 7 # Framebuffer attachment type: color 7
  RL_ATTACHMENT_DEPTH = 100        # Framebuffer attachment type: depth
  RL_ATTACHMENT_STENCIL = 200      # Framebuffer attachment type: stencil

  # enum rlFramebufferAttachTextureType
  # Framebuffer texture attachment type
  RL_ATTACHMENT_CUBEMAP_POSITIVE_X = 0 # Framebuffer texture attachment type: cubemap, +X side
  RL_ATTACHMENT_CUBEMAP_NEGATIVE_X = 1 # Framebuffer texture attachment type: cubemap, -X side
  RL_ATTACHMENT_CUBEMAP_POSITIVE_Y = 2 # Framebuffer texture attachment type: cubemap, +Y side
  RL_ATTACHMENT_CUBEMAP_NEGATIVE_Y = 3 # Framebuffer texture attachment type: cubemap, -Y side
  RL_ATTACHMENT_CUBEMAP_POSITIVE_Z = 4 # Framebuffer texture attachment type: cubemap, +Z side
  RL_ATTACHMENT_CUBEMAP_NEGATIVE_Z = 5 # Framebuffer texture attachment type: cubemap, -Z side
  RL_ATTACHMENT_TEXTURE2D = 100        # Framebuffer texture attachment type: texture2d
  RL_ATTACHMENT_RENDERBUFFER = 200     # Framebuffer texture attachment type: renderbuffer

  # enum rlCullMode
  # Face culling mode
  RL_CULL_FACE_FRONT = 0
  RL_CULL_FACE_BACK = 1


  # Typedef

  typedef :int, :rlGlVersion
  typedef :int, :rlTraceLogLevel
  typedef :int, :rlPixelFormat
  typedef :int, :rlTextureFilter
  typedef :int, :rlBlendMode
  typedef :int, :rlShaderLocationIndex
  typedef :int, :rlShaderUniformDataType
  typedef :int, :rlShaderAttributeDataType
  typedef :int, :rlFramebufferAttachType
  typedef :int, :rlFramebufferAttachTextureType
  typedef :int, :rlCullMode

  # Struct

  # Dynamic vertex buffers (position + texcoords + colors + indices arrays)
  class RlVertexBuffer < FFI::Struct
    layout(
      :elementCount, :int,  # Number of elements in the buffer (QUADS)
      :vertices, :pointer,  # Vertex position (XYZ - 3 components per vertex) (shader-location = 0)
      :texcoords, :pointer, # Vertex texture coordinates (UV - 2 components per vertex) (shader-location = 1)
      :normals, :pointer,   # Vertex normal (XYZ - 3 components per vertex) (shader-location = 2)
      :colors, :pointer,    # Vertex colors (RGBA - 4 components per vertex) (shader-location = 3)
      :indices, :pointer,   # Vertex indices (in case vertex data comes indexed) (6 indices per quad)
      :vaoId, :uint,        # OpenGL Vertex Array Object id
      :vboId, [:uint, 5],   # OpenGL Vertex Buffer Objects id (5 types of vertex data)
    )
    def elementCount = self[:elementCount]
    def elementCount=(v) self[:elementCount] = v end
    def vertices = self[:vertices]
    def vertices=(v) self[:vertices] = v end
    def texcoords = self[:texcoords]
    def texcoords=(v) self[:texcoords] = v end
    def normals = self[:normals]
    def normals=(v) self[:normals] = v end
    def colors = self[:colors]
    def colors=(v) self[:colors] = v end
    def indices = self[:indices]
    def indices=(v) self[:indices] = v end
    def vaoId = self[:vaoId]
    def vaoId=(v) self[:vaoId] = v end
    def vboId = self[:vboId]
    def vboId=(v) self[:vboId] = v end
  end

  # of those state-change happens (this is done in core module)
  class RlDrawCall < FFI::Struct
    layout(
      :mode, :int,            # Drawing mode: LINES, TRIANGLES, QUADS
      :vertexCount, :int,     # Number of vertex of the draw
      :vertexAlignment, :int, # Number of vertex required for index alignment (LINES, TRIANGLES)
      :textureId, :uint,      # Texture id to be used on the draw -> Use to create new draw call if changes
    )
    def mode = self[:mode]
    def mode=(v) self[:mode] = v end
    def vertexCount = self[:vertexCount]
    def vertexCount=(v) self[:vertexCount] = v end
    def vertexAlignment = self[:vertexAlignment]
    def vertexAlignment=(v) self[:vertexAlignment] = v end
    def textureId = self[:textureId]
    def textureId=(v) self[:textureId] = v end
  end

  # rlRenderBatch type
  class RlRenderBatch < FFI::Struct
    layout(
      :bufferCount, :int,      # Number of vertex buffers (multi-buffering support)
      :currentBuffer, :int,    # Current buffer tracking in case of multi-buffering
      :vertexBuffer, :pointer, # Dynamic buffer(s) for vertex data
      :draws, :pointer,        # Draw calls array, depends on textureId
      :drawCounter, :int,      # Draw calls counter
      :currentDepth, :float,   # Current depth value for next draw
    )
    def bufferCount = self[:bufferCount]
    def bufferCount=(v) self[:bufferCount] = v end
    def currentBuffer = self[:currentBuffer]
    def currentBuffer=(v) self[:currentBuffer] = v end
    def vertexBuffer = self[:vertexBuffer]
    def vertexBuffer=(v) self[:vertexBuffer] = v end
    def draws = self[:draws]
    def draws=(v) self[:draws] = v end
    def drawCounter = self[:drawCounter]
    def drawCounter=(v) self[:drawCounter] = v end
    def currentDepth = self[:currentDepth]
    def currentDepth=(v) self[:currentDepth] = v end
  end


  # Function

  def self.setup_rlgl_symbols(method_naming: :original)
    entries = [

      # @!method rlMatrixMode(mode)
      #   rlMatrixMode : Choose the current matrix to be transformed
      #   @param mode [int]
      #   @return [void]
      [:rlMatrixMode, :rlMatrixMode, [:int], :void],

      # @!method rlPushMatrix()
      #   rlPushMatrix : Push the current matrix to stack
      #   @return [void]
      [:rlPushMatrix, :rlPushMatrix, [], :void],

      # @!method rlPopMatrix()
      #   rlPopMatrix : Pop latest inserted matrix from stack
      #   @return [void]
      [:rlPopMatrix, :rlPopMatrix, [], :void],

      # @!method rlLoadIdentity()
      #   rlLoadIdentity : Reset current matrix to identity matrix
      #   @return [void]
      [:rlLoadIdentity, :rlLoadIdentity, [], :void],

      # @!method rlTranslatef(x, y, z)
      #   rlTranslatef : Multiply the current matrix by a translation matrix
      #   @param x [float]
      #   @param y [float]
      #   @param z [float]
      #   @return [void]
      [:rlTranslatef, :rlTranslatef, [:float, :float, :float], :void],

      # @!method rlRotatef(angle, x, y, z)
      #   rlRotatef : Multiply the current matrix by a rotation matrix
      #   @param angle [float]
      #   @param x [float]
      #   @param y [float]
      #   @param z [float]
      #   @return [void]
      [:rlRotatef, :rlRotatef, [:float, :float, :float, :float], :void],

      # @!method rlScalef(x, y, z)
      #   rlScalef : Multiply the current matrix by a scaling matrix
      #   @param x [float]
      #   @param y [float]
      #   @param z [float]
      #   @return [void]
      [:rlScalef, :rlScalef, [:float, :float, :float], :void],

      # @!method rlMultMatrixf(matf)
      #   rlMultMatrixf : Multiply the current matrix by another matrix
      #   @param matf [const float *]
      #   @return [void]
      [:rlMultMatrixf, :rlMultMatrixf, [:pointer], :void],

      # @!method rlFrustum(left, right, bottom, top, znear, zfar)
      #   rlFrustum
      #   @param left [double]
      #   @param right [double]
      #   @param bottom [double]
      #   @param top [double]
      #   @param znear [double]
      #   @param zfar [double]
      #   @return [void]
      [:rlFrustum, :rlFrustum, [:double, :double, :double, :double, :double, :double], :void],

      # @!method rlOrtho(left, right, bottom, top, znear, zfar)
      #   rlOrtho
      #   @param left [double]
      #   @param right [double]
      #   @param bottom [double]
      #   @param top [double]
      #   @param znear [double]
      #   @param zfar [double]
      #   @return [void]
      [:rlOrtho, :rlOrtho, [:double, :double, :double, :double, :double, :double], :void],

      # @!method rlViewport(x, y, width, height)
      #   rlViewport : Set the viewport area
      #   @param x [int]
      #   @param y [int]
      #   @param width [int]
      #   @param height [int]
      #   @return [void]
      [:rlViewport, :rlViewport, [:int, :int, :int, :int], :void],

      # @!method rlSetClipPlanes(nearPlane, farPlane)
      #   rlSetClipPlanes : Set clip planes distances
      #   @param nearPlane [double]
      #   @param farPlane [double]
      #   @return [void]
      [:rlSetClipPlanes, :rlSetClipPlanes, [:double, :double], :void],

      # @!method rlGetCullDistanceNear()
      #   rlGetCullDistanceNear : Get cull plane distance near
      #   @return [double]
      [:rlGetCullDistanceNear, :rlGetCullDistanceNear, [], :double],

      # @!method rlGetCullDistanceFar()
      #   rlGetCullDistanceFar : Get cull plane distance far
      #   @return [double]
      [:rlGetCullDistanceFar, :rlGetCullDistanceFar, [], :double],

      # @!method rlBegin(mode)
      #   rlBegin : Initialize drawing mode (how to organize vertex)
      #   @param mode [int]
      #   @return [void]
      [:rlBegin, :rlBegin, [:int], :void],

      # @!method rlEnd()
      #   rlEnd : Finish vertex providing
      #   @return [void]
      [:rlEnd, :rlEnd, [], :void],

      # @!method rlVertex2i(x, y)
      #   rlVertex2i : Define one vertex (position) - 2 int
      #   @param x [int]
      #   @param y [int]
      #   @return [void]
      [:rlVertex2i, :rlVertex2i, [:int, :int], :void],

      # @!method rlVertex2f(x, y)
      #   rlVertex2f : Define one vertex (position) - 2 float
      #   @param x [float]
      #   @param y [float]
      #   @return [void]
      [:rlVertex2f, :rlVertex2f, [:float, :float], :void],

      # @!method rlVertex3f(x, y, z)
      #   rlVertex3f : Define one vertex (position) - 3 float
      #   @param x [float]
      #   @param y [float]
      #   @param z [float]
      #   @return [void]
      [:rlVertex3f, :rlVertex3f, [:float, :float, :float], :void],

      # @!method rlTexCoord2f(x, y)
      #   rlTexCoord2f : Define one vertex (texture coordinate) - 2 float
      #   @param x [float]
      #   @param y [float]
      #   @return [void]
      [:rlTexCoord2f, :rlTexCoord2f, [:float, :float], :void],

      # @!method rlNormal3f(x, y, z)
      #   rlNormal3f : Define one vertex (normal) - 3 float
      #   @param x [float]
      #   @param y [float]
      #   @param z [float]
      #   @return [void]
      [:rlNormal3f, :rlNormal3f, [:float, :float, :float], :void],

      # @!method rlColor4ub(r, g, b, a)
      #   rlColor4ub : Define one vertex (color) - 4 byte
      #   @param r [unsigned char]
      #   @param g [unsigned char]
      #   @param b [unsigned char]
      #   @param a [unsigned char]
      #   @return [void]
      [:rlColor4ub, :rlColor4ub, [:uchar, :uchar, :uchar, :uchar], :void],

      # @!method rlColor3f(x, y, z)
      #   rlColor3f : Define one vertex (color) - 3 float
      #   @param x [float]
      #   @param y [float]
      #   @param z [float]
      #   @return [void]
      [:rlColor3f, :rlColor3f, [:float, :float, :float], :void],

      # @!method rlColor4f(x, y, z, w)
      #   rlColor4f : Define one vertex (color) - 4 float
      #   @param x [float]
      #   @param y [float]
      #   @param z [float]
      #   @param w [float]
      #   @return [void]
      [:rlColor4f, :rlColor4f, [:float, :float, :float, :float], :void],

      # @!method rlEnableVertexArray(vaoId)
      #   rlEnableVertexArray : Enable vertex array (VAO, if supported)
      #   @param vaoId [unsigned int]
      #   @return [bool]
      [:rlEnableVertexArray, :rlEnableVertexArray, [:uint], :bool],

      # @!method rlDisableVertexArray()
      #   rlDisableVertexArray : Disable vertex array (VAO, if supported)
      #   @return [void]
      [:rlDisableVertexArray, :rlDisableVertexArray, [], :void],

      # @!method rlEnableVertexBuffer(id)
      #   rlEnableVertexBuffer : Enable vertex buffer (VBO)
      #   @param id [unsigned int]
      #   @return [void]
      [:rlEnableVertexBuffer, :rlEnableVertexBuffer, [:uint], :void],

      # @!method rlDisableVertexBuffer()
      #   rlDisableVertexBuffer : Disable vertex buffer (VBO)
      #   @return [void]
      [:rlDisableVertexBuffer, :rlDisableVertexBuffer, [], :void],

      # @!method rlEnableVertexBufferElement(id)
      #   rlEnableVertexBufferElement : Enable vertex buffer element (VBO element)
      #   @param id [unsigned int]
      #   @return [void]
      [:rlEnableVertexBufferElement, :rlEnableVertexBufferElement, [:uint], :void],

      # @!method rlDisableVertexBufferElement()
      #   rlDisableVertexBufferElement : Disable vertex buffer element (VBO element)
      #   @return [void]
      [:rlDisableVertexBufferElement, :rlDisableVertexBufferElement, [], :void],

      # @!method rlEnableVertexAttribute(index)
      #   rlEnableVertexAttribute : Enable vertex attribute index
      #   @param index [unsigned int]
      #   @return [void]
      [:rlEnableVertexAttribute, :rlEnableVertexAttribute, [:uint], :void],

      # @!method rlDisableVertexAttribute(index)
      #   rlDisableVertexAttribute : Disable vertex attribute index
      #   @param index [unsigned int]
      #   @return [void]
      [:rlDisableVertexAttribute, :rlDisableVertexAttribute, [:uint], :void],

      # @!method rlActiveTextureSlot(slot)
      #   rlActiveTextureSlot : Select and active a texture slot
      #   @param slot [int]
      #   @return [void]
      [:rlActiveTextureSlot, :rlActiveTextureSlot, [:int], :void],

      # @!method rlEnableTexture(id)
      #   rlEnableTexture : Enable texture
      #   @param id [unsigned int]
      #   @return [void]
      [:rlEnableTexture, :rlEnableTexture, [:uint], :void],

      # @!method rlDisableTexture()
      #   rlDisableTexture : Disable texture
      #   @return [void]
      [:rlDisableTexture, :rlDisableTexture, [], :void],

      # @!method rlEnableTextureCubemap(id)
      #   rlEnableTextureCubemap : Enable texture cubemap
      #   @param id [unsigned int]
      #   @return [void]
      [:rlEnableTextureCubemap, :rlEnableTextureCubemap, [:uint], :void],

      # @!method rlDisableTextureCubemap()
      #   rlDisableTextureCubemap : Disable texture cubemap
      #   @return [void]
      [:rlDisableTextureCubemap, :rlDisableTextureCubemap, [], :void],

      # @!method rlTextureParameters(id, param, value)
      #   rlTextureParameters : Set texture parameters (filter, wrap)
      #   @param id [unsigned int]
      #   @param param [int]
      #   @param value [int]
      #   @return [void]
      [:rlTextureParameters, :rlTextureParameters, [:uint, :int, :int], :void],

      # @!method rlCubemapParameters(id, param, value)
      #   rlCubemapParameters : Set cubemap parameters (filter, wrap)
      #   @param id [unsigned int]
      #   @param param [int]
      #   @param value [int]
      #   @return [void]
      [:rlCubemapParameters, :rlCubemapParameters, [:uint, :int, :int], :void],

      # @!method rlEnableShader(id)
      #   rlEnableShader : Enable shader program
      #   @param id [unsigned int]
      #   @return [void]
      [:rlEnableShader, :rlEnableShader, [:uint], :void],

      # @!method rlDisableShader()
      #   rlDisableShader : Disable shader program
      #   @return [void]
      [:rlDisableShader, :rlDisableShader, [], :void],

      # @!method rlEnableFramebuffer(id)
      #   rlEnableFramebuffer : Enable render texture (fbo)
      #   @param id [unsigned int]
      #   @return [void]
      [:rlEnableFramebuffer, :rlEnableFramebuffer, [:uint], :void],

      # @!method rlDisableFramebuffer()
      #   rlDisableFramebuffer : Disable render texture (fbo), return to default framebuffer
      #   @return [void]
      [:rlDisableFramebuffer, :rlDisableFramebuffer, [], :void],

      # @!method rlGetActiveFramebuffer()
      #   rlGetActiveFramebuffer : Get the currently active render texture (fbo), 0 for default framebuffer
      #   @return [unsigned int]
      [:rlGetActiveFramebuffer, :rlGetActiveFramebuffer, [], :uint],

      # @!method rlActiveDrawBuffers(count)
      #   rlActiveDrawBuffers : Activate multiple draw color buffers
      #   @param count [int]
      #   @return [void]
      [:rlActiveDrawBuffers, :rlActiveDrawBuffers, [:int], :void],

      # @!method rlBlitFramebuffer(srcX, srcY, srcWidth, srcHeight, dstX, dstY, dstWidth, dstHeight, bufferMask)
      #   rlBlitFramebuffer : Blit active framebuffer to main framebuffer
      #   @param srcX [int]
      #   @param srcY [int]
      #   @param srcWidth [int]
      #   @param srcHeight [int]
      #   @param dstX [int]
      #   @param dstY [int]
      #   @param dstWidth [int]
      #   @param dstHeight [int]
      #   @param bufferMask [int]
      #   @return [void]
      [:rlBlitFramebuffer, :rlBlitFramebuffer, [:int, :int, :int, :int, :int, :int, :int, :int, :int], :void],

      # @!method rlBindFramebuffer(target, framebuffer)
      #   rlBindFramebuffer : Bind framebuffer (FBO)
      #   @param target [unsigned int]
      #   @param framebuffer [unsigned int]
      #   @return [void]
      [:rlBindFramebuffer, :rlBindFramebuffer, [:uint, :uint], :void],

      # @!method rlEnableColorBlend()
      #   rlEnableColorBlend : Enable color blending
      #   @return [void]
      [:rlEnableColorBlend, :rlEnableColorBlend, [], :void],

      # @!method rlDisableColorBlend()
      #   rlDisableColorBlend : Disable color blending
      #   @return [void]
      [:rlDisableColorBlend, :rlDisableColorBlend, [], :void],

      # @!method rlEnableDepthTest()
      #   rlEnableDepthTest : Enable depth test
      #   @return [void]
      [:rlEnableDepthTest, :rlEnableDepthTest, [], :void],

      # @!method rlDisableDepthTest()
      #   rlDisableDepthTest : Disable depth test
      #   @return [void]
      [:rlDisableDepthTest, :rlDisableDepthTest, [], :void],

      # @!method rlEnableDepthMask()
      #   rlEnableDepthMask : Enable depth write
      #   @return [void]
      [:rlEnableDepthMask, :rlEnableDepthMask, [], :void],

      # @!method rlDisableDepthMask()
      #   rlDisableDepthMask : Disable depth write
      #   @return [void]
      [:rlDisableDepthMask, :rlDisableDepthMask, [], :void],

      # @!method rlEnableBackfaceCulling()
      #   rlEnableBackfaceCulling : Enable backface culling
      #   @return [void]
      [:rlEnableBackfaceCulling, :rlEnableBackfaceCulling, [], :void],

      # @!method rlDisableBackfaceCulling()
      #   rlDisableBackfaceCulling : Disable backface culling
      #   @return [void]
      [:rlDisableBackfaceCulling, :rlDisableBackfaceCulling, [], :void],

      # @!method rlColorMask(r, g, b, a)
      #   rlColorMask : Color mask control
      #   @param r [bool]
      #   @param g [bool]
      #   @param b [bool]
      #   @param a [bool]
      #   @return [void]
      [:rlColorMask, :rlColorMask, [:bool, :bool, :bool, :bool], :void],

      # @!method rlSetCullFace(mode)
      #   rlSetCullFace : Set face culling mode
      #   @param mode [int]
      #   @return [void]
      [:rlSetCullFace, :rlSetCullFace, [:int], :void],

      # @!method rlEnableScissorTest()
      #   rlEnableScissorTest : Enable scissor test
      #   @return [void]
      [:rlEnableScissorTest, :rlEnableScissorTest, [], :void],

      # @!method rlDisableScissorTest()
      #   rlDisableScissorTest : Disable scissor test
      #   @return [void]
      [:rlDisableScissorTest, :rlDisableScissorTest, [], :void],

      # @!method rlScissor(x, y, width, height)
      #   rlScissor : Scissor test
      #   @param x [int]
      #   @param y [int]
      #   @param width [int]
      #   @param height [int]
      #   @return [void]
      [:rlScissor, :rlScissor, [:int, :int, :int, :int], :void],

      # @!method rlEnableWireMode()
      #   rlEnableWireMode : Enable wire mode
      #   @return [void]
      [:rlEnableWireMode, :rlEnableWireMode, [], :void],

      # @!method rlEnablePointMode()
      #   rlEnablePointMode : Enable point mode
      #   @return [void]
      [:rlEnablePointMode, :rlEnablePointMode, [], :void],

      # @!method rlDisableWireMode()
      #   rlDisableWireMode : Disable wire (and point) mode
      #   @return [void]
      [:rlDisableWireMode, :rlDisableWireMode, [], :void],

      # @!method rlSetLineWidth(width)
      #   rlSetLineWidth : Set the line drawing width
      #   @param width [float]
      #   @return [void]
      [:rlSetLineWidth, :rlSetLineWidth, [:float], :void],

      # @!method rlGetLineWidth()
      #   rlGetLineWidth : Get the line drawing width
      #   @return [float]
      [:rlGetLineWidth, :rlGetLineWidth, [], :float],

      # @!method rlEnableSmoothLines()
      #   rlEnableSmoothLines : Enable line aliasing
      #   @return [void]
      [:rlEnableSmoothLines, :rlEnableSmoothLines, [], :void],

      # @!method rlDisableSmoothLines()
      #   rlDisableSmoothLines : Disable line aliasing
      #   @return [void]
      [:rlDisableSmoothLines, :rlDisableSmoothLines, [], :void],

      # @!method rlEnableStereoRender()
      #   rlEnableStereoRender : Enable stereo rendering
      #   @return [void]
      [:rlEnableStereoRender, :rlEnableStereoRender, [], :void],

      # @!method rlDisableStereoRender()
      #   rlDisableStereoRender : Disable stereo rendering
      #   @return [void]
      [:rlDisableStereoRender, :rlDisableStereoRender, [], :void],

      # @!method rlIsStereoRenderEnabled()
      #   rlIsStereoRenderEnabled : Check if stereo render is enabled
      #   @return [bool]
      [:rlIsStereoRenderEnabled, :rlIsStereoRenderEnabled, [], :bool],

      # @!method rlClearColor(r, g, b, a)
      #   rlClearColor : Clear color buffer with color
      #   @param r [unsigned char]
      #   @param g [unsigned char]
      #   @param b [unsigned char]
      #   @param a [unsigned char]
      #   @return [void]
      [:rlClearColor, :rlClearColor, [:uchar, :uchar, :uchar, :uchar], :void],

      # @!method rlClearScreenBuffers()
      #   rlClearScreenBuffers : Clear used screen buffers (color and depth)
      #   @return [void]
      [:rlClearScreenBuffers, :rlClearScreenBuffers, [], :void],

      # @!method rlCheckErrors()
      #   rlCheckErrors : Check and log OpenGL error codes
      #   @return [void]
      [:rlCheckErrors, :rlCheckErrors, [], :void],

      # @!method rlSetBlendMode(mode)
      #   rlSetBlendMode : Set blending mode
      #   @param mode [int]
      #   @return [void]
      [:rlSetBlendMode, :rlSetBlendMode, [:int], :void],

      # @!method rlSetBlendFactors(glSrcFactor, glDstFactor, glEquation)
      #   rlSetBlendFactors : Set blending mode factor and equation (using OpenGL factors)
      #   @param glSrcFactor [int]
      #   @param glDstFactor [int]
      #   @param glEquation [int]
      #   @return [void]
      [:rlSetBlendFactors, :rlSetBlendFactors, [:int, :int, :int], :void],

      # @!method rlSetBlendFactorsSeparate(glSrcRGB, glDstRGB, glSrcAlpha, glDstAlpha, glEqRGB, glEqAlpha)
      #   rlSetBlendFactorsSeparate : Set blending mode factors and equations separately (using OpenGL factors)
      #   @param glSrcRGB [int]
      #   @param glDstRGB [int]
      #   @param glSrcAlpha [int]
      #   @param glDstAlpha [int]
      #   @param glEqRGB [int]
      #   @param glEqAlpha [int]
      #   @return [void]
      [:rlSetBlendFactorsSeparate, :rlSetBlendFactorsSeparate, [:int, :int, :int, :int, :int, :int], :void],

      # @!method rlglInit(width, height)
      #   rlglInit : Initialize rlgl (buffers, shaders, textures, states)
      #   @param width [int]
      #   @param height [int]
      #   @return [void]
      [:rlglInit, :rlglInit, [:int, :int], :void],

      # @!method rlglClose()
      #   rlglClose : De-initialize rlgl (buffers, shaders, textures)
      #   @return [void]
      [:rlglClose, :rlglClose, [], :void],

      # @!method rlLoadExtensions(loader)
      #   rlLoadExtensions : Load OpenGL extensions (loader function required)
      #   @param loader [void *]
      #   @return [void]
      [:rlLoadExtensions, :rlLoadExtensions, [:pointer], :void],

      # @!method rlGetVersion()
      #   rlGetVersion : Get current OpenGL version
      #   @return [int]
      [:rlGetVersion, :rlGetVersion, [], :int],

      # @!method rlSetFramebufferWidth(width)
      #   rlSetFramebufferWidth : Set current framebuffer width
      #   @param width [int]
      #   @return [void]
      [:rlSetFramebufferWidth, :rlSetFramebufferWidth, [:int], :void],

      # @!method rlGetFramebufferWidth()
      #   rlGetFramebufferWidth : Get default framebuffer width
      #   @return [int]
      [:rlGetFramebufferWidth, :rlGetFramebufferWidth, [], :int],

      # @!method rlSetFramebufferHeight(height)
      #   rlSetFramebufferHeight : Set current framebuffer height
      #   @param height [int]
      #   @return [void]
      [:rlSetFramebufferHeight, :rlSetFramebufferHeight, [:int], :void],

      # @!method rlGetFramebufferHeight()
      #   rlGetFramebufferHeight : Get default framebuffer height
      #   @return [int]
      [:rlGetFramebufferHeight, :rlGetFramebufferHeight, [], :int],

      # @!method rlGetTextureIdDefault()
      #   rlGetTextureIdDefault : Get default texture id
      #   @return [unsigned int]
      [:rlGetTextureIdDefault, :rlGetTextureIdDefault, [], :uint],

      # @!method rlGetShaderIdDefault()
      #   rlGetShaderIdDefault : Get default shader id
      #   @return [unsigned int]
      [:rlGetShaderIdDefault, :rlGetShaderIdDefault, [], :uint],

      # @!method rlGetShaderLocsDefault()
      #   rlGetShaderLocsDefault : Get default shader locations
      #   @return [int *]
      [:rlGetShaderLocsDefault, :rlGetShaderLocsDefault, [], :pointer],

      # @!method rlLoadRenderBatch(numBuffers, bufferElements)
      #   rlLoadRenderBatch : Load a render batch system
      #   @param numBuffers [int]
      #   @param bufferElements [int]
      #   @return [rlRenderBatch]
      [:rlLoadRenderBatch, :rlLoadRenderBatch, [:int, :int], RlRenderBatch.by_value],

      # @!method rlUnloadRenderBatch(batch)
      #   rlUnloadRenderBatch : Unload render batch system
      #   @param batch [rlRenderBatch]
      #   @return [void]
      [:rlUnloadRenderBatch, :rlUnloadRenderBatch, [RlRenderBatch.by_value], :void],

      # @!method rlDrawRenderBatch(batch)
      #   rlDrawRenderBatch : Draw render batch data (Update->Draw->Reset)
      #   @param batch [rlRenderBatch *]
      #   @return [void]
      [:rlDrawRenderBatch, :rlDrawRenderBatch, [:pointer], :void],

      # @!method rlSetRenderBatchActive(batch)
      #   rlSetRenderBatchActive : Set the active render batch for rlgl (NULL for default internal)
      #   @param batch [rlRenderBatch *]
      #   @return [void]
      [:rlSetRenderBatchActive, :rlSetRenderBatchActive, [:pointer], :void],

      # @!method rlDrawRenderBatchActive()
      #   rlDrawRenderBatchActive : Update and draw internal render batch
      #   @return [void]
      [:rlDrawRenderBatchActive, :rlDrawRenderBatchActive, [], :void],

      # @!method rlCheckRenderBatchLimit(vCount)
      #   rlCheckRenderBatchLimit : Check internal buffer overflow for a given number of vertex
      #   @param vCount [int]
      #   @return [bool]
      [:rlCheckRenderBatchLimit, :rlCheckRenderBatchLimit, [:int], :bool],

      # @!method rlSetTexture(id)
      #   rlSetTexture : Set current texture for render batch and check buffers limits
      #   @param id [unsigned int]
      #   @return [void]
      [:rlSetTexture, :rlSetTexture, [:uint], :void],

      # @!method rlLoadVertexArray()
      #   rlLoadVertexArray : Load vertex array (vao) if supported
      #   @return [unsigned int]
      [:rlLoadVertexArray, :rlLoadVertexArray, [], :uint],

      # @!method rlLoadVertexBuffer(buffer, size, dynamic)
      #   rlLoadVertexBuffer : Load a vertex buffer object
      #   @param buffer [const void *]
      #   @param size [int]
      #   @param dynamic [bool]
      #   @return [unsigned int]
      [:rlLoadVertexBuffer, :rlLoadVertexBuffer, [:pointer, :int, :bool], :uint],

      # @!method rlLoadVertexBufferElement(buffer, size, dynamic)
      #   rlLoadVertexBufferElement : Load vertex buffer elements object
      #   @param buffer [const void *]
      #   @param size [int]
      #   @param dynamic [bool]
      #   @return [unsigned int]
      [:rlLoadVertexBufferElement, :rlLoadVertexBufferElement, [:pointer, :int, :bool], :uint],

      # @!method rlUpdateVertexBuffer(bufferId, data, dataSize, offset)
      #   rlUpdateVertexBuffer : Update vertex buffer object data on GPU buffer
      #   @param bufferId [unsigned int]
      #   @param data [const void *]
      #   @param dataSize [int]
      #   @param offset [int]
      #   @return [void]
      [:rlUpdateVertexBuffer, :rlUpdateVertexBuffer, [:uint, :pointer, :int, :int], :void],

      # @!method rlUpdateVertexBufferElements(id, data, dataSize, offset)
      #   rlUpdateVertexBufferElements : Update vertex buffer elements data on GPU buffer
      #   @param id [unsigned int]
      #   @param data [const void *]
      #   @param dataSize [int]
      #   @param offset [int]
      #   @return [void]
      [:rlUpdateVertexBufferElements, :rlUpdateVertexBufferElements, [:uint, :pointer, :int, :int], :void],

      # @!method rlUnloadVertexArray(vaoId)
      #   rlUnloadVertexArray : Unload vertex array (vao)
      #   @param vaoId [unsigned int]
      #   @return [void]
      [:rlUnloadVertexArray, :rlUnloadVertexArray, [:uint], :void],

      # @!method rlUnloadVertexBuffer(vboId)
      #   rlUnloadVertexBuffer : Unload vertex buffer object
      #   @param vboId [unsigned int]
      #   @return [void]
      [:rlUnloadVertexBuffer, :rlUnloadVertexBuffer, [:uint], :void],

      # @!method rlSetVertexAttribute(index, compSize, type, normalized, stride, offset)
      #   rlSetVertexAttribute : Set vertex attribute data configuration
      #   @param index [unsigned int]
      #   @param compSize [int]
      #   @param type [int]
      #   @param normalized [bool]
      #   @param stride [int]
      #   @param offset [int]
      #   @return [void]
      [:rlSetVertexAttribute, :rlSetVertexAttribute, [:uint, :int, :int, :bool, :int, :int], :void],

      # @!method rlSetVertexAttributeDivisor(index, divisor)
      #   rlSetVertexAttributeDivisor : Set vertex attribute data divisor
      #   @param index [unsigned int]
      #   @param divisor [int]
      #   @return [void]
      [:rlSetVertexAttributeDivisor, :rlSetVertexAttributeDivisor, [:uint, :int], :void],

      # @!method rlSetVertexAttributeDefault(locIndex, value, attribType, count)
      #   rlSetVertexAttributeDefault : Set vertex attribute default value, when attribute to provided
      #   @param locIndex [int]
      #   @param value [const void *]
      #   @param attribType [int]
      #   @param count [int]
      #   @return [void]
      [:rlSetVertexAttributeDefault, :rlSetVertexAttributeDefault, [:int, :pointer, :int, :int], :void],

      # @!method rlDrawVertexArray(offset, count)
      #   rlDrawVertexArray : Draw vertex array (currently active vao)
      #   @param offset [int]
      #   @param count [int]
      #   @return [void]
      [:rlDrawVertexArray, :rlDrawVertexArray, [:int, :int], :void],

      # @!method rlDrawVertexArrayElements(offset, count, buffer)
      #   rlDrawVertexArrayElements : Draw vertex array elements
      #   @param offset [int]
      #   @param count [int]
      #   @param buffer [const void *]
      #   @return [void]
      [:rlDrawVertexArrayElements, :rlDrawVertexArrayElements, [:int, :int, :pointer], :void],

      # @!method rlDrawVertexArrayInstanced(offset, count, instances)
      #   rlDrawVertexArrayInstanced : Draw vertex array (currently active vao) with instancing
      #   @param offset [int]
      #   @param count [int]
      #   @param instances [int]
      #   @return [void]
      [:rlDrawVertexArrayInstanced, :rlDrawVertexArrayInstanced, [:int, :int, :int], :void],

      # @!method rlDrawVertexArrayElementsInstanced(offset, count, buffer, instances)
      #   rlDrawVertexArrayElementsInstanced : Draw vertex array elements with instancing
      #   @param offset [int]
      #   @param count [int]
      #   @param buffer [const void *]
      #   @param instances [int]
      #   @return [void]
      [:rlDrawVertexArrayElementsInstanced, :rlDrawVertexArrayElementsInstanced, [:int, :int, :pointer, :int], :void],

      # @!method rlLoadTexture(data, width, height, format, mipmapCount)
      #   rlLoadTexture : Load texture data
      #   @param data [const void *]
      #   @param width [int]
      #   @param height [int]
      #   @param format [int]
      #   @param mipmapCount [int]
      #   @return [unsigned int]
      [:rlLoadTexture, :rlLoadTexture, [:pointer, :int, :int, :int, :int], :uint],

      # @!method rlLoadTextureDepth(width, height, useRenderBuffer)
      #   rlLoadTextureDepth : Load depth texture/renderbuffer (to be attached to fbo)
      #   @param width [int]
      #   @param height [int]
      #   @param useRenderBuffer [bool]
      #   @return [unsigned int]
      [:rlLoadTextureDepth, :rlLoadTextureDepth, [:int, :int, :bool], :uint],

      # @!method rlLoadTextureCubemap(data, size, format, mipmapCount)
      #   rlLoadTextureCubemap : Load texture cubemap data
      #   @param data [const void *]
      #   @param size [int]
      #   @param format [int]
      #   @param mipmapCount [int]
      #   @return [unsigned int]
      [:rlLoadTextureCubemap, :rlLoadTextureCubemap, [:pointer, :int, :int, :int], :uint],

      # @!method rlUpdateTexture(id, offsetX, offsetY, width, height, format, data)
      #   rlUpdateTexture : Update texture with new data on GPU
      #   @param id [unsigned int]
      #   @param offsetX [int]
      #   @param offsetY [int]
      #   @param width [int]
      #   @param height [int]
      #   @param format [int]
      #   @param data [const void *]
      #   @return [void]
      [:rlUpdateTexture, :rlUpdateTexture, [:uint, :int, :int, :int, :int, :int, :pointer], :void],

      # @!method rlGetGlTextureFormats(format, glInternalFormat, glFormat, glType)
      #   rlGetGlTextureFormats : Get OpenGL internal formats
      #   @param format [int]
      #   @param glInternalFormat [unsigned int *]
      #   @param glFormat [unsigned int *]
      #   @param glType [unsigned int *]
      #   @return [void]
      [:rlGetGlTextureFormats, :rlGetGlTextureFormats, [:int, :pointer, :pointer, :pointer], :void],

      # @!method rlGetPixelFormatName(format)
      #   rlGetPixelFormatName : Get name string for pixel format
      #   @param format [unsigned int]
      #   @return [const char *]
      [:rlGetPixelFormatName, :rlGetPixelFormatName, [:uint], :pointer],

      # @!method rlUnloadTexture(id)
      #   rlUnloadTexture : Unload texture from GPU memory
      #   @param id [unsigned int]
      #   @return [void]
      [:rlUnloadTexture, :rlUnloadTexture, [:uint], :void],

      # @!method rlGenTextureMipmaps(id, width, height, format, mipmaps)
      #   rlGenTextureMipmaps : Generate mipmap data for selected texture
      #   @param id [unsigned int]
      #   @param width [int]
      #   @param height [int]
      #   @param format [int]
      #   @param mipmaps [int *]
      #   @return [void]
      [:rlGenTextureMipmaps, :rlGenTextureMipmaps, [:uint, :int, :int, :int, :pointer], :void],

      # @!method rlReadTexturePixels(id, width, height, format)
      #   rlReadTexturePixels : Read texture pixel data
      #   @param id [unsigned int]
      #   @param width [int]
      #   @param height [int]
      #   @param format [int]
      #   @return [void *]
      [:rlReadTexturePixels, :rlReadTexturePixels, [:uint, :int, :int, :int], :pointer],

      # @!method rlReadScreenPixels(width, height)
      #   rlReadScreenPixels : Read screen pixel data (color buffer)
      #   @param width [int]
      #   @param height [int]
      #   @return [unsigned char *]
      [:rlReadScreenPixels, :rlReadScreenPixels, [:int, :int], :pointer],

      # @!method rlLoadFramebuffer()
      #   rlLoadFramebuffer : Load an empty framebuffer
      #   @return [unsigned int]
      [:rlLoadFramebuffer, :rlLoadFramebuffer, [], :uint],

      # @!method rlFramebufferAttach(fboId, texId, attachType, texType, mipLevel)
      #   rlFramebufferAttach : Attach texture/renderbuffer to a framebuffer
      #   @param fboId [unsigned int]
      #   @param texId [unsigned int]
      #   @param attachType [int]
      #   @param texType [int]
      #   @param mipLevel [int]
      #   @return [void]
      [:rlFramebufferAttach, :rlFramebufferAttach, [:uint, :uint, :int, :int, :int], :void],

      # @!method rlFramebufferComplete(id)
      #   rlFramebufferComplete : Verify framebuffer is complete
      #   @param id [unsigned int]
      #   @return [bool]
      [:rlFramebufferComplete, :rlFramebufferComplete, [:uint], :bool],

      # @!method rlUnloadFramebuffer(id)
      #   rlUnloadFramebuffer : Delete framebuffer from GPU
      #   @param id [unsigned int]
      #   @return [void]
      [:rlUnloadFramebuffer, :rlUnloadFramebuffer, [:uint], :void],

      # @!method rlLoadShaderCode(vsCode, fsCode)
      #   rlLoadShaderCode : Load shader from code strings
      #   @param vsCode [const char *]
      #   @param fsCode [const char *]
      #   @return [unsigned int]
      [:rlLoadShaderCode, :rlLoadShaderCode, [:pointer, :pointer], :uint],

      # @!method rlCompileShader(shaderCode, type)
      #   rlCompileShader : Compile custom shader and return shader id (type: RL_VERTEX_SHADER, RL_FRAGMENT_SHADER, RL_COMPUTE_SHADER)
      #   @param shaderCode [const char *]
      #   @param type [int]
      #   @return [unsigned int]
      [:rlCompileShader, :rlCompileShader, [:pointer, :int], :uint],

      # @!method rlLoadShaderProgram(vShaderId, fShaderId)
      #   rlLoadShaderProgram : Load custom shader program
      #   @param vShaderId [unsigned int]
      #   @param fShaderId [unsigned int]
      #   @return [unsigned int]
      [:rlLoadShaderProgram, :rlLoadShaderProgram, [:uint, :uint], :uint],

      # @!method rlUnloadShaderProgram(id)
      #   rlUnloadShaderProgram : Unload shader program
      #   @param id [unsigned int]
      #   @return [void]
      [:rlUnloadShaderProgram, :rlUnloadShaderProgram, [:uint], :void],

      # @!method rlGetLocationUniform(shaderId, uniformName)
      #   rlGetLocationUniform : Get shader location uniform
      #   @param shaderId [unsigned int]
      #   @param uniformName [const char *]
      #   @return [int]
      [:rlGetLocationUniform, :rlGetLocationUniform, [:uint, :pointer], :int],

      # @!method rlGetLocationAttrib(shaderId, attribName)
      #   rlGetLocationAttrib : Get shader location attribute
      #   @param shaderId [unsigned int]
      #   @param attribName [const char *]
      #   @return [int]
      [:rlGetLocationAttrib, :rlGetLocationAttrib, [:uint, :pointer], :int],

      # @!method rlSetUniform(locIndex, value, uniformType, count)
      #   rlSetUniform : Set shader value uniform
      #   @param locIndex [int]
      #   @param value [const void *]
      #   @param uniformType [int]
      #   @param count [int]
      #   @return [void]
      [:rlSetUniform, :rlSetUniform, [:int, :pointer, :int, :int], :void],

      # @!method rlSetUniformMatrix(locIndex, mat)
      #   rlSetUniformMatrix : Set shader value matrix
      #   @param locIndex [int]
      #   @param mat [Matrix]
      #   @return [void]
      [:rlSetUniformMatrix, :rlSetUniformMatrix, [:int, Matrix.by_value], :void],

      # @!method rlSetUniformMatrices(locIndex, mat, count)
      #   rlSetUniformMatrices : Set shader value matrices
      #   @param locIndex [int]
      #   @param mat [const Matrix *]
      #   @param count [int]
      #   @return [void]
      [:rlSetUniformMatrices, :rlSetUniformMatrices, [:int, :pointer, :int], :void],

      # @!method rlSetUniformSampler(locIndex, textureId)
      #   rlSetUniformSampler : Set shader value sampler
      #   @param locIndex [int]
      #   @param textureId [unsigned int]
      #   @return [void]
      [:rlSetUniformSampler, :rlSetUniformSampler, [:int, :uint], :void],

      # @!method rlSetShader(id, locs)
      #   rlSetShader : Set shader currently active (id and locations)
      #   @param id [unsigned int]
      #   @param locs [int *]
      #   @return [void]
      [:rlSetShader, :rlSetShader, [:uint, :pointer], :void],

      # @!method rlLoadComputeShaderProgram(shaderId)
      #   rlLoadComputeShaderProgram : Load compute shader program
      #   @param shaderId [unsigned int]
      #   @return [unsigned int]
      [:rlLoadComputeShaderProgram, :rlLoadComputeShaderProgram, [:uint], :uint],

      # @!method rlComputeShaderDispatch(groupX, groupY, groupZ)
      #   rlComputeShaderDispatch : Dispatch compute shader (equivalent to *draw* for graphics pipeline)
      #   @param groupX [unsigned int]
      #   @param groupY [unsigned int]
      #   @param groupZ [unsigned int]
      #   @return [void]
      [:rlComputeShaderDispatch, :rlComputeShaderDispatch, [:uint, :uint, :uint], :void],

      # @!method rlLoadShaderBuffer(size, data, usageHint)
      #   rlLoadShaderBuffer : Load shader storage buffer object (SSBO)
      #   @param size [unsigned int]
      #   @param data [const void *]
      #   @param usageHint [int]
      #   @return [unsigned int]
      [:rlLoadShaderBuffer, :rlLoadShaderBuffer, [:uint, :pointer, :int], :uint],

      # @!method rlUnloadShaderBuffer(ssboId)
      #   rlUnloadShaderBuffer : Unload shader storage buffer object (SSBO)
      #   @param ssboId [unsigned int]
      #   @return [void]
      [:rlUnloadShaderBuffer, :rlUnloadShaderBuffer, [:uint], :void],

      # @!method rlUpdateShaderBuffer(id, data, dataSize, offset)
      #   rlUpdateShaderBuffer : Update SSBO buffer data
      #   @param id [unsigned int]
      #   @param data [const void *]
      #   @param dataSize [unsigned int]
      #   @param offset [unsigned int]
      #   @return [void]
      [:rlUpdateShaderBuffer, :rlUpdateShaderBuffer, [:uint, :pointer, :uint, :uint], :void],

      # @!method rlBindShaderBuffer(id, index)
      #   rlBindShaderBuffer : Bind SSBO buffer
      #   @param id [unsigned int]
      #   @param index [unsigned int]
      #   @return [void]
      [:rlBindShaderBuffer, :rlBindShaderBuffer, [:uint, :uint], :void],

      # @!method rlReadShaderBuffer(id, dest, count, offset)
      #   rlReadShaderBuffer : Read SSBO buffer data (GPU->CPU)
      #   @param id [unsigned int]
      #   @param dest [void *]
      #   @param count [unsigned int]
      #   @param offset [unsigned int]
      #   @return [void]
      [:rlReadShaderBuffer, :rlReadShaderBuffer, [:uint, :pointer, :uint, :uint], :void],

      # @!method rlCopyShaderBuffer(destId, srcId, destOffset, srcOffset, count)
      #   rlCopyShaderBuffer : Copy SSBO data between buffers
      #   @param destId [unsigned int]
      #   @param srcId [unsigned int]
      #   @param destOffset [unsigned int]
      #   @param srcOffset [unsigned int]
      #   @param count [unsigned int]
      #   @return [void]
      [:rlCopyShaderBuffer, :rlCopyShaderBuffer, [:uint, :uint, :uint, :uint, :uint], :void],

      # @!method rlGetShaderBufferSize(id)
      #   rlGetShaderBufferSize : Get SSBO buffer size
      #   @param id [unsigned int]
      #   @return [unsigned int]
      [:rlGetShaderBufferSize, :rlGetShaderBufferSize, [:uint], :uint],

      # @!method rlBindImageTexture(id, index, format, readonly)
      #   rlBindImageTexture : Bind image texture
      #   @param id [unsigned int]
      #   @param index [unsigned int]
      #   @param format [int]
      #   @param readonly [bool]
      #   @return [void]
      [:rlBindImageTexture, :rlBindImageTexture, [:uint, :uint, :int, :bool], :void],

      # @!method rlGetMatrixModelview()
      #   rlGetMatrixModelview : Get internal modelview matrix
      #   @return [Matrix]
      [:rlGetMatrixModelview, :rlGetMatrixModelview, [], Matrix.by_value],

      # @!method rlGetMatrixProjection()
      #   rlGetMatrixProjection : Get internal projection matrix
      #   @return [Matrix]
      [:rlGetMatrixProjection, :rlGetMatrixProjection, [], Matrix.by_value],

      # @!method rlGetMatrixTransform()
      #   rlGetMatrixTransform : Get internal accumulated transform matrix
      #   @return [Matrix]
      [:rlGetMatrixTransform, :rlGetMatrixTransform, [], Matrix.by_value],

      # @!method rlGetMatrixProjectionStereo(eye)
      #   rlGetMatrixProjectionStereo : Get internal projection matrix for stereo render (selected eye)
      #   @param eye [int]
      #   @return [Matrix]
      [:rlGetMatrixProjectionStereo, :rlGetMatrixProjectionStereo, [:int], Matrix.by_value],

      # @!method rlGetMatrixViewOffsetStereo(eye)
      #   rlGetMatrixViewOffsetStereo : Get internal view offset matrix for stereo render (selected eye)
      #   @param eye [int]
      #   @return [Matrix]
      [:rlGetMatrixViewOffsetStereo, :rlGetMatrixViewOffsetStereo, [:int], Matrix.by_value],

      # @!method rlSetMatrixProjection(proj)
      #   rlSetMatrixProjection : Set a custom projection matrix (replaces internal projection matrix)
      #   @param proj [Matrix]
      #   @return [void]
      [:rlSetMatrixProjection, :rlSetMatrixProjection, [Matrix.by_value], :void],

      # @!method rlSetMatrixModelview(view)
      #   rlSetMatrixModelview : Set a custom modelview matrix (replaces internal modelview matrix)
      #   @param view [Matrix]
      #   @return [void]
      [:rlSetMatrixModelview, :rlSetMatrixModelview, [Matrix.by_value], :void],

      # @!method rlSetMatrixProjectionStereo(right, left)
      #   rlSetMatrixProjectionStereo : Set eyes projection matrices for stereo rendering
      #   @param right [Matrix]
      #   @param left [Matrix]
      #   @return [void]
      [:rlSetMatrixProjectionStereo, :rlSetMatrixProjectionStereo, [Matrix.by_value, Matrix.by_value], :void],

      # @!method rlSetMatrixViewOffsetStereo(right, left)
      #   rlSetMatrixViewOffsetStereo : Set eyes view offsets matrices for stereo rendering
      #   @param right [Matrix]
      #   @param left [Matrix]
      #   @return [void]
      [:rlSetMatrixViewOffsetStereo, :rlSetMatrixViewOffsetStereo, [Matrix.by_value, Matrix.by_value], :void],

      # @!method rlLoadDrawCube()
      #   rlLoadDrawCube : Load and draw a cube
      #   @return [void]
      [:rlLoadDrawCube, :rlLoadDrawCube, [], :void],

      # @!method rlLoadDrawQuad()
      #   rlLoadDrawQuad : Load and draw a quad
      #   @return [void]
      [:rlLoadDrawQuad, :rlLoadDrawQuad, [], :void],
    ]
    entries.each do |entry|
      api_name = if method_naming == :snake_case
                   snake_case_name = entry[0].to_s.gsub(/([A-Z]+)([A-Z0-9][a-z])/, '\1_\2').gsub(/([a-z\d])([A-Z0-9])/, '\1_\2').downcase
                   snake_case_name.gsub!('vector_3', 'vector3_') if snake_case_name.include?('vector_3')
                   snake_case_name.gsub!('vector_2', 'vector2_') if snake_case_name.include?('vector_2')
                   snake_case_name.chop! if snake_case_name.end_with?('_')
                   snake_case_name.to_sym
                 else
                   entry[0]
                 end
      attach_function api_name, entry[1], entry[2], entry[3]
    rescue FFI::NotFoundError => e
      warn "[Warning] Failed to import #{entry[0]} (#{e})."
    end
  end
end
