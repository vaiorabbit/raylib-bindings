# Yet another raylib wrapper for Ruby
#
# * https://github.com/vaiorabbit/raylib-bindings
#
# [NOTICE] Autogenerated. Do not edit.

require 'ffi'

module Raylib
  extend FFI::Library

  # Define/Macro

  RAYLIB_VERSION_MAJOR = 5
  RAYLIB_VERSION_MINOR = 6
  RAYLIB_VERSION_PATCH = 0
  RAYLIB_VERSION = "5.6-dev"

  # Enum

  # enum ConfigFlags
  # System/Window config flags
  FLAG_VSYNC_HINT = 64                  # Set to try enabling V-Sync on GPU
  FLAG_FULLSCREEN_MODE = 2              # Set to run program in fullscreen
  FLAG_WINDOW_RESIZABLE = 4             # Set to allow resizable window
  FLAG_WINDOW_UNDECORATED = 8           # Set to disable window decoration (frame and buttons)
  FLAG_WINDOW_HIDDEN = 128              # Set to hide window
  FLAG_WINDOW_MINIMIZED = 512           # Set to minimize window (iconify)
  FLAG_WINDOW_MAXIMIZED = 1024          # Set to maximize window (expanded to monitor)
  FLAG_WINDOW_UNFOCUSED = 2048          # Set to window non focused
  FLAG_WINDOW_TOPMOST = 4096            # Set to window always on top
  FLAG_WINDOW_ALWAYS_RUN = 256          # Set to allow windows running while minimized
  FLAG_WINDOW_TRANSPARENT = 16          # Set to allow transparent framebuffer
  FLAG_WINDOW_HIGHDPI = 8192            # Set to support HighDPI
  FLAG_WINDOW_MOUSE_PASSTHROUGH = 16384 # Set to support mouse passthrough, only supported when FLAG_WINDOW_UNDECORATED
  FLAG_BORDERLESS_WINDOWED_MODE = 32768 # Set to run program in borderless windowed mode
  FLAG_MSAA_4X_HINT = 32                # Set to try enabling MSAA 4X
  FLAG_INTERLACED_HINT = 65536          # Set to try enabling interlaced video format (for V3D)

  # enum TraceLogLevel
  # Trace log level
  LOG_ALL = 0     # Display all logs
  LOG_TRACE = 1   # Trace logging, intended for internal use only
  LOG_DEBUG = 2   # Debug logging, used for internal debugging, it should be disabled on release builds
  LOG_INFO = 3    # Info logging, used for program execution info
  LOG_WARNING = 4 # Warning logging, used on recoverable failures
  LOG_ERROR = 5   # Error logging, used on unrecoverable failures
  LOG_FATAL = 6   # Fatal logging, used to abort program: exit(EXIT_FAILURE)
  LOG_NONE = 7    # Disable logging

  # enum KeyboardKey
  # Keyboard keys (US keyboard layout)
  KEY_NULL = 0            # Key: NULL, used for no key pressed
  KEY_APOSTROPHE = 39     # Key: '
  KEY_COMMA = 44          # Key: ,
  KEY_MINUS = 45          # Key: -
  KEY_PERIOD = 46         # Key: .
  KEY_SLASH = 47          # Key: /
  KEY_ZERO = 48           # Key: 0
  KEY_ONE = 49            # Key: 1
  KEY_TWO = 50            # Key: 2
  KEY_THREE = 51          # Key: 3
  KEY_FOUR = 52           # Key: 4
  KEY_FIVE = 53           # Key: 5
  KEY_SIX = 54            # Key: 6
  KEY_SEVEN = 55          # Key: 7
  KEY_EIGHT = 56          # Key: 8
  KEY_NINE = 57           # Key: 9
  KEY_SEMICOLON = 59      # Key: ;
  KEY_EQUAL = 61          # Key: =
  KEY_A = 65              # Key: A | a
  KEY_B = 66              # Key: B | b
  KEY_C = 67              # Key: C | c
  KEY_D = 68              # Key: D | d
  KEY_E = 69              # Key: E | e
  KEY_F = 70              # Key: F | f
  KEY_G = 71              # Key: G | g
  KEY_H = 72              # Key: H | h
  KEY_I = 73              # Key: I | i
  KEY_J = 74              # Key: J | j
  KEY_K = 75              # Key: K | k
  KEY_L = 76              # Key: L | l
  KEY_M = 77              # Key: M | m
  KEY_N = 78              # Key: N | n
  KEY_O = 79              # Key: O | o
  KEY_P = 80              # Key: P | p
  KEY_Q = 81              # Key: Q | q
  KEY_R = 82              # Key: R | r
  KEY_S = 83              # Key: S | s
  KEY_T = 84              # Key: T | t
  KEY_U = 85              # Key: U | u
  KEY_V = 86              # Key: V | v
  KEY_W = 87              # Key: W | w
  KEY_X = 88              # Key: X | x
  KEY_Y = 89              # Key: Y | y
  KEY_Z = 90              # Key: Z | z
  KEY_LEFT_BRACKET = 91   # Key: [
  KEY_BACKSLASH = 92      # Key: '\'
  KEY_RIGHT_BRACKET = 93  # Key: ]
  KEY_GRAVE = 96          # Key: `
  KEY_SPACE = 32          # Key: Space
  KEY_ESCAPE = 256        # Key: Esc
  KEY_ENTER = 257         # Key: Enter
  KEY_TAB = 258           # Key: Tab
  KEY_BACKSPACE = 259     # Key: Backspace
  KEY_INSERT = 260        # Key: Ins
  KEY_DELETE = 261        # Key: Del
  KEY_RIGHT = 262         # Key: Cursor right
  KEY_LEFT = 263          # Key: Cursor left
  KEY_DOWN = 264          # Key: Cursor down
  KEY_UP = 265            # Key: Cursor up
  KEY_PAGE_UP = 266       # Key: Page up
  KEY_PAGE_DOWN = 267     # Key: Page down
  KEY_HOME = 268          # Key: Home
  KEY_END = 269           # Key: End
  KEY_CAPS_LOCK = 280     # Key: Caps lock
  KEY_SCROLL_LOCK = 281   # Key: Scroll down
  KEY_NUM_LOCK = 282      # Key: Num lock
  KEY_PRINT_SCREEN = 283  # Key: Print screen
  KEY_PAUSE = 284         # Key: Pause
  KEY_F1 = 290            # Key: F1
  KEY_F2 = 291            # Key: F2
  KEY_F3 = 292            # Key: F3
  KEY_F4 = 293            # Key: F4
  KEY_F5 = 294            # Key: F5
  KEY_F6 = 295            # Key: F6
  KEY_F7 = 296            # Key: F7
  KEY_F8 = 297            # Key: F8
  KEY_F9 = 298            # Key: F9
  KEY_F10 = 299           # Key: F10
  KEY_F11 = 300           # Key: F11
  KEY_F12 = 301           # Key: F12
  KEY_LEFT_SHIFT = 340    # Key: Shift left
  KEY_LEFT_CONTROL = 341  # Key: Control left
  KEY_LEFT_ALT = 342      # Key: Alt left
  KEY_LEFT_SUPER = 343    # Key: Super left
  KEY_RIGHT_SHIFT = 344   # Key: Shift right
  KEY_RIGHT_CONTROL = 345 # Key: Control right
  KEY_RIGHT_ALT = 346     # Key: Alt right
  KEY_RIGHT_SUPER = 347   # Key: Super right
  KEY_KB_MENU = 348       # Key: KB menu
  KEY_KP_0 = 320          # Key: Keypad 0
  KEY_KP_1 = 321          # Key: Keypad 1
  KEY_KP_2 = 322          # Key: Keypad 2
  KEY_KP_3 = 323          # Key: Keypad 3
  KEY_KP_4 = 324          # Key: Keypad 4
  KEY_KP_5 = 325          # Key: Keypad 5
  KEY_KP_6 = 326          # Key: Keypad 6
  KEY_KP_7 = 327          # Key: Keypad 7
  KEY_KP_8 = 328          # Key: Keypad 8
  KEY_KP_9 = 329          # Key: Keypad 9
  KEY_KP_DECIMAL = 330    # Key: Keypad .
  KEY_KP_DIVIDE = 331     # Key: Keypad /
  KEY_KP_MULTIPLY = 332   # Key: Keypad *
  KEY_KP_SUBTRACT = 333   # Key: Keypad -
  KEY_KP_ADD = 334        # Key: Keypad +
  KEY_KP_ENTER = 335      # Key: Keypad Enter
  KEY_KP_EQUAL = 336      # Key: Keypad =
  KEY_BACK = 4            # Key: Android back button
  KEY_MENU = 5            # Key: Android menu button
  KEY_VOLUME_UP = 24      # Key: Android volume up button
  KEY_VOLUME_DOWN = 25    # Key: Android volume down button

  # enum MouseButton
  # Mouse buttons
  MOUSE_BUTTON_LEFT = 0    # Mouse button left
  MOUSE_BUTTON_RIGHT = 1   # Mouse button right
  MOUSE_BUTTON_MIDDLE = 2  # Mouse button middle (pressed wheel)
  MOUSE_BUTTON_SIDE = 3    # Mouse button side (advanced mouse device)
  MOUSE_BUTTON_EXTRA = 4   # Mouse button extra (advanced mouse device)
  MOUSE_BUTTON_FORWARD = 5 # Mouse button forward (advanced mouse device)
  MOUSE_BUTTON_BACK = 6    # Mouse button back (advanced mouse device)

  # enum MouseCursor
  # Mouse cursor
  MOUSE_CURSOR_DEFAULT = 0       # Default pointer shape
  MOUSE_CURSOR_ARROW = 1         # Arrow shape
  MOUSE_CURSOR_IBEAM = 2         # Text writing cursor shape
  MOUSE_CURSOR_CROSSHAIR = 3     # Cross shape
  MOUSE_CURSOR_POINTING_HAND = 4 # Pointing hand cursor
  MOUSE_CURSOR_RESIZE_EW = 5     # Horizontal resize/move arrow shape
  MOUSE_CURSOR_RESIZE_NS = 6     # Vertical resize/move arrow shape
  MOUSE_CURSOR_RESIZE_NWSE = 7   # Top-left to bottom-right diagonal resize/move arrow shape
  MOUSE_CURSOR_RESIZE_NESW = 8   # The top-right to bottom-left diagonal resize/move arrow shape
  MOUSE_CURSOR_RESIZE_ALL = 9    # The omnidirectional resize/move cursor shape
  MOUSE_CURSOR_NOT_ALLOWED = 10  # The operation-not-allowed shape

  # enum GamepadButton
  # Gamepad buttons
  GAMEPAD_BUTTON_UNKNOWN = 0          # Unknown button, just for error checking
  GAMEPAD_BUTTON_LEFT_FACE_UP = 1     # Gamepad left DPAD up button
  GAMEPAD_BUTTON_LEFT_FACE_RIGHT = 2  # Gamepad left DPAD right button
  GAMEPAD_BUTTON_LEFT_FACE_DOWN = 3   # Gamepad left DPAD down button
  GAMEPAD_BUTTON_LEFT_FACE_LEFT = 4   # Gamepad left DPAD left button
  GAMEPAD_BUTTON_RIGHT_FACE_UP = 5    # Gamepad right button up (i.e. PS3: Triangle, Xbox: Y)
  GAMEPAD_BUTTON_RIGHT_FACE_RIGHT = 6 # Gamepad right button right (i.e. PS3: Circle, Xbox: B)
  GAMEPAD_BUTTON_RIGHT_FACE_DOWN = 7  # Gamepad right button down (i.e. PS3: Cross, Xbox: A)
  GAMEPAD_BUTTON_RIGHT_FACE_LEFT = 8  # Gamepad right button left (i.e. PS3: Square, Xbox: X)
  GAMEPAD_BUTTON_LEFT_TRIGGER_1 = 9   # Gamepad top/back trigger left (first), it could be a trailing button
  GAMEPAD_BUTTON_LEFT_TRIGGER_2 = 10  # Gamepad top/back trigger left (second), it could be a trailing button
  GAMEPAD_BUTTON_RIGHT_TRIGGER_1 = 11 # Gamepad top/back trigger right (first), it could be a trailing button
  GAMEPAD_BUTTON_RIGHT_TRIGGER_2 = 12 # Gamepad top/back trigger right (second), it could be a trailing button
  GAMEPAD_BUTTON_MIDDLE_LEFT = 13     # Gamepad center buttons, left one (i.e. PS3: Select)
  GAMEPAD_BUTTON_MIDDLE = 14          # Gamepad center buttons, middle one (i.e. PS3: PS, Xbox: XBOX)
  GAMEPAD_BUTTON_MIDDLE_RIGHT = 15    # Gamepad center buttons, right one (i.e. PS3: Start)
  GAMEPAD_BUTTON_LEFT_THUMB = 16      # Gamepad joystick pressed button left
  GAMEPAD_BUTTON_RIGHT_THUMB = 17     # Gamepad joystick pressed button right

  # enum GamepadAxis
  # Gamepad axes
  GAMEPAD_AXIS_LEFT_X = 0        # Gamepad left stick X axis
  GAMEPAD_AXIS_LEFT_Y = 1        # Gamepad left stick Y axis
  GAMEPAD_AXIS_RIGHT_X = 2       # Gamepad right stick X axis
  GAMEPAD_AXIS_RIGHT_Y = 3       # Gamepad right stick Y axis
  GAMEPAD_AXIS_LEFT_TRIGGER = 4  # Gamepad back trigger left, pressure level: [1..-1]
  GAMEPAD_AXIS_RIGHT_TRIGGER = 5 # Gamepad back trigger right, pressure level: [1..-1]

  # enum MaterialMapIndex
  # Material map index
  MATERIAL_MAP_ALBEDO = 0     # Albedo material (same as: MATERIAL_MAP_DIFFUSE)
  MATERIAL_MAP_METALNESS = 1  # Metalness material (same as: MATERIAL_MAP_SPECULAR)
  MATERIAL_MAP_NORMAL = 2     # Normal material
  MATERIAL_MAP_ROUGHNESS = 3  # Roughness material
  MATERIAL_MAP_OCCLUSION = 4  # Ambient occlusion material
  MATERIAL_MAP_EMISSION = 5   # Emission material
  MATERIAL_MAP_HEIGHT = 6     # Heightmap material
  MATERIAL_MAP_CUBEMAP = 7    # Cubemap material (NOTE: Uses GL_TEXTURE_CUBE_MAP)
  MATERIAL_MAP_IRRADIANCE = 8 # Irradiance material (NOTE: Uses GL_TEXTURE_CUBE_MAP)
  MATERIAL_MAP_PREFILTER = 9  # Prefilter material (NOTE: Uses GL_TEXTURE_CUBE_MAP)
  MATERIAL_MAP_BRDF = 10      # Brdf material

  # enum ShaderLocationIndex
  # Shader location index
  SHADER_LOC_VERTEX_POSITION = 0     # Shader location: vertex attribute: position
  SHADER_LOC_VERTEX_TEXCOORD01 = 1   # Shader location: vertex attribute: texcoord01
  SHADER_LOC_VERTEX_TEXCOORD02 = 2   # Shader location: vertex attribute: texcoord02
  SHADER_LOC_VERTEX_NORMAL = 3       # Shader location: vertex attribute: normal
  SHADER_LOC_VERTEX_TANGENT = 4      # Shader location: vertex attribute: tangent
  SHADER_LOC_VERTEX_COLOR = 5        # Shader location: vertex attribute: color
  SHADER_LOC_MATRIX_MVP = 6          # Shader location: matrix uniform: model-view-projection
  SHADER_LOC_MATRIX_VIEW = 7         # Shader location: matrix uniform: view (camera transform)
  SHADER_LOC_MATRIX_PROJECTION = 8   # Shader location: matrix uniform: projection
  SHADER_LOC_MATRIX_MODEL = 9        # Shader location: matrix uniform: model (transform)
  SHADER_LOC_MATRIX_NORMAL = 10      # Shader location: matrix uniform: normal
  SHADER_LOC_VECTOR_VIEW = 11        # Shader location: vector uniform: view
  SHADER_LOC_COLOR_DIFFUSE = 12      # Shader location: vector uniform: diffuse color
  SHADER_LOC_COLOR_SPECULAR = 13     # Shader location: vector uniform: specular color
  SHADER_LOC_COLOR_AMBIENT = 14      # Shader location: vector uniform: ambient color
  SHADER_LOC_MAP_ALBEDO = 15         # Shader location: sampler2d texture: albedo (same as: SHADER_LOC_MAP_DIFFUSE)
  SHADER_LOC_MAP_METALNESS = 16      # Shader location: sampler2d texture: metalness (same as: SHADER_LOC_MAP_SPECULAR)
  SHADER_LOC_MAP_NORMAL = 17         # Shader location: sampler2d texture: normal
  SHADER_LOC_MAP_ROUGHNESS = 18      # Shader location: sampler2d texture: roughness
  SHADER_LOC_MAP_OCCLUSION = 19      # Shader location: sampler2d texture: occlusion
  SHADER_LOC_MAP_EMISSION = 20       # Shader location: sampler2d texture: emission
  SHADER_LOC_MAP_HEIGHT = 21         # Shader location: sampler2d texture: height
  SHADER_LOC_MAP_CUBEMAP = 22        # Shader location: samplerCube texture: cubemap
  SHADER_LOC_MAP_IRRADIANCE = 23     # Shader location: samplerCube texture: irradiance
  SHADER_LOC_MAP_PREFILTER = 24      # Shader location: samplerCube texture: prefilter
  SHADER_LOC_MAP_BRDF = 25           # Shader location: sampler2d texture: brdf
  SHADER_LOC_VERTEX_BONEIDS = 26     # Shader location: vertex attribute: boneIds
  SHADER_LOC_VERTEX_BONEWEIGHTS = 27 # Shader location: vertex attribute: boneWeights
  SHADER_LOC_BONE_MATRICES = 28      # Shader location: array of matrices uniform: boneMatrices
  SHADER_LOC_VERTEX_INSTANCE_TX = 29 # Shader location: vertex attribute: instanceTransform

  # enum ShaderUniformDataType
  # Shader uniform data type
  SHADER_UNIFORM_FLOAT = 0      # Shader uniform type: float
  SHADER_UNIFORM_VEC2 = 1       # Shader uniform type: vec2 (2 float)
  SHADER_UNIFORM_VEC3 = 2       # Shader uniform type: vec3 (3 float)
  SHADER_UNIFORM_VEC4 = 3       # Shader uniform type: vec4 (4 float)
  SHADER_UNIFORM_INT = 4        # Shader uniform type: int
  SHADER_UNIFORM_IVEC2 = 5      # Shader uniform type: ivec2 (2 int)
  SHADER_UNIFORM_IVEC3 = 6      # Shader uniform type: ivec3 (3 int)
  SHADER_UNIFORM_IVEC4 = 7      # Shader uniform type: ivec4 (4 int)
  SHADER_UNIFORM_UINT = 8       # Shader uniform type: unsigned int
  SHADER_UNIFORM_UIVEC2 = 9     # Shader uniform type: uivec2 (2 unsigned int)
  SHADER_UNIFORM_UIVEC3 = 10    # Shader uniform type: uivec3 (3 unsigned int)
  SHADER_UNIFORM_UIVEC4 = 11    # Shader uniform type: uivec4 (4 unsigned int)
  SHADER_UNIFORM_SAMPLER2D = 12 # Shader uniform type: sampler2d

  # enum ShaderAttributeDataType
  # Shader attribute data types
  SHADER_ATTRIB_FLOAT = 0 # Shader attribute type: float
  SHADER_ATTRIB_VEC2 = 1  # Shader attribute type: vec2 (2 float)
  SHADER_ATTRIB_VEC3 = 2  # Shader attribute type: vec3 (3 float)
  SHADER_ATTRIB_VEC4 = 3  # Shader attribute type: vec4 (4 float)

  # enum PixelFormat
  # Pixel formats
  PIXELFORMAT_UNCOMPRESSED_GRAYSCALE = 1     # 8 bit per pixel (no alpha)
  PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA = 2    # 8*2 bpp (2 channels)
  PIXELFORMAT_UNCOMPRESSED_R5G6B5 = 3        # 16 bpp
  PIXELFORMAT_UNCOMPRESSED_R8G8B8 = 4        # 24 bpp
  PIXELFORMAT_UNCOMPRESSED_R5G5B5A1 = 5      # 16 bpp (1 bit alpha)
  PIXELFORMAT_UNCOMPRESSED_R4G4B4A4 = 6      # 16 bpp (4 bit alpha)
  PIXELFORMAT_UNCOMPRESSED_R8G8B8A8 = 7      # 32 bpp
  PIXELFORMAT_UNCOMPRESSED_R32 = 8           # 32 bpp (1 channel - float)
  PIXELFORMAT_UNCOMPRESSED_R32G32B32 = 9     # 32*3 bpp (3 channels - float)
  PIXELFORMAT_UNCOMPRESSED_R32G32B32A32 = 10 # 32*4 bpp (4 channels - float)
  PIXELFORMAT_UNCOMPRESSED_R16 = 11          # 16 bpp (1 channel - half float)
  PIXELFORMAT_UNCOMPRESSED_R16G16B16 = 12    # 16*3 bpp (3 channels - half float)
  PIXELFORMAT_UNCOMPRESSED_R16G16B16A16 = 13 # 16*4 bpp (4 channels - half float)
  PIXELFORMAT_COMPRESSED_DXT1_RGB = 14       # 4 bpp (no alpha)
  PIXELFORMAT_COMPRESSED_DXT1_RGBA = 15      # 4 bpp (1 bit alpha)
  PIXELFORMAT_COMPRESSED_DXT3_RGBA = 16      # 8 bpp
  PIXELFORMAT_COMPRESSED_DXT5_RGBA = 17      # 8 bpp
  PIXELFORMAT_COMPRESSED_ETC1_RGB = 18       # 4 bpp
  PIXELFORMAT_COMPRESSED_ETC2_RGB = 19       # 4 bpp
  PIXELFORMAT_COMPRESSED_ETC2_EAC_RGBA = 20  # 8 bpp
  PIXELFORMAT_COMPRESSED_PVRT_RGB = 21       # 4 bpp
  PIXELFORMAT_COMPRESSED_PVRT_RGBA = 22      # 4 bpp
  PIXELFORMAT_COMPRESSED_ASTC_4x4_RGBA = 23  # 8 bpp
  PIXELFORMAT_COMPRESSED_ASTC_8x8_RGBA = 24  # 2 bpp

  # enum TextureFilter
  # Texture parameters: filter mode
  TEXTURE_FILTER_POINT = 0           # No filter, just pixel approximation
  TEXTURE_FILTER_BILINEAR = 1        # Linear filtering
  TEXTURE_FILTER_TRILINEAR = 2       # Trilinear filtering (linear with mipmaps)
  TEXTURE_FILTER_ANISOTROPIC_4X = 3  # Anisotropic filtering 4x
  TEXTURE_FILTER_ANISOTROPIC_8X = 4  # Anisotropic filtering 8x
  TEXTURE_FILTER_ANISOTROPIC_16X = 5 # Anisotropic filtering 16x

  # enum TextureWrap
  # Texture parameters: wrap mode
  TEXTURE_WRAP_REPEAT = 0        # Repeats texture in tiled mode
  TEXTURE_WRAP_CLAMP = 1         # Clamps texture to edge pixel in tiled mode
  TEXTURE_WRAP_MIRROR_REPEAT = 2 # Mirrors and repeats the texture in tiled mode
  TEXTURE_WRAP_MIRROR_CLAMP = 3  # Mirrors and clamps to border the texture in tiled mode

  # enum CubemapLayout
  # Cubemap layouts
  CUBEMAP_LAYOUT_AUTO_DETECT = 0         # Automatically detect layout type
  CUBEMAP_LAYOUT_LINE_VERTICAL = 1       # Layout is defined by a vertical line with faces
  CUBEMAP_LAYOUT_LINE_HORIZONTAL = 2     # Layout is defined by a horizontal line with faces
  CUBEMAP_LAYOUT_CROSS_THREE_BY_FOUR = 3 # Layout is defined by a 3x4 cross with cubemap faces
  CUBEMAP_LAYOUT_CROSS_FOUR_BY_THREE = 4 # Layout is defined by a 4x3 cross with cubemap faces

  # enum FontType
  # Font type, defines generation method
  FONT_DEFAULT = 0 # Default font generation, anti-aliased
  FONT_BITMAP = 1  # Bitmap font generation, no anti-aliasing
  FONT_SDF = 2     # SDF font generation, requires external shader

  # enum BlendMode
  # Color blending modes (pre-defined)
  BLEND_ALPHA = 0             # Blend textures considering alpha (default)
  BLEND_ADDITIVE = 1          # Blend textures adding colors
  BLEND_MULTIPLIED = 2        # Blend textures multiplying colors
  BLEND_ADD_COLORS = 3        # Blend textures adding colors (alternative)
  BLEND_SUBTRACT_COLORS = 4   # Blend textures subtracting colors (alternative)
  BLEND_ALPHA_PREMULTIPLY = 5 # Blend premultiplied textures considering alpha
  BLEND_CUSTOM = 6            # Blend textures using custom src/dst factors (use rlSetBlendFactors())
  BLEND_CUSTOM_SEPARATE = 7   # Blend textures using custom rgb/alpha separate src/dst factors (use rlSetBlendFactorsSeparate())

  # enum Gesture
  # Gesture
  GESTURE_NONE = 0         # No gesture
  GESTURE_TAP = 1          # Tap gesture
  GESTURE_DOUBLETAP = 2    # Double tap gesture
  GESTURE_HOLD = 4         # Hold gesture
  GESTURE_DRAG = 8         # Drag gesture
  GESTURE_SWIPE_RIGHT = 16 # Swipe right gesture
  GESTURE_SWIPE_LEFT = 32  # Swipe left gesture
  GESTURE_SWIPE_UP = 64    # Swipe up gesture
  GESTURE_SWIPE_DOWN = 128 # Swipe down gesture
  GESTURE_PINCH_IN = 256   # Pinch in gesture
  GESTURE_PINCH_OUT = 512  # Pinch out gesture

  # enum CameraMode
  # Camera system modes
  CAMERA_CUSTOM = 0       # Camera custom, controlled by user (UpdateCamera() does nothing)
  CAMERA_FREE = 1         # Camera free mode
  CAMERA_ORBITAL = 2      # Camera orbital, around target, zoom supported
  CAMERA_FIRST_PERSON = 3 # Camera first person
  CAMERA_THIRD_PERSON = 4 # Camera third person

  # enum CameraProjection
  # Camera projection
  CAMERA_PERSPECTIVE = 0  # Perspective projection
  CAMERA_ORTHOGRAPHIC = 1 # Orthographic projection

  # enum NPatchLayout
  # N-patch layout
  NPATCH_NINE_PATCH = 0             # Npatch layout: 3x3 tiles
  NPATCH_THREE_PATCH_VERTICAL = 1   # Npatch layout: 1x3 tiles
  NPATCH_THREE_PATCH_HORIZONTAL = 2 # Npatch layout: 3x1 tiles


  # Typedef

  typedef :int, :ConfigFlags
  typedef :int, :TraceLogLevel
  typedef :int, :KeyboardKey
  typedef :int, :MouseButton
  typedef :int, :MouseCursor
  typedef :int, :GamepadButton
  typedef :int, :GamepadAxis
  typedef :int, :MaterialMapIndex
  typedef :int, :ShaderLocationIndex
  typedef :int, :ShaderUniformDataType
  typedef :int, :ShaderAttributeDataType
  typedef :int, :PixelFormat
  typedef :int, :TextureFilter
  typedef :int, :TextureWrap
  typedef :int, :CubemapLayout
  typedef :int, :FontType
  typedef :int, :BlendMode
  typedef :int, :Gesture
  typedef :int, :CameraMode
  typedef :int, :CameraProjection
  typedef :int, :NPatchLayout
  callback :TraceLogCallback, [:int, :pointer, :pointer], :void
  callback :LoadFileDataCallback, [:pointer, :pointer], :pointer
  callback :SaveFileDataCallback, [:pointer, :pointer, :int], :bool
  callback :LoadFileTextCallback, [:pointer], :pointer
  callback :SaveFileTextCallback, [:pointer, :pointer], :bool
  callback :AudioCallback, [:pointer, :uint], :void

  # Struct

  # Vector2, 2 components
  class Vector2 < FFI::Struct
    layout(
      :x, :float, # Vector x component
      :y, :float, # Vector y component
    )
    def x = self[:x]
    def x=(v) self[:x] = v end
    def y = self[:y]
    def y=(v) self[:y] = v end
  end

  # Vector3, 3 components
  class Vector3 < FFI::Struct
    layout(
      :x, :float, # Vector x component
      :y, :float, # Vector y component
      :z, :float, # Vector z component
    )
    def x = self[:x]
    def x=(v) self[:x] = v end
    def y = self[:y]
    def y=(v) self[:y] = v end
    def z = self[:z]
    def z=(v) self[:z] = v end
  end

  # Vector4, 4 components
  class Vector4 < FFI::Struct
    layout(
      :x, :float, # Vector x component
      :y, :float, # Vector y component
      :z, :float, # Vector z component
      :w, :float, # Vector w component
    )
    def x = self[:x]
    def x=(v) self[:x] = v end
    def y = self[:y]
    def y=(v) self[:y] = v end
    def z = self[:z]
    def z=(v) self[:z] = v end
    def w = self[:w]
    def w=(v) self[:w] = v end
  end

  Quaternion = Vector4

  # Matrix, 4x4 components, column major, OpenGL style, right-handed
  class Matrix < FFI::Struct
    layout(
      :m0, :float,  # Matrix first row (4 components)
      :m4, :float,  # Matrix first row (4 components)
      :m8, :float,  # Matrix first row (4 components)
      :m12, :float, # Matrix first row (4 components)
      :m1, :float,  # Matrix second row (4 components)
      :m5, :float,  # Matrix second row (4 components)
      :m9, :float,  # Matrix second row (4 components)
      :m13, :float, # Matrix second row (4 components)
      :m2, :float,  # Matrix third row (4 components)
      :m6, :float,  # Matrix third row (4 components)
      :m10, :float, # Matrix third row (4 components)
      :m14, :float, # Matrix third row (4 components)
      :m3, :float,  # Matrix fourth row (4 components)
      :m7, :float,  # Matrix fourth row (4 components)
      :m11, :float, # Matrix fourth row (4 components)
      :m15, :float, # Matrix fourth row (4 components)
    )
    def m0 = self[:m0]
    def m0=(v) self[:m0] = v end
    def m4 = self[:m4]
    def m4=(v) self[:m4] = v end
    def m8 = self[:m8]
    def m8=(v) self[:m8] = v end
    def m12 = self[:m12]
    def m12=(v) self[:m12] = v end
    def m1 = self[:m1]
    def m1=(v) self[:m1] = v end
    def m5 = self[:m5]
    def m5=(v) self[:m5] = v end
    def m9 = self[:m9]
    def m9=(v) self[:m9] = v end
    def m13 = self[:m13]
    def m13=(v) self[:m13] = v end
    def m2 = self[:m2]
    def m2=(v) self[:m2] = v end
    def m6 = self[:m6]
    def m6=(v) self[:m6] = v end
    def m10 = self[:m10]
    def m10=(v) self[:m10] = v end
    def m14 = self[:m14]
    def m14=(v) self[:m14] = v end
    def m3 = self[:m3]
    def m3=(v) self[:m3] = v end
    def m7 = self[:m7]
    def m7=(v) self[:m7] = v end
    def m11 = self[:m11]
    def m11=(v) self[:m11] = v end
    def m15 = self[:m15]
    def m15=(v) self[:m15] = v end
  end

  # Color, 4 components, R8G8B8A8 (32bit)
  class Color < FFI::Struct
    layout(
      :r, :uchar, # Color red value
      :g, :uchar, # Color green value
      :b, :uchar, # Color blue value
      :a, :uchar, # Color alpha value
    )
    def r = self[:r]
    def r=(v) self[:r] = v end
    def g = self[:g]
    def g=(v) self[:g] = v end
    def b = self[:b]
    def b=(v) self[:b] = v end
    def a = self[:a]
    def a=(v) self[:a] = v end
  end

  # Rectangle, 4 components
  class Rectangle < FFI::Struct
    layout(
      :x, :float,      # Rectangle top-left corner position x
      :y, :float,      # Rectangle top-left corner position y
      :width, :float,  # Rectangle width
      :height, :float, # Rectangle height
    )
    def x = self[:x]
    def x=(v) self[:x] = v end
    def y = self[:y]
    def y=(v) self[:y] = v end
    def width = self[:width]
    def width=(v) self[:width] = v end
    def height = self[:height]
    def height=(v) self[:height] = v end
  end

  # Image, pixel data stored in CPU memory (RAM)
  class Image < FFI::Struct
    layout(
      :data, :pointer, # Image raw data
      :width, :int,    # Image base width
      :height, :int,   # Image base height
      :mipmaps, :int,  # Mipmap levels, 1 by default
      :format, :int,   # Data format (PixelFormat type)
    )
    def data = self[:data]
    def data=(v) self[:data] = v end
    def width = self[:width]
    def width=(v) self[:width] = v end
    def height = self[:height]
    def height=(v) self[:height] = v end
    def mipmaps = self[:mipmaps]
    def mipmaps=(v) self[:mipmaps] = v end
    def format = self[:format]
    def format=(v) self[:format] = v end
  end

  # Texture, tex data stored in GPU memory (VRAM)
  class Texture < FFI::Struct
    layout(
      :id, :uint,     # OpenGL texture id
      :width, :int,   # Texture base width
      :height, :int,  # Texture base height
      :mipmaps, :int, # Mipmap levels, 1 by default
      :format, :int,  # Data format (PixelFormat type)
    )
    def id = self[:id]
    def id=(v) self[:id] = v end
    def width = self[:width]
    def width=(v) self[:width] = v end
    def height = self[:height]
    def height=(v) self[:height] = v end
    def mipmaps = self[:mipmaps]
    def mipmaps=(v) self[:mipmaps] = v end
    def format = self[:format]
    def format=(v) self[:format] = v end
  end

  Texture2D = Texture
  TextureCubemap = Texture

  # RenderTexture, fbo for texture rendering
  class RenderTexture < FFI::Struct
    layout(
      :id, :uint,        # OpenGL framebuffer object id
      :texture, Texture, # Color buffer attachment texture
      :depth, Texture,   # Depth buffer attachment texture
    )
    def id = self[:id]
    def id=(v) self[:id] = v end
    def texture = self[:texture]
    def texture=(v) self[:texture] = v end
    def depth = self[:depth]
    def depth=(v) self[:depth] = v end
  end

  RenderTexture2D = RenderTexture

  # NPatchInfo, n-patch layout info
  class NPatchInfo < FFI::Struct
    layout(
      :source, Rectangle, # Texture source rectangle
      :left, :int,        # Left border offset
      :top, :int,         # Top border offset
      :right, :int,       # Right border offset
      :bottom, :int,      # Bottom border offset
      :layout, :int,      # Layout of the n-patch: 3x3, 1x3 or 3x1
    )
    def source = self[:source]
    def source=(v) self[:source] = v end
    def left = self[:left]
    def left=(v) self[:left] = v end
    def top = self[:top]
    def top=(v) self[:top] = v end
    def right = self[:right]
    def right=(v) self[:right] = v end
    def bottom = self[:bottom]
    def bottom=(v) self[:bottom] = v end
    def layout = self[:layout]
    def layout=(v) self[:layout] = v end
  end

  # GlyphInfo, font characters glyphs info
  class GlyphInfo < FFI::Struct
    layout(
      :value, :int,    # Character value (Unicode)
      :offsetX, :int,  # Character offset X when drawing
      :offsetY, :int,  # Character offset Y when drawing
      :advanceX, :int, # Character advance position X
      :image, Image,   # Character image data
    )
    def value = self[:value]
    def value=(v) self[:value] = v end
    def offsetX = self[:offsetX]
    def offsetX=(v) self[:offsetX] = v end
    def offsetY = self[:offsetY]
    def offsetY=(v) self[:offsetY] = v end
    def advanceX = self[:advanceX]
    def advanceX=(v) self[:advanceX] = v end
    def image = self[:image]
    def image=(v) self[:image] = v end
  end

  # Font, font texture and GlyphInfo array data
  class Font < FFI::Struct
    layout(
      :baseSize, :int,     # Base size (default chars height)
      :glyphCount, :int,   # Number of glyph characters
      :glyphPadding, :int, # Padding around the glyph characters
      :texture, Texture2D, # Texture atlas containing the glyphs
      :recs, :pointer,     # Rectangles in texture for the glyphs
      :glyphs, :pointer,   # Glyphs info data
    )
    def baseSize = self[:baseSize]
    def baseSize=(v) self[:baseSize] = v end
    def glyphCount = self[:glyphCount]
    def glyphCount=(v) self[:glyphCount] = v end
    def glyphPadding = self[:glyphPadding]
    def glyphPadding=(v) self[:glyphPadding] = v end
    def texture = self[:texture]
    def texture=(v) self[:texture] = v end
    def recs = self[:recs]
    def recs=(v) self[:recs] = v end
    def glyphs = self[:glyphs]
    def glyphs=(v) self[:glyphs] = v end
  end

  # Camera, defines position/orientation in 3d space
  class Camera3D < FFI::Struct
    layout(
      :position, Vector3, # Camera position
      :target, Vector3,   # Camera target it looks-at
      :up, Vector3,       # Camera up vector (rotation over its axis)
      :fovy, :float,      # Camera field-of-view aperture in Y (degrees) in perspective, used as near plane height in world units in orthographic
      :projection, :int,  # Camera projection: CAMERA_PERSPECTIVE or CAMERA_ORTHOGRAPHIC
    )
    def position = self[:position]
    def position=(v) self[:position] = v end
    def target = self[:target]
    def target=(v) self[:target] = v end
    def up = self[:up]
    def up=(v) self[:up] = v end
    def fovy = self[:fovy]
    def fovy=(v) self[:fovy] = v end
    def projection = self[:projection]
    def projection=(v) self[:projection] = v end
  end

  Camera = Camera3D

  # Camera2D, defines position/orientation in 2d space
  class Camera2D < FFI::Struct
    layout(
      :offset, Vector2,  # Camera offset (displacement from target)
      :target, Vector2,  # Camera target (rotation and zoom origin)
      :rotation, :float, # Camera rotation in degrees
      :zoom, :float,     # Camera zoom (scaling), should be 1.0f by default
    )
    def offset = self[:offset]
    def offset=(v) self[:offset] = v end
    def target = self[:target]
    def target=(v) self[:target] = v end
    def rotation = self[:rotation]
    def rotation=(v) self[:rotation] = v end
    def zoom = self[:zoom]
    def zoom=(v) self[:zoom] = v end
  end

  # Mesh, vertex data and vao/vbo
  class Mesh < FFI::Struct
    layout(
      :vertexCount, :int,      # Number of vertices stored in arrays
      :triangleCount, :int,    # Number of triangles stored (indexed or not)
      :vertices, :pointer,     # Vertex position (XYZ - 3 components per vertex) (shader-location = 0)
      :texcoords, :pointer,    # Vertex texture coordinates (UV - 2 components per vertex) (shader-location = 1)
      :texcoords2, :pointer,   # Vertex texture second coordinates (UV - 2 components per vertex) (shader-location = 5)
      :normals, :pointer,      # Vertex normals (XYZ - 3 components per vertex) (shader-location = 2)
      :tangents, :pointer,     # Vertex tangents (XYZW - 4 components per vertex) (shader-location = 4)
      :colors, :pointer,       # Vertex colors (RGBA - 4 components per vertex) (shader-location = 3)
      :indices, :pointer,      # Vertex indices (in case vertex data comes indexed)
      :animVertices, :pointer, # Animated vertex positions (after bones transformations)
      :animNormals, :pointer,  # Animated normals (after bones transformations)
      :boneIds, :pointer,      # Vertex bone ids, max 255 bone ids, up to 4 bones influence by vertex (skinning) (shader-location = 6)
      :boneWeights, :pointer,  # Vertex bone weight, up to 4 bones influence by vertex (skinning) (shader-location = 7)
      :boneMatrices, :pointer, # Bones animated transformation matrices
      :boneCount, :int,        # Number of bones
      :vaoId, :uint,           # OpenGL Vertex Array Object id
      :vboId, :pointer,        # OpenGL Vertex Buffer Objects id (default vertex data)
    )
    def vertexCount = self[:vertexCount]
    def vertexCount=(v) self[:vertexCount] = v end
    def triangleCount = self[:triangleCount]
    def triangleCount=(v) self[:triangleCount] = v end
    def vertices = self[:vertices]
    def vertices=(v) self[:vertices] = v end
    def texcoords = self[:texcoords]
    def texcoords=(v) self[:texcoords] = v end
    def texcoords2 = self[:texcoords2]
    def texcoords2=(v) self[:texcoords2] = v end
    def normals = self[:normals]
    def normals=(v) self[:normals] = v end
    def tangents = self[:tangents]
    def tangents=(v) self[:tangents] = v end
    def colors = self[:colors]
    def colors=(v) self[:colors] = v end
    def indices = self[:indices]
    def indices=(v) self[:indices] = v end
    def animVertices = self[:animVertices]
    def animVertices=(v) self[:animVertices] = v end
    def animNormals = self[:animNormals]
    def animNormals=(v) self[:animNormals] = v end
    def boneIds = self[:boneIds]
    def boneIds=(v) self[:boneIds] = v end
    def boneWeights = self[:boneWeights]
    def boneWeights=(v) self[:boneWeights] = v end
    def boneMatrices = self[:boneMatrices]
    def boneMatrices=(v) self[:boneMatrices] = v end
    def boneCount = self[:boneCount]
    def boneCount=(v) self[:boneCount] = v end
    def vaoId = self[:vaoId]
    def vaoId=(v) self[:vaoId] = v end
    def vboId = self[:vboId]
    def vboId=(v) self[:vboId] = v end
  end

  # Shader
  class Shader < FFI::Struct
    layout(
      :id, :uint,      # Shader program id
      :locs, :pointer, # Shader locations array (RL_MAX_SHADER_LOCATIONS)
    )
    def id = self[:id]
    def id=(v) self[:id] = v end
    def locs = self[:locs]
    def locs=(v) self[:locs] = v end
  end

  # MaterialMap
  class MaterialMap < FFI::Struct
    layout(
      :texture, Texture2D, # Material map texture
      :color, Color,       # Material map color
      :value, :float,      # Material map value
    )
    def texture = self[:texture]
    def texture=(v) self[:texture] = v end
    def color = self[:color]
    def color=(v) self[:color] = v end
    def value = self[:value]
    def value=(v) self[:value] = v end
  end

  # Material, includes shader and maps
  class Material < FFI::Struct
    layout(
      :shader, Shader,      # Material shader
      :maps, :pointer,      # Material maps array (MAX_MATERIAL_MAPS)
      :params, [:float, 4], # Material generic parameters (if required)
    )
    def shader = self[:shader]
    def shader=(v) self[:shader] = v end
    def maps = self[:maps]
    def maps=(v) self[:maps] = v end
    def params = self[:params]
    def params=(v) self[:params] = v end
  end

  # Transform, vertex transformation data
  class Transform < FFI::Struct
    layout(
      :translation, Vector3, # Translation
      :rotation, Quaternion, # Rotation
      :scale, Vector3,       # Scale
    )
    def translation = self[:translation]
    def translation=(v) self[:translation] = v end
    def rotation = self[:rotation]
    def rotation=(v) self[:rotation] = v end
    def scale = self[:scale]
    def scale=(v) self[:scale] = v end
  end

  # Bone, skeletal animation bone
  class BoneInfo < FFI::Struct
    layout(
      :name, [:char, 32], # Bone name
      :parent, :int,      # Bone parent
    )
    def name = self[:name]
    def name=(v) self[:name] = v end
    def parent = self[:parent]
    def parent=(v) self[:parent] = v end
  end

  # Model, meshes, materials and animation data
  class Model < FFI::Struct
    layout(
      :transform, Matrix,      # Local transform matrix
      :meshCount, :int,        # Number of meshes
      :materialCount, :int,    # Number of materials
      :meshes, :pointer,       # Meshes array
      :materials, :pointer,    # Materials array
      :meshMaterial, :pointer, # Mesh material number
      :boneCount, :int,        # Number of bones
      :bones, :pointer,        # Bones information (skeleton)
      :bindPose, :pointer,     # Bones base transformation (pose)
    )
    def transform = self[:transform]
    def transform=(v) self[:transform] = v end
    def meshCount = self[:meshCount]
    def meshCount=(v) self[:meshCount] = v end
    def materialCount = self[:materialCount]
    def materialCount=(v) self[:materialCount] = v end
    def meshes = self[:meshes]
    def meshes=(v) self[:meshes] = v end
    def materials = self[:materials]
    def materials=(v) self[:materials] = v end
    def meshMaterial = self[:meshMaterial]
    def meshMaterial=(v) self[:meshMaterial] = v end
    def boneCount = self[:boneCount]
    def boneCount=(v) self[:boneCount] = v end
    def bones = self[:bones]
    def bones=(v) self[:bones] = v end
    def bindPose = self[:bindPose]
    def bindPose=(v) self[:bindPose] = v end
  end

  # ModelAnimation
  class ModelAnimation < FFI::Struct
    layout(
      :boneCount, :int,      # Number of bones
      :frameCount, :int,     # Number of animation frames
      :bones, :pointer,      # Bones information (skeleton)
      :framePoses, :pointer, # Poses array by frame
      :name, [:char, 32],    # Animation name
    )
    def boneCount = self[:boneCount]
    def boneCount=(v) self[:boneCount] = v end
    def frameCount = self[:frameCount]
    def frameCount=(v) self[:frameCount] = v end
    def bones = self[:bones]
    def bones=(v) self[:bones] = v end
    def framePoses = self[:framePoses]
    def framePoses=(v) self[:framePoses] = v end
    def name = self[:name]
    def name=(v) self[:name] = v end
  end

  # Ray, ray for raycasting
  class Ray < FFI::Struct
    layout(
      :position, Vector3,  # Ray position (origin)
      :direction, Vector3, # Ray direction (normalized)
    )
    def position = self[:position]
    def position=(v) self[:position] = v end
    def direction = self[:direction]
    def direction=(v) self[:direction] = v end
  end

  # RayCollision, ray hit information
  class RayCollision < FFI::Struct
    layout(
      :hit, :bool,       # Did the ray hit something?
      :distance, :float, # Distance to the nearest hit
      :point, Vector3,   # Point of the nearest hit
      :normal, Vector3,  # Surface normal of hit
    )
    def hit = self[:hit]
    def hit=(v) self[:hit] = v end
    def distance = self[:distance]
    def distance=(v) self[:distance] = v end
    def point = self[:point]
    def point=(v) self[:point] = v end
    def normal = self[:normal]
    def normal=(v) self[:normal] = v end
  end

  # BoundingBox
  class BoundingBox < FFI::Struct
    layout(
      :min, Vector3, # Minimum vertex box-corner
      :max, Vector3, # Maximum vertex box-corner
    )
    def min = self[:min]
    def min=(v) self[:min] = v end
    def max = self[:max]
    def max=(v) self[:max] = v end
  end

  # Wave, audio wave data
  class Wave < FFI::Struct
    layout(
      :frameCount, :uint, # Total number of frames (considering channels)
      :sampleRate, :uint, # Frequency (samples per second)
      :sampleSize, :uint, # Bit depth (bits per sample): 8, 16, 32 (24 not supported)
      :channels, :uint,   # Number of channels (1-mono, 2-stereo, ...)
      :data, :pointer,    # Buffer data pointer
    )
    def frameCount = self[:frameCount]
    def frameCount=(v) self[:frameCount] = v end
    def sampleRate = self[:sampleRate]
    def sampleRate=(v) self[:sampleRate] = v end
    def sampleSize = self[:sampleSize]
    def sampleSize=(v) self[:sampleSize] = v end
    def channels = self[:channels]
    def channels=(v) self[:channels] = v end
    def data = self[:data]
    def data=(v) self[:data] = v end
  end

  # AudioStream, custom audio stream
  class AudioStream < FFI::Struct
    layout(
      :buffer, :pointer,    # Pointer to internal data used by the audio system
      :processor, :pointer, # Pointer to internal data processor, useful for audio effects
      :sampleRate, :uint,   # Frequency (samples per second)
      :sampleSize, :uint,   # Bit depth (bits per sample): 8, 16, 32 (24 not supported)
      :channels, :uint,     # Number of channels (1-mono, 2-stereo, ...)
    )
    def buffer = self[:buffer]
    def buffer=(v) self[:buffer] = v end
    def processor = self[:processor]
    def processor=(v) self[:processor] = v end
    def sampleRate = self[:sampleRate]
    def sampleRate=(v) self[:sampleRate] = v end
    def sampleSize = self[:sampleSize]
    def sampleSize=(v) self[:sampleSize] = v end
    def channels = self[:channels]
    def channels=(v) self[:channels] = v end
  end

  # Sound
  class Sound < FFI::Struct
    layout(
      :stream, AudioStream, # Audio stream
      :frameCount, :uint,   # Total number of frames (considering channels)
    )
    def stream = self[:stream]
    def stream=(v) self[:stream] = v end
    def frameCount = self[:frameCount]
    def frameCount=(v) self[:frameCount] = v end
  end

  # Music, audio stream, anything longer than ~10 seconds should be streamed
  class Music < FFI::Struct
    layout(
      :stream, AudioStream, # Audio stream
      :frameCount, :uint,   # Total number of frames (considering channels)
      :looping, :bool,      # Music looping enable
      :ctxType, :int,       # Type of music context (audio filetype)
      :ctxData, :pointer,   # Audio context data, depends on type
    )
    def stream = self[:stream]
    def stream=(v) self[:stream] = v end
    def frameCount = self[:frameCount]
    def frameCount=(v) self[:frameCount] = v end
    def looping = self[:looping]
    def looping=(v) self[:looping] = v end
    def ctxType = self[:ctxType]
    def ctxType=(v) self[:ctxType] = v end
    def ctxData = self[:ctxData]
    def ctxData=(v) self[:ctxData] = v end
  end

  # VrDeviceInfo, Head-Mounted-Display device parameters
  class VrDeviceInfo < FFI::Struct
    layout(
      :hResolution, :int,                 # Horizontal resolution in pixels
      :vResolution, :int,                 # Vertical resolution in pixels
      :hScreenSize, :float,               # Horizontal size in meters
      :vScreenSize, :float,               # Vertical size in meters
      :eyeToScreenDistance, :float,       # Distance between eye and display in meters
      :lensSeparationDistance, :float,    # Lens separation distance in meters
      :interpupillaryDistance, :float,    # IPD (distance between pupils) in meters
      :lensDistortionValues, [:float, 4], # Lens distortion constant parameters
      :chromaAbCorrection, [:float, 4],   # Chromatic aberration correction parameters
    )
    def hResolution = self[:hResolution]
    def hResolution=(v) self[:hResolution] = v end
    def vResolution = self[:vResolution]
    def vResolution=(v) self[:vResolution] = v end
    def hScreenSize = self[:hScreenSize]
    def hScreenSize=(v) self[:hScreenSize] = v end
    def vScreenSize = self[:vScreenSize]
    def vScreenSize=(v) self[:vScreenSize] = v end
    def eyeToScreenDistance = self[:eyeToScreenDistance]
    def eyeToScreenDistance=(v) self[:eyeToScreenDistance] = v end
    def lensSeparationDistance = self[:lensSeparationDistance]
    def lensSeparationDistance=(v) self[:lensSeparationDistance] = v end
    def interpupillaryDistance = self[:interpupillaryDistance]
    def interpupillaryDistance=(v) self[:interpupillaryDistance] = v end
    def lensDistortionValues = self[:lensDistortionValues]
    def lensDistortionValues=(v) self[:lensDistortionValues] = v end
    def chromaAbCorrection = self[:chromaAbCorrection]
    def chromaAbCorrection=(v) self[:chromaAbCorrection] = v end
  end

  # VrStereoConfig, VR stereo rendering configuration for simulator
  class VrStereoConfig < FFI::Struct
    layout(
      :projection, [Matrix, 2],        # VR projection matrices (per eye)
      :viewOffset, [Matrix, 2],        # VR view offset matrices (per eye)
      :leftLensCenter, [:float, 2],    # VR left lens center
      :rightLensCenter, [:float, 2],   # VR right lens center
      :leftScreenCenter, [:float, 2],  # VR left screen center
      :rightScreenCenter, [:float, 2], # VR right screen center
      :scale, [:float, 2],             # VR distortion scale
      :scaleIn, [:float, 2],           # VR distortion scale in
    )
    def projection = self[:projection]
    def projection=(v) self[:projection] = v end
    def viewOffset = self[:viewOffset]
    def viewOffset=(v) self[:viewOffset] = v end
    def leftLensCenter = self[:leftLensCenter]
    def leftLensCenter=(v) self[:leftLensCenter] = v end
    def rightLensCenter = self[:rightLensCenter]
    def rightLensCenter=(v) self[:rightLensCenter] = v end
    def leftScreenCenter = self[:leftScreenCenter]
    def leftScreenCenter=(v) self[:leftScreenCenter] = v end
    def rightScreenCenter = self[:rightScreenCenter]
    def rightScreenCenter=(v) self[:rightScreenCenter] = v end
    def scale = self[:scale]
    def scale=(v) self[:scale] = v end
    def scaleIn = self[:scaleIn]
    def scaleIn=(v) self[:scaleIn] = v end
  end

  # File path list
  class FilePathList < FFI::Struct
    layout(
      :capacity, :uint, # Filepaths max entries
      :count, :uint,    # Filepaths entries count
      :paths, :pointer, # Filepaths entries
    )
    def capacity = self[:capacity]
    def capacity=(v) self[:capacity] = v end
    def count = self[:count]
    def count=(v) self[:count] = v end
    def paths = self[:paths]
    def paths=(v) self[:paths] = v end
  end

  # Automation event
  class AutomationEvent < FFI::Struct
    layout(
      :frame, :uint,      # Event frame
      :type, :uint,       # Event type (AutomationEventType)
      :params, [:int, 4], # Event parameters (if required)
    )
    def frame = self[:frame]
    def frame=(v) self[:frame] = v end
    def type = self[:type]
    def type=(v) self[:type] = v end
    def params = self[:params]
    def params=(v) self[:params] = v end
  end

  # Automation event list
  class AutomationEventList < FFI::Struct
    layout(
      :capacity, :uint,  # Events max entries (MAX_AUTOMATION_EVENTS)
      :count, :uint,     # Events entries count
      :events, :pointer, # Events entries
    )
    def capacity = self[:capacity]
    def capacity=(v) self[:capacity] = v end
    def count = self[:count]
    def count=(v) self[:count] = v end
    def events = self[:events]
    def events=(v) self[:events] = v end
  end


  # Function

  def self.setup_raylib_symbols(method_naming: :original)
    entries = [

      # @!method InitWindow(width, height, title)
      #   InitWindow : Initialize window and OpenGL context
      #   @param width [int]
      #   @param height [int]
      #   @param title [const char *]
      #   @return [void]
      [:InitWindow, :InitWindow, [:int, :int, :pointer], :void],

      # @!method CloseWindow()
      #   CloseWindow : Close window and unload OpenGL context
      #   @return [void]
      [:CloseWindow, :CloseWindow, [], :void],

      # @!method WindowShouldClose()
      #   WindowShouldClose : Check if application should close (KEY_ESCAPE pressed or windows close icon clicked)
      #   @return [bool]
      [:WindowShouldClose, :WindowShouldClose, [], :bool],

      # @!method IsWindowReady()
      #   IsWindowReady : Check if window has been initialized successfully
      #   @return [bool]
      [:IsWindowReady, :IsWindowReady, [], :bool],

      # @!method IsWindowFullscreen()
      #   IsWindowFullscreen : Check if window is currently fullscreen
      #   @return [bool]
      [:IsWindowFullscreen, :IsWindowFullscreen, [], :bool],

      # @!method IsWindowHidden()
      #   IsWindowHidden : Check if window is currently hidden
      #   @return [bool]
      [:IsWindowHidden, :IsWindowHidden, [], :bool],

      # @!method IsWindowMinimized()
      #   IsWindowMinimized : Check if window is currently minimized
      #   @return [bool]
      [:IsWindowMinimized, :IsWindowMinimized, [], :bool],

      # @!method IsWindowMaximized()
      #   IsWindowMaximized : Check if window is currently maximized
      #   @return [bool]
      [:IsWindowMaximized, :IsWindowMaximized, [], :bool],

      # @!method IsWindowFocused()
      #   IsWindowFocused : Check if window is currently focused
      #   @return [bool]
      [:IsWindowFocused, :IsWindowFocused, [], :bool],

      # @!method IsWindowResized()
      #   IsWindowResized : Check if window has been resized last frame
      #   @return [bool]
      [:IsWindowResized, :IsWindowResized, [], :bool],

      # @!method IsWindowState(flag)
      #   IsWindowState : Check if one specific window flag is enabled
      #   @param flag [unsigned int]
      #   @return [bool]
      [:IsWindowState, :IsWindowState, [:uint], :bool],

      # @!method SetWindowState(flags)
      #   SetWindowState : Set window configuration state using flags
      #   @param flags [unsigned int]
      #   @return [void]
      [:SetWindowState, :SetWindowState, [:uint], :void],

      # @!method ClearWindowState(flags)
      #   ClearWindowState : Clear window configuration state flags
      #   @param flags [unsigned int]
      #   @return [void]
      [:ClearWindowState, :ClearWindowState, [:uint], :void],

      # @!method ToggleFullscreen()
      #   ToggleFullscreen : Toggle window state: fullscreen/windowed, resizes monitor to match window resolution
      #   @return [void]
      [:ToggleFullscreen, :ToggleFullscreen, [], :void],

      # @!method ToggleBorderlessWindowed()
      #   ToggleBorderlessWindowed : Toggle window state: borderless windowed, resizes window to match monitor resolution
      #   @return [void]
      [:ToggleBorderlessWindowed, :ToggleBorderlessWindowed, [], :void],

      # @!method MaximizeWindow()
      #   MaximizeWindow : Set window state: maximized, if resizable
      #   @return [void]
      [:MaximizeWindow, :MaximizeWindow, [], :void],

      # @!method MinimizeWindow()
      #   MinimizeWindow : Set window state: minimized, if resizable
      #   @return [void]
      [:MinimizeWindow, :MinimizeWindow, [], :void],

      # @!method RestoreWindow()
      #   RestoreWindow : Restore window from being minimized/maximized
      #   @return [void]
      [:RestoreWindow, :RestoreWindow, [], :void],

      # @!method SetWindowIcon(image)
      #   SetWindowIcon : Set icon for window (single image, RGBA 32bit)
      #   @param image [Image]
      #   @return [void]
      [:SetWindowIcon, :SetWindowIcon, [Image.by_value], :void],

      # @!method SetWindowIcons(images, count)
      #   SetWindowIcons : Set icon for window (multiple images, RGBA 32bit)
      #   @param images [Image *]
      #   @param count [int]
      #   @return [void]
      [:SetWindowIcons, :SetWindowIcons, [:pointer, :int], :void],

      # @!method SetWindowTitle(title)
      #   SetWindowTitle : Set title for window
      #   @param title [const char *]
      #   @return [void]
      [:SetWindowTitle, :SetWindowTitle, [:pointer], :void],

      # @!method SetWindowPosition(x, y)
      #   SetWindowPosition : Set window position on screen
      #   @param x [int]
      #   @param y [int]
      #   @return [void]
      [:SetWindowPosition, :SetWindowPosition, [:int, :int], :void],

      # @!method SetWindowMonitor(monitor)
      #   SetWindowMonitor : Set monitor for the current window
      #   @param monitor [int]
      #   @return [void]
      [:SetWindowMonitor, :SetWindowMonitor, [:int], :void],

      # @!method SetWindowMinSize(width, height)
      #   SetWindowMinSize : Set window minimum dimensions (for FLAG_WINDOW_RESIZABLE)
      #   @param width [int]
      #   @param height [int]
      #   @return [void]
      [:SetWindowMinSize, :SetWindowMinSize, [:int, :int], :void],

      # @!method SetWindowMaxSize(width, height)
      #   SetWindowMaxSize : Set window maximum dimensions (for FLAG_WINDOW_RESIZABLE)
      #   @param width [int]
      #   @param height [int]
      #   @return [void]
      [:SetWindowMaxSize, :SetWindowMaxSize, [:int, :int], :void],

      # @!method SetWindowSize(width, height)
      #   SetWindowSize : Set window dimensions
      #   @param width [int]
      #   @param height [int]
      #   @return [void]
      [:SetWindowSize, :SetWindowSize, [:int, :int], :void],

      # @!method SetWindowOpacity(opacity)
      #   SetWindowOpacity : Set window opacity [0.0f..1.0f]
      #   @param opacity [float]
      #   @return [void]
      [:SetWindowOpacity, :SetWindowOpacity, [:float], :void],

      # @!method SetWindowFocused()
      #   SetWindowFocused : Set window focused
      #   @return [void]
      [:SetWindowFocused, :SetWindowFocused, [], :void],

      # @!method GetWindowHandle()
      #   GetWindowHandle : Get native window handle
      #   @return [void *]
      [:GetWindowHandle, :GetWindowHandle, [], :pointer],

      # @!method GetScreenWidth()
      #   GetScreenWidth : Get current screen width
      #   @return [int]
      [:GetScreenWidth, :GetScreenWidth, [], :int],

      # @!method GetScreenHeight()
      #   GetScreenHeight : Get current screen height
      #   @return [int]
      [:GetScreenHeight, :GetScreenHeight, [], :int],

      # @!method GetRenderWidth()
      #   GetRenderWidth : Get current render width (it considers HiDPI)
      #   @return [int]
      [:GetRenderWidth, :GetRenderWidth, [], :int],

      # @!method GetRenderHeight()
      #   GetRenderHeight : Get current render height (it considers HiDPI)
      #   @return [int]
      [:GetRenderHeight, :GetRenderHeight, [], :int],

      # @!method GetMonitorCount()
      #   GetMonitorCount : Get number of connected monitors
      #   @return [int]
      [:GetMonitorCount, :GetMonitorCount, [], :int],

      # @!method GetCurrentMonitor()
      #   GetCurrentMonitor : Get current monitor where window is placed
      #   @return [int]
      [:GetCurrentMonitor, :GetCurrentMonitor, [], :int],

      # @!method GetMonitorPosition(monitor)
      #   GetMonitorPosition : Get specified monitor position
      #   @param monitor [int]
      #   @return [Vector2]
      [:GetMonitorPosition, :GetMonitorPosition, [:int], Vector2.by_value],

      # @!method GetMonitorWidth(monitor)
      #   GetMonitorWidth : Get specified monitor width (current video mode used by monitor)
      #   @param monitor [int]
      #   @return [int]
      [:GetMonitorWidth, :GetMonitorWidth, [:int], :int],

      # @!method GetMonitorHeight(monitor)
      #   GetMonitorHeight : Get specified monitor height (current video mode used by monitor)
      #   @param monitor [int]
      #   @return [int]
      [:GetMonitorHeight, :GetMonitorHeight, [:int], :int],

      # @!method GetMonitorPhysicalWidth(monitor)
      #   GetMonitorPhysicalWidth : Get specified monitor physical width in millimetres
      #   @param monitor [int]
      #   @return [int]
      [:GetMonitorPhysicalWidth, :GetMonitorPhysicalWidth, [:int], :int],

      # @!method GetMonitorPhysicalHeight(monitor)
      #   GetMonitorPhysicalHeight : Get specified monitor physical height in millimetres
      #   @param monitor [int]
      #   @return [int]
      [:GetMonitorPhysicalHeight, :GetMonitorPhysicalHeight, [:int], :int],

      # @!method GetMonitorRefreshRate(monitor)
      #   GetMonitorRefreshRate : Get specified monitor refresh rate
      #   @param monitor [int]
      #   @return [int]
      [:GetMonitorRefreshRate, :GetMonitorRefreshRate, [:int], :int],

      # @!method GetWindowPosition()
      #   GetWindowPosition : Get window position XY on monitor
      #   @return [Vector2]
      [:GetWindowPosition, :GetWindowPosition, [], Vector2.by_value],

      # @!method GetWindowScaleDPI()
      #   GetWindowScaleDPI : Get window scale DPI factor
      #   @return [Vector2]
      [:GetWindowScaleDPI, :GetWindowScaleDPI, [], Vector2.by_value],

      # @!method GetMonitorName(monitor)
      #   GetMonitorName : Get the human-readable, UTF-8 encoded name of the specified monitor
      #   @param monitor [int]
      #   @return [const char *]
      [:GetMonitorName, :GetMonitorName, [:int], :pointer],

      # @!method SetClipboardText(text)
      #   SetClipboardText : Set clipboard text content
      #   @param text [const char *]
      #   @return [void]
      [:SetClipboardText, :SetClipboardText, [:pointer], :void],

      # @!method GetClipboardText()
      #   GetClipboardText : Get clipboard text content
      #   @return [const char *]
      [:GetClipboardText, :GetClipboardText, [], :pointer],

      # @!method GetClipboardImage()
      #   GetClipboardImage : Get clipboard image content
      #   @return [Image]
      [:GetClipboardImage, :GetClipboardImage, [], Image.by_value],

      # @!method EnableEventWaiting()
      #   EnableEventWaiting : Enable waiting for events on EndDrawing(), no automatic event polling
      #   @return [void]
      [:EnableEventWaiting, :EnableEventWaiting, [], :void],

      # @!method DisableEventWaiting()
      #   DisableEventWaiting : Disable waiting for events on EndDrawing(), automatic events polling
      #   @return [void]
      [:DisableEventWaiting, :DisableEventWaiting, [], :void],

      # @!method ShowCursor()
      #   ShowCursor : Shows cursor
      #   @return [void]
      [:ShowCursor, :ShowCursor, [], :void],

      # @!method HideCursor()
      #   HideCursor : Hides cursor
      #   @return [void]
      [:HideCursor, :HideCursor, [], :void],

      # @!method IsCursorHidden()
      #   IsCursorHidden : Check if cursor is not visible
      #   @return [bool]
      [:IsCursorHidden, :IsCursorHidden, [], :bool],

      # @!method EnableCursor()
      #   EnableCursor : Enables cursor (unlock cursor)
      #   @return [void]
      [:EnableCursor, :EnableCursor, [], :void],

      # @!method DisableCursor()
      #   DisableCursor : Disables cursor (lock cursor)
      #   @return [void]
      [:DisableCursor, :DisableCursor, [], :void],

      # @!method IsCursorOnScreen()
      #   IsCursorOnScreen : Check if cursor is on the screen
      #   @return [bool]
      [:IsCursorOnScreen, :IsCursorOnScreen, [], :bool],

      # @!method ClearBackground(color)
      #   ClearBackground : Set background color (framebuffer clear color)
      #   @param color [Color]
      #   @return [void]
      [:ClearBackground, :ClearBackground, [Color.by_value], :void],

      # @!method BeginDrawing()
      #   BeginDrawing : Setup canvas (framebuffer) to start drawing
      #   @return [void]
      [:BeginDrawing, :BeginDrawing, [], :void],

      # @!method EndDrawing()
      #   EndDrawing : End canvas drawing and swap buffers (double buffering)
      #   @return [void]
      [:EndDrawing, :EndDrawing, [], :void],

      # @!method BeginMode2D(camera)
      #   BeginMode2D : Begin 2D mode with custom camera (2D)
      #   @param camera [Camera2D]
      #   @return [void]
      [:BeginMode2D, :BeginMode2D, [Camera2D.by_value], :void],

      # @!method EndMode2D()
      #   EndMode2D : Ends 2D mode with custom camera
      #   @return [void]
      [:EndMode2D, :EndMode2D, [], :void],

      # @!method BeginMode3D(camera)
      #   BeginMode3D : Begin 3D mode with custom camera (3D)
      #   @param camera [Camera3D]
      #   @return [void]
      [:BeginMode3D, :BeginMode3D, [Camera3D.by_value], :void],

      # @!method EndMode3D()
      #   EndMode3D : Ends 3D mode and returns to default 2D orthographic mode
      #   @return [void]
      [:EndMode3D, :EndMode3D, [], :void],

      # @!method BeginTextureMode(target)
      #   BeginTextureMode : Begin drawing to render texture
      #   @param target [RenderTexture2D]
      #   @return [void]
      [:BeginTextureMode, :BeginTextureMode, [RenderTexture2D.by_value], :void],

      # @!method EndTextureMode()
      #   EndTextureMode : Ends drawing to render texture
      #   @return [void]
      [:EndTextureMode, :EndTextureMode, [], :void],

      # @!method BeginShaderMode(shader)
      #   BeginShaderMode : Begin custom shader drawing
      #   @param shader [Shader]
      #   @return [void]
      [:BeginShaderMode, :BeginShaderMode, [Shader.by_value], :void],

      # @!method EndShaderMode()
      #   EndShaderMode : End custom shader drawing (use default shader)
      #   @return [void]
      [:EndShaderMode, :EndShaderMode, [], :void],

      # @!method BeginBlendMode(mode)
      #   BeginBlendMode : Begin blending mode (alpha, additive, multiplied, subtract, custom)
      #   @param mode [int]
      #   @return [void]
      [:BeginBlendMode, :BeginBlendMode, [:int], :void],

      # @!method EndBlendMode()
      #   EndBlendMode : End blending mode (reset to default: alpha blending)
      #   @return [void]
      [:EndBlendMode, :EndBlendMode, [], :void],

      # @!method BeginScissorMode(x, y, width, height)
      #   BeginScissorMode : Begin scissor mode (define screen area for following drawing)
      #   @param x [int]
      #   @param y [int]
      #   @param width [int]
      #   @param height [int]
      #   @return [void]
      [:BeginScissorMode, :BeginScissorMode, [:int, :int, :int, :int], :void],

      # @!method EndScissorMode()
      #   EndScissorMode : End scissor mode
      #   @return [void]
      [:EndScissorMode, :EndScissorMode, [], :void],

      # @!method BeginVrStereoMode(config)
      #   BeginVrStereoMode : Begin stereo rendering (requires VR simulator)
      #   @param config [VrStereoConfig]
      #   @return [void]
      [:BeginVrStereoMode, :BeginVrStereoMode, [VrStereoConfig.by_value], :void],

      # @!method EndVrStereoMode()
      #   EndVrStereoMode : End stereo rendering (requires VR simulator)
      #   @return [void]
      [:EndVrStereoMode, :EndVrStereoMode, [], :void],

      # @!method LoadVrStereoConfig(device)
      #   LoadVrStereoConfig : Load VR stereo config for VR simulator device parameters
      #   @param device [VrDeviceInfo]
      #   @return [VrStereoConfig]
      [:LoadVrStereoConfig, :LoadVrStereoConfig, [VrDeviceInfo.by_value], VrStereoConfig.by_value],

      # @!method UnloadVrStereoConfig(config)
      #   UnloadVrStereoConfig : Unload VR stereo config
      #   @param config [VrStereoConfig]
      #   @return [void]
      [:UnloadVrStereoConfig, :UnloadVrStereoConfig, [VrStereoConfig.by_value], :void],

      # @!method LoadShader(vsFileName, fsFileName)
      #   LoadShader : Load shader from files and bind default locations
      #   @param vsFileName [const char *]
      #   @param fsFileName [const char *]
      #   @return [Shader]
      [:LoadShader, :LoadShader, [:pointer, :pointer], Shader.by_value],

      # @!method LoadShaderFromMemory(vsCode, fsCode)
      #   LoadShaderFromMemory : Load shader from code strings and bind default locations
      #   @param vsCode [const char *]
      #   @param fsCode [const char *]
      #   @return [Shader]
      [:LoadShaderFromMemory, :LoadShaderFromMemory, [:pointer, :pointer], Shader.by_value],

      # @!method IsShaderValid(shader)
      #   IsShaderValid : Check if a shader is valid (loaded on GPU)
      #   @param shader [Shader]
      #   @return [bool]
      [:IsShaderValid, :IsShaderValid, [Shader.by_value], :bool],

      # @!method GetShaderLocation(shader, uniformName)
      #   GetShaderLocation : Get shader uniform location
      #   @param shader [Shader]
      #   @param uniformName [const char *]
      #   @return [int]
      [:GetShaderLocation, :GetShaderLocation, [Shader.by_value, :pointer], :int],

      # @!method GetShaderLocationAttrib(shader, attribName)
      #   GetShaderLocationAttrib : Get shader attribute location
      #   @param shader [Shader]
      #   @param attribName [const char *]
      #   @return [int]
      [:GetShaderLocationAttrib, :GetShaderLocationAttrib, [Shader.by_value, :pointer], :int],

      # @!method SetShaderValue(shader, locIndex, value, uniformType)
      #   SetShaderValue : Set shader uniform value
      #   @param shader [Shader]
      #   @param locIndex [int]
      #   @param value [const void *]
      #   @param uniformType [int]
      #   @return [void]
      [:SetShaderValue, :SetShaderValue, [Shader.by_value, :int, :pointer, :int], :void],

      # @!method SetShaderValueV(shader, locIndex, value, uniformType, count)
      #   SetShaderValueV : Set shader uniform value vector
      #   @param shader [Shader]
      #   @param locIndex [int]
      #   @param value [const void *]
      #   @param uniformType [int]
      #   @param count [int]
      #   @return [void]
      [:SetShaderValueV, :SetShaderValueV, [Shader.by_value, :int, :pointer, :int, :int], :void],

      # @!method SetShaderValueMatrix(shader, locIndex, mat)
      #   SetShaderValueMatrix : Set shader uniform value (matrix 4x4)
      #   @param shader [Shader]
      #   @param locIndex [int]
      #   @param mat [Matrix]
      #   @return [void]
      [:SetShaderValueMatrix, :SetShaderValueMatrix, [Shader.by_value, :int, Matrix.by_value], :void],

      # @!method SetShaderValueTexture(shader, locIndex, texture)
      #   SetShaderValueTexture : Set shader uniform value and bind the texture (sampler2d)
      #   @param shader [Shader]
      #   @param locIndex [int]
      #   @param texture [Texture2D]
      #   @return [void]
      [:SetShaderValueTexture, :SetShaderValueTexture, [Shader.by_value, :int, Texture2D.by_value], :void],

      # @!method UnloadShader(shader)
      #   UnloadShader : Unload shader from GPU memory (VRAM)
      #   @param shader [Shader]
      #   @return [void]
      [:UnloadShader, :UnloadShader, [Shader.by_value], :void],

      # @!method GetScreenToWorldRay(position, camera)
      #   GetScreenToWorldRay : Get a ray trace from screen position (i.e mouse)
      #   @param position [Vector2]
      #   @param camera [Camera]
      #   @return [Ray]
      [:GetScreenToWorldRay, :GetScreenToWorldRay, [Vector2.by_value, Camera.by_value], Ray.by_value],

      # @!method GetScreenToWorldRayEx(position, camera, width, height)
      #   GetScreenToWorldRayEx : Get a ray trace from screen position (i.e mouse) in a viewport
      #   @param position [Vector2]
      #   @param camera [Camera]
      #   @param width [int]
      #   @param height [int]
      #   @return [Ray]
      [:GetScreenToWorldRayEx, :GetScreenToWorldRayEx, [Vector2.by_value, Camera.by_value, :int, :int], Ray.by_value],

      # @!method GetWorldToScreen(position, camera)
      #   GetWorldToScreen : Get the screen space position for a 3d world space position
      #   @param position [Vector3]
      #   @param camera [Camera]
      #   @return [Vector2]
      [:GetWorldToScreen, :GetWorldToScreen, [Vector3.by_value, Camera.by_value], Vector2.by_value],

      # @!method GetWorldToScreenEx(position, camera, width, height)
      #   GetWorldToScreenEx : Get size position for a 3d world space position
      #   @param position [Vector3]
      #   @param camera [Camera]
      #   @param width [int]
      #   @param height [int]
      #   @return [Vector2]
      [:GetWorldToScreenEx, :GetWorldToScreenEx, [Vector3.by_value, Camera.by_value, :int, :int], Vector2.by_value],

      # @!method GetWorldToScreen2D(position, camera)
      #   GetWorldToScreen2D : Get the screen space position for a 2d camera world space position
      #   @param position [Vector2]
      #   @param camera [Camera2D]
      #   @return [Vector2]
      [:GetWorldToScreen2D, :GetWorldToScreen2D, [Vector2.by_value, Camera2D.by_value], Vector2.by_value],

      # @!method GetScreenToWorld2D(position, camera)
      #   GetScreenToWorld2D : Get the world space position for a 2d camera screen space position
      #   @param position [Vector2]
      #   @param camera [Camera2D]
      #   @return [Vector2]
      [:GetScreenToWorld2D, :GetScreenToWorld2D, [Vector2.by_value, Camera2D.by_value], Vector2.by_value],

      # @!method GetCameraMatrix(camera)
      #   GetCameraMatrix : Get camera transform matrix (view matrix)
      #   @param camera [Camera]
      #   @return [Matrix]
      [:GetCameraMatrix, :GetCameraMatrix, [Camera.by_value], Matrix.by_value],

      # @!method GetCameraMatrix2D(camera)
      #   GetCameraMatrix2D : Get camera 2d transform matrix
      #   @param camera [Camera2D]
      #   @return [Matrix]
      [:GetCameraMatrix2D, :GetCameraMatrix2D, [Camera2D.by_value], Matrix.by_value],

      # @!method SetTargetFPS(fps)
      #   SetTargetFPS : Set target FPS (maximum)
      #   @param fps [int]
      #   @return [void]
      [:SetTargetFPS, :SetTargetFPS, [:int], :void],

      # @!method GetFrameTime()
      #   GetFrameTime : Get time in seconds for last frame drawn (delta time)
      #   @return [float]
      [:GetFrameTime, :GetFrameTime, [], :float],

      # @!method GetTime()
      #   GetTime : Get elapsed time in seconds since InitWindow()
      #   @return [double]
      [:GetTime, :GetTime, [], :double],

      # @!method GetFPS()
      #   GetFPS : Get current FPS
      #   @return [int]
      [:GetFPS, :GetFPS, [], :int],

      # @!method SwapScreenBuffer()
      #   SwapScreenBuffer : Swap back buffer with front buffer (screen drawing)
      #   @return [void]
      [:SwapScreenBuffer, :SwapScreenBuffer, [], :void],

      # @!method PollInputEvents()
      #   PollInputEvents : Register all input events
      #   @return [void]
      [:PollInputEvents, :PollInputEvents, [], :void],

      # @!method WaitTime(seconds)
      #   WaitTime : Wait for some time (halt program execution)
      #   @param seconds [double]
      #   @return [void]
      [:WaitTime, :WaitTime, [:double], :void],

      # @!method SetRandomSeed(seed)
      #   SetRandomSeed : Set the seed for the random number generator
      #   @param seed [unsigned int]
      #   @return [void]
      [:SetRandomSeed, :SetRandomSeed, [:uint], :void],

      # @!method GetRandomValue(min, max)
      #   GetRandomValue : Get a random value between min and max (both included)
      #   @param min [int]
      #   @param max [int]
      #   @return [int]
      [:GetRandomValue, :GetRandomValue, [:int, :int], :int],

      # @!method LoadRandomSequence(count, min, max)
      #   LoadRandomSequence : Load random values sequence, no values repeated
      #   @param count [unsigned int]
      #   @param min [int]
      #   @param max [int]
      #   @return [int *]
      [:LoadRandomSequence, :LoadRandomSequence, [:uint, :int, :int], :pointer],

      # @!method UnloadRandomSequence(sequence)
      #   UnloadRandomSequence : Unload random values sequence
      #   @param sequence [int *]
      #   @return [void]
      [:UnloadRandomSequence, :UnloadRandomSequence, [:pointer], :void],

      # @!method TakeScreenshot(fileName)
      #   TakeScreenshot : Takes a screenshot of current screen (filename extension defines format)
      #   @param fileName [const char *]
      #   @return [void]
      [:TakeScreenshot, :TakeScreenshot, [:pointer], :void],

      # @!method SetConfigFlags(flags)
      #   SetConfigFlags : Setup init configuration flags (view FLAGS)
      #   @param flags [unsigned int]
      #   @return [void]
      [:SetConfigFlags, :SetConfigFlags, [:uint], :void],

      # @!method OpenURL(url)
      #   OpenURL : Open URL with default system browser (if available)
      #   @param url [const char *]
      #   @return [void]
      [:OpenURL, :OpenURL, [:pointer], :void],

      # @!method TraceLog(logLevel, text, ...)
      #   TraceLog : Show trace log messages (LOG_DEBUG, LOG_INFO, LOG_WARNING, LOG_ERROR...)
      #   @param logLevel [int]
      #   @param text [const char *]
      #   @param args [...]
      #   @return [void]
      [:TraceLog, :TraceLog, [:int, :pointer, :varargs], :void],

      # @!method SetTraceLogLevel(logLevel)
      #   SetTraceLogLevel : Set the current threshold (minimum) log level
      #   @param logLevel [int]
      #   @return [void]
      [:SetTraceLogLevel, :SetTraceLogLevel, [:int], :void],

      # @!method MemAlloc(size)
      #   MemAlloc : Internal memory allocator
      #   @param size [unsigned int]
      #   @return [void *]
      [:MemAlloc, :MemAlloc, [:uint], :pointer],

      # @!method MemRealloc(ptr, size)
      #   MemRealloc : Internal memory reallocator
      #   @param ptr [void *]
      #   @param size [unsigned int]
      #   @return [void *]
      [:MemRealloc, :MemRealloc, [:pointer, :uint], :pointer],

      # @!method MemFree(ptr)
      #   MemFree : Internal memory free
      #   @param ptr [void *]
      #   @return [void]
      [:MemFree, :MemFree, [:pointer], :void],

      # @!method SetTraceLogCallback(callback)
      #   SetTraceLogCallback : Set custom trace log
      #   @param callback [TraceLogCallback]
      #   @return [void]
      [:SetTraceLogCallback, :SetTraceLogCallback, [:TraceLogCallback], :void],

      # @!method SetLoadFileDataCallback(callback)
      #   SetLoadFileDataCallback : Set custom file binary data loader
      #   @param callback [LoadFileDataCallback]
      #   @return [void]
      [:SetLoadFileDataCallback, :SetLoadFileDataCallback, [:LoadFileDataCallback], :void],

      # @!method SetSaveFileDataCallback(callback)
      #   SetSaveFileDataCallback : Set custom file binary data saver
      #   @param callback [SaveFileDataCallback]
      #   @return [void]
      [:SetSaveFileDataCallback, :SetSaveFileDataCallback, [:SaveFileDataCallback], :void],

      # @!method SetLoadFileTextCallback(callback)
      #   SetLoadFileTextCallback : Set custom file text data loader
      #   @param callback [LoadFileTextCallback]
      #   @return [void]
      [:SetLoadFileTextCallback, :SetLoadFileTextCallback, [:LoadFileTextCallback], :void],

      # @!method SetSaveFileTextCallback(callback)
      #   SetSaveFileTextCallback : Set custom file text data saver
      #   @param callback [SaveFileTextCallback]
      #   @return [void]
      [:SetSaveFileTextCallback, :SetSaveFileTextCallback, [:SaveFileTextCallback], :void],

      # @!method LoadFileData(fileName, dataSize)
      #   LoadFileData : Load file data as byte array (read)
      #   @param fileName [const char *]
      #   @param dataSize [int *]
      #   @return [unsigned char *]
      [:LoadFileData, :LoadFileData, [:pointer, :pointer], :pointer],

      # @!method UnloadFileData(data)
      #   UnloadFileData : Unload file data allocated by LoadFileData()
      #   @param data [unsigned char *]
      #   @return [void]
      [:UnloadFileData, :UnloadFileData, [:pointer], :void],

      # @!method SaveFileData(fileName, data, dataSize)
      #   SaveFileData : Save data to file from byte array (write), returns true on success
      #   @param fileName [const char *]
      #   @param data [void *]
      #   @param dataSize [int]
      #   @return [bool]
      [:SaveFileData, :SaveFileData, [:pointer, :pointer, :int], :bool],

      # @!method ExportDataAsCode(data, dataSize, fileName)
      #   ExportDataAsCode : Export data to code (.h), returns true on success
      #   @param data [const unsigned char *]
      #   @param dataSize [int]
      #   @param fileName [const char *]
      #   @return [bool]
      [:ExportDataAsCode, :ExportDataAsCode, [:pointer, :int, :pointer], :bool],

      # @!method LoadFileText(fileName)
      #   LoadFileText : Load text data from file (read), returns a '\0' terminated string
      #   @param fileName [const char *]
      #   @return [char *]
      [:LoadFileText, :LoadFileText, [:pointer], :pointer],

      # @!method UnloadFileText(text)
      #   UnloadFileText : Unload file text data allocated by LoadFileText()
      #   @param text [char *]
      #   @return [void]
      [:UnloadFileText, :UnloadFileText, [:pointer], :void],

      # @!method SaveFileText(fileName, text)
      #   SaveFileText : Save text data to file (write), string must be '\0' terminated, returns true on success
      #   @param fileName [const char *]
      #   @param text [const char *]
      #   @return [bool]
      [:SaveFileText, :SaveFileText, [:pointer, :pointer], :bool],

      # @!method FileRename(fileName, fileRename)
      #   FileRename : Rename file (if exists)
      #   @param fileName [const char *]
      #   @param fileRename [const char *]
      #   @return [int]
      [:FileRename, :FileRename, [:pointer, :pointer], :int],

      # @!method FileRemove(fileName)
      #   FileRemove : Remove file (if exists)
      #   @param fileName [const char *]
      #   @return [int]
      [:FileRemove, :FileRemove, [:pointer], :int],

      # @!method FileCopy(srcPath, dstPath)
      #   FileCopy : Copy file from one path to another, dstPath created if it doesn't exist
      #   @param srcPath [const char *]
      #   @param dstPath [const char *]
      #   @return [int]
      [:FileCopy, :FileCopy, [:pointer, :pointer], :int],

      # @!method FileMove(srcPath, dstPath)
      #   FileMove : Move file from one directory to another, dstPath created if it doesn't exist
      #   @param srcPath [const char *]
      #   @param dstPath [const char *]
      #   @return [int]
      [:FileMove, :FileMove, [:pointer, :pointer], :int],

      # @!method FileTextReplace(fileName, search, replacement)
      #   FileTextReplace : Replace text in an existing file
      #   @param fileName [const char *]
      #   @param search [const char *]
      #   @param replacement [const char *]
      #   @return [int]
      [:FileTextReplace, :FileTextReplace, [:pointer, :pointer, :pointer], :int],

      # @!method FileTextFindIndex(fileName, search)
      #   FileTextFindIndex : Find text in existing file
      #   @param fileName [const char *]
      #   @param search [const char *]
      #   @return [int]
      [:FileTextFindIndex, :FileTextFindIndex, [:pointer, :pointer], :int],

      # @!method FileExists(fileName)
      #   FileExists : Check if file exists
      #   @param fileName [const char *]
      #   @return [bool]
      [:FileExists, :FileExists, [:pointer], :bool],

      # @!method DirectoryExists(dirPath)
      #   DirectoryExists : Check if a directory path exists
      #   @param dirPath [const char *]
      #   @return [bool]
      [:DirectoryExists, :DirectoryExists, [:pointer], :bool],

      # @!method IsFileExtension(fileName, ext)
      #   IsFileExtension : Check file extension (recommended include point: .png, .wav)
      #   @param fileName [const char *]
      #   @param ext [const char *]
      #   @return [bool]
      [:IsFileExtension, :IsFileExtension, [:pointer, :pointer], :bool],

      # @!method GetFileLength(fileName)
      #   GetFileLength : Get file length in bytes (NOTE: GetFileSize() conflicts with windows.h)
      #   @param fileName [const char *]
      #   @return [int]
      [:GetFileLength, :GetFileLength, [:pointer], :int],

      # @!method GetFileModTime(fileName)
      #   GetFileModTime : Get file modification time (last write time)
      #   @param fileName [const char *]
      #   @return [long]
      [:GetFileModTime, :GetFileModTime, [:pointer], :long],

      # @!method GetFileExtension(fileName)
      #   GetFileExtension : Get pointer to extension for a filename string (includes dot: '.png')
      #   @param fileName [const char *]
      #   @return [const char *]
      [:GetFileExtension, :GetFileExtension, [:pointer], :pointer],

      # @!method GetFileName(filePath)
      #   GetFileName : Get pointer to filename for a path string
      #   @param filePath [const char *]
      #   @return [const char *]
      [:GetFileName, :GetFileName, [:pointer], :pointer],

      # @!method GetFileNameWithoutExt(filePath)
      #   GetFileNameWithoutExt : Get filename string without extension (uses static string)
      #   @param filePath [const char *]
      #   @return [const char *]
      [:GetFileNameWithoutExt, :GetFileNameWithoutExt, [:pointer], :pointer],

      # @!method GetDirectoryPath(filePath)
      #   GetDirectoryPath : Get full path for a given fileName with path (uses static string)
      #   @param filePath [const char *]
      #   @return [const char *]
      [:GetDirectoryPath, :GetDirectoryPath, [:pointer], :pointer],

      # @!method GetPrevDirectoryPath(dirPath)
      #   GetPrevDirectoryPath : Get previous directory path for a given path (uses static string)
      #   @param dirPath [const char *]
      #   @return [const char *]
      [:GetPrevDirectoryPath, :GetPrevDirectoryPath, [:pointer], :pointer],

      # @!method GetWorkingDirectory()
      #   GetWorkingDirectory : Get current working directory (uses static string)
      #   @return [const char *]
      [:GetWorkingDirectory, :GetWorkingDirectory, [], :pointer],

      # @!method GetApplicationDirectory()
      #   GetApplicationDirectory : Get the directory of the running application (uses static string)
      #   @return [const char *]
      [:GetApplicationDirectory, :GetApplicationDirectory, [], :pointer],

      # @!method MakeDirectory(dirPath)
      #   MakeDirectory : Create directories (including full path requested), returns 0 on success
      #   @param dirPath [const char *]
      #   @return [int]
      [:MakeDirectory, :MakeDirectory, [:pointer], :int],

      # @!method ChangeDirectory(dir)
      #   ChangeDirectory : Change working directory, return true on success
      #   @param dir [const char *]
      #   @return [bool]
      [:ChangeDirectory, :ChangeDirectory, [:pointer], :bool],

      # @!method IsPathFile(path)
      #   IsPathFile : Check if a given path is a file or a directory
      #   @param path [const char *]
      #   @return [bool]
      [:IsPathFile, :IsPathFile, [:pointer], :bool],

      # @!method IsFileNameValid(fileName)
      #   IsFileNameValid : Check if fileName is valid for the platform/OS
      #   @param fileName [const char *]
      #   @return [bool]
      [:IsFileNameValid, :IsFileNameValid, [:pointer], :bool],

      # @!method LoadDirectoryFiles(dirPath)
      #   LoadDirectoryFiles : Load directory filepaths
      #   @param dirPath [const char *]
      #   @return [FilePathList]
      [:LoadDirectoryFiles, :LoadDirectoryFiles, [:pointer], FilePathList.by_value],

      # @!method LoadDirectoryFilesEx(basePath, filter, scanSubdirs)
      #   LoadDirectoryFilesEx : Load directory filepaths with extension filtering and recursive directory scan. Use 'DIR' in the filter string to include directories in the result
      #   @param basePath [const char *]
      #   @param filter [const char *]
      #   @param scanSubdirs [bool]
      #   @return [FilePathList]
      [:LoadDirectoryFilesEx, :LoadDirectoryFilesEx, [:pointer, :pointer, :bool], FilePathList.by_value],

      # @!method UnloadDirectoryFiles(files)
      #   UnloadDirectoryFiles : Unload filepaths
      #   @param files [FilePathList]
      #   @return [void]
      [:UnloadDirectoryFiles, :UnloadDirectoryFiles, [FilePathList.by_value], :void],

      # @!method IsFileDropped()
      #   IsFileDropped : Check if a file has been dropped into window
      #   @return [bool]
      [:IsFileDropped, :IsFileDropped, [], :bool],

      # @!method LoadDroppedFiles()
      #   LoadDroppedFiles : Load dropped filepaths
      #   @return [FilePathList]
      [:LoadDroppedFiles, :LoadDroppedFiles, [], FilePathList.by_value],

      # @!method UnloadDroppedFiles(files)
      #   UnloadDroppedFiles : Unload dropped filepaths
      #   @param files [FilePathList]
      #   @return [void]
      [:UnloadDroppedFiles, :UnloadDroppedFiles, [FilePathList.by_value], :void],

      # @!method CompressData(data, dataSize, compDataSize)
      #   CompressData : Compress data (DEFLATE algorithm), memory must be MemFree()
      #   @param data [const unsigned char *]
      #   @param dataSize [int]
      #   @param compDataSize [int *]
      #   @return [unsigned char *]
      [:CompressData, :CompressData, [:pointer, :int, :pointer], :pointer],

      # @!method DecompressData(compData, compDataSize, dataSize)
      #   DecompressData : Decompress data (DEFLATE algorithm), memory must be MemFree()
      #   @param compData [const unsigned char *]
      #   @param compDataSize [int]
      #   @param dataSize [int *]
      #   @return [unsigned char *]
      [:DecompressData, :DecompressData, [:pointer, :int, :pointer], :pointer],

      # @!method EncodeDataBase64(data, dataSize, outputSize)
      #   EncodeDataBase64 : Encode data to Base64 string (includes NULL terminator), memory must be MemFree()
      #   @param data [const unsigned char *]
      #   @param dataSize [int]
      #   @param outputSize [int *]
      #   @return [char *]
      [:EncodeDataBase64, :EncodeDataBase64, [:pointer, :int, :pointer], :pointer],

      # @!method DecodeDataBase64(text, outputSize)
      #   DecodeDataBase64 : Decode Base64 string (expected NULL terminated), memory must be MemFree()
      #   @param text [const char *]
      #   @param outputSize [int *]
      #   @return [unsigned char *]
      [:DecodeDataBase64, :DecodeDataBase64, [:pointer, :pointer], :pointer],

      # @!method ComputeCRC32(data, dataSize)
      #   ComputeCRC32 : Compute CRC32 hash code
      #   @param data [unsigned char *]
      #   @param dataSize [int]
      #   @return [unsigned int]
      [:ComputeCRC32, :ComputeCRC32, [:pointer, :int], :uint],

      # @!method ComputeMD5(data, dataSize)
      #   ComputeMD5 : Compute MD5 hash code, returns static int[4] (16 bytes)
      #   @param data [unsigned char *]
      #   @param dataSize [int]
      #   @return [unsigned int *]
      [:ComputeMD5, :ComputeMD5, [:pointer, :int], :pointer],

      # @!method ComputeSHA1(data, dataSize)
      #   ComputeSHA1 : Compute SHA1 hash code, returns static int[5] (20 bytes)
      #   @param data [unsigned char *]
      #   @param dataSize [int]
      #   @return [unsigned int *]
      [:ComputeSHA1, :ComputeSHA1, [:pointer, :int], :pointer],

      # @!method ComputeSHA256(data, dataSize)
      #   ComputeSHA256 : Compute SHA256 hash code, returns static int[8] (32 bytes)
      #   @param data [unsigned char *]
      #   @param dataSize [int]
      #   @return [unsigned int *]
      [:ComputeSHA256, :ComputeSHA256, [:pointer, :int], :pointer],

      # @!method LoadAutomationEventList(fileName)
      #   LoadAutomationEventList : Load automation events list from file, NULL for empty list, capacity = MAX_AUTOMATION_EVENTS
      #   @param fileName [const char *]
      #   @return [AutomationEventList]
      [:LoadAutomationEventList, :LoadAutomationEventList, [:pointer], AutomationEventList.by_value],

      # @!method UnloadAutomationEventList(list)
      #   UnloadAutomationEventList : Unload automation events list from file
      #   @param list [AutomationEventList]
      #   @return [void]
      [:UnloadAutomationEventList, :UnloadAutomationEventList, [AutomationEventList.by_value], :void],

      # @!method ExportAutomationEventList(list, fileName)
      #   ExportAutomationEventList : Export automation events list as text file
      #   @param list [AutomationEventList]
      #   @param fileName [const char *]
      #   @return [bool]
      [:ExportAutomationEventList, :ExportAutomationEventList, [AutomationEventList.by_value, :pointer], :bool],

      # @!method SetAutomationEventList(list)
      #   SetAutomationEventList : Set automation event list to record to
      #   @param list [AutomationEventList *]
      #   @return [void]
      [:SetAutomationEventList, :SetAutomationEventList, [:pointer], :void],

      # @!method SetAutomationEventBaseFrame(frame)
      #   SetAutomationEventBaseFrame : Set automation event internal base frame to start recording
      #   @param frame [int]
      #   @return [void]
      [:SetAutomationEventBaseFrame, :SetAutomationEventBaseFrame, [:int], :void],

      # @!method StartAutomationEventRecording()
      #   StartAutomationEventRecording : Start recording automation events (AutomationEventList must be set)
      #   @return [void]
      [:StartAutomationEventRecording, :StartAutomationEventRecording, [], :void],

      # @!method StopAutomationEventRecording()
      #   StopAutomationEventRecording : Stop recording automation events
      #   @return [void]
      [:StopAutomationEventRecording, :StopAutomationEventRecording, [], :void],

      # @!method PlayAutomationEvent(event)
      #   PlayAutomationEvent : Play a recorded automation event
      #   @param event [AutomationEvent]
      #   @return [void]
      [:PlayAutomationEvent, :PlayAutomationEvent, [AutomationEvent.by_value], :void],

      # @!method IsKeyPressed(key)
      #   IsKeyPressed : Check if a key has been pressed once
      #   @param key [int]
      #   @return [bool]
      [:IsKeyPressed, :IsKeyPressed, [:int], :bool],

      # @!method IsKeyPressedRepeat(key)
      #   IsKeyPressedRepeat : Check if a key has been pressed again
      #   @param key [int]
      #   @return [bool]
      [:IsKeyPressedRepeat, :IsKeyPressedRepeat, [:int], :bool],

      # @!method IsKeyDown(key)
      #   IsKeyDown : Check if a key is being pressed
      #   @param key [int]
      #   @return [bool]
      [:IsKeyDown, :IsKeyDown, [:int], :bool],

      # @!method IsKeyReleased(key)
      #   IsKeyReleased : Check if a key has been released once
      #   @param key [int]
      #   @return [bool]
      [:IsKeyReleased, :IsKeyReleased, [:int], :bool],

      # @!method IsKeyUp(key)
      #   IsKeyUp : Check if a key is NOT being pressed
      #   @param key [int]
      #   @return [bool]
      [:IsKeyUp, :IsKeyUp, [:int], :bool],

      # @!method GetKeyPressed()
      #   GetKeyPressed : Get key pressed (keycode), call it multiple times for keys queued, returns 0 when the queue is empty
      #   @return [int]
      [:GetKeyPressed, :GetKeyPressed, [], :int],

      # @!method GetCharPressed()
      #   GetCharPressed : Get char pressed (unicode), call it multiple times for chars queued, returns 0 when the queue is empty
      #   @return [int]
      [:GetCharPressed, :GetCharPressed, [], :int],

      # @!method GetKeyName(key)
      #   GetKeyName : Get name of a QWERTY key on the current keyboard layout (eg returns string 'q' for KEY_A on an AZERTY keyboard)
      #   @param key [int]
      #   @return [const char *]
      [:GetKeyName, :GetKeyName, [:int], :pointer],

      # @!method SetExitKey(key)
      #   SetExitKey : Set a custom key to exit program (default is ESC)
      #   @param key [int]
      #   @return [void]
      [:SetExitKey, :SetExitKey, [:int], :void],

      # @!method IsGamepadAvailable(gamepad)
      #   IsGamepadAvailable : Check if a gamepad is available
      #   @param gamepad [int]
      #   @return [bool]
      [:IsGamepadAvailable, :IsGamepadAvailable, [:int], :bool],

      # @!method GetGamepadName(gamepad)
      #   GetGamepadName : Get gamepad internal name id
      #   @param gamepad [int]
      #   @return [const char *]
      [:GetGamepadName, :GetGamepadName, [:int], :pointer],

      # @!method IsGamepadButtonPressed(gamepad, button)
      #   IsGamepadButtonPressed : Check if a gamepad button has been pressed once
      #   @param gamepad [int]
      #   @param button [int]
      #   @return [bool]
      [:IsGamepadButtonPressed, :IsGamepadButtonPressed, [:int, :int], :bool],

      # @!method IsGamepadButtonDown(gamepad, button)
      #   IsGamepadButtonDown : Check if a gamepad button is being pressed
      #   @param gamepad [int]
      #   @param button [int]
      #   @return [bool]
      [:IsGamepadButtonDown, :IsGamepadButtonDown, [:int, :int], :bool],

      # @!method IsGamepadButtonReleased(gamepad, button)
      #   IsGamepadButtonReleased : Check if a gamepad button has been released once
      #   @param gamepad [int]
      #   @param button [int]
      #   @return [bool]
      [:IsGamepadButtonReleased, :IsGamepadButtonReleased, [:int, :int], :bool],

      # @!method IsGamepadButtonUp(gamepad, button)
      #   IsGamepadButtonUp : Check if a gamepad button is NOT being pressed
      #   @param gamepad [int]
      #   @param button [int]
      #   @return [bool]
      [:IsGamepadButtonUp, :IsGamepadButtonUp, [:int, :int], :bool],

      # @!method GetGamepadButtonPressed()
      #   GetGamepadButtonPressed : Get the last gamepad button pressed
      #   @return [int]
      [:GetGamepadButtonPressed, :GetGamepadButtonPressed, [], :int],

      # @!method GetGamepadAxisCount(gamepad)
      #   GetGamepadAxisCount : Get axis count for a gamepad
      #   @param gamepad [int]
      #   @return [int]
      [:GetGamepadAxisCount, :GetGamepadAxisCount, [:int], :int],

      # @!method GetGamepadAxisMovement(gamepad, axis)
      #   GetGamepadAxisMovement : Get movement value for a gamepad axis
      #   @param gamepad [int]
      #   @param axis [int]
      #   @return [float]
      [:GetGamepadAxisMovement, :GetGamepadAxisMovement, [:int, :int], :float],

      # @!method SetGamepadMappings(mappings)
      #   SetGamepadMappings : Set internal gamepad mappings (SDL_GameControllerDB)
      #   @param mappings [const char *]
      #   @return [int]
      [:SetGamepadMappings, :SetGamepadMappings, [:pointer], :int],

      # @!method SetGamepadVibration(gamepad, leftMotor, rightMotor, duration)
      #   SetGamepadVibration : Set gamepad vibration for both motors (duration in seconds)
      #   @param gamepad [int]
      #   @param leftMotor [float]
      #   @param rightMotor [float]
      #   @param duration [float]
      #   @return [void]
      [:SetGamepadVibration, :SetGamepadVibration, [:int, :float, :float, :float], :void],

      # @!method IsMouseButtonPressed(button)
      #   IsMouseButtonPressed : Check if a mouse button has been pressed once
      #   @param button [int]
      #   @return [bool]
      [:IsMouseButtonPressed, :IsMouseButtonPressed, [:int], :bool],

      # @!method IsMouseButtonDown(button)
      #   IsMouseButtonDown : Check if a mouse button is being pressed
      #   @param button [int]
      #   @return [bool]
      [:IsMouseButtonDown, :IsMouseButtonDown, [:int], :bool],

      # @!method IsMouseButtonReleased(button)
      #   IsMouseButtonReleased : Check if a mouse button has been released once
      #   @param button [int]
      #   @return [bool]
      [:IsMouseButtonReleased, :IsMouseButtonReleased, [:int], :bool],

      # @!method IsMouseButtonUp(button)
      #   IsMouseButtonUp : Check if a mouse button is NOT being pressed
      #   @param button [int]
      #   @return [bool]
      [:IsMouseButtonUp, :IsMouseButtonUp, [:int], :bool],

      # @!method GetMouseX()
      #   GetMouseX : Get mouse position X
      #   @return [int]
      [:GetMouseX, :GetMouseX, [], :int],

      # @!method GetMouseY()
      #   GetMouseY : Get mouse position Y
      #   @return [int]
      [:GetMouseY, :GetMouseY, [], :int],

      # @!method GetMousePosition()
      #   GetMousePosition : Get mouse position XY
      #   @return [Vector2]
      [:GetMousePosition, :GetMousePosition, [], Vector2.by_value],

      # @!method GetMouseDelta()
      #   GetMouseDelta : Get mouse delta between frames
      #   @return [Vector2]
      [:GetMouseDelta, :GetMouseDelta, [], Vector2.by_value],

      # @!method SetMousePosition(x, y)
      #   SetMousePosition : Set mouse position XY
      #   @param x [int]
      #   @param y [int]
      #   @return [void]
      [:SetMousePosition, :SetMousePosition, [:int, :int], :void],

      # @!method SetMouseOffset(offsetX, offsetY)
      #   SetMouseOffset : Set mouse offset
      #   @param offsetX [int]
      #   @param offsetY [int]
      #   @return [void]
      [:SetMouseOffset, :SetMouseOffset, [:int, :int], :void],

      # @!method SetMouseScale(scaleX, scaleY)
      #   SetMouseScale : Set mouse scaling
      #   @param scaleX [float]
      #   @param scaleY [float]
      #   @return [void]
      [:SetMouseScale, :SetMouseScale, [:float, :float], :void],

      # @!method GetMouseWheelMove()
      #   GetMouseWheelMove : Get mouse wheel movement for X or Y, whichever is larger
      #   @return [float]
      [:GetMouseWheelMove, :GetMouseWheelMove, [], :float],

      # @!method GetMouseWheelMoveV()
      #   GetMouseWheelMoveV : Get mouse wheel movement for both X and Y
      #   @return [Vector2]
      [:GetMouseWheelMoveV, :GetMouseWheelMoveV, [], Vector2.by_value],

      # @!method SetMouseCursor(cursor)
      #   SetMouseCursor : Set mouse cursor
      #   @param cursor [int]
      #   @return [void]
      [:SetMouseCursor, :SetMouseCursor, [:int], :void],

      # @!method GetTouchX()
      #   GetTouchX : Get touch position X for touch point 0 (relative to screen size)
      #   @return [int]
      [:GetTouchX, :GetTouchX, [], :int],

      # @!method GetTouchY()
      #   GetTouchY : Get touch position Y for touch point 0 (relative to screen size)
      #   @return [int]
      [:GetTouchY, :GetTouchY, [], :int],

      # @!method GetTouchPosition(index)
      #   GetTouchPosition : Get touch position XY for a touch point index (relative to screen size)
      #   @param index [int]
      #   @return [Vector2]
      [:GetTouchPosition, :GetTouchPosition, [:int], Vector2.by_value],

      # @!method GetTouchPointId(index)
      #   GetTouchPointId : Get touch point identifier for given index
      #   @param index [int]
      #   @return [int]
      [:GetTouchPointId, :GetTouchPointId, [:int], :int],

      # @!method GetTouchPointCount()
      #   GetTouchPointCount : Get number of touch points
      #   @return [int]
      [:GetTouchPointCount, :GetTouchPointCount, [], :int],

      # @!method SetGesturesEnabled(flags)
      #   SetGesturesEnabled : Enable a set of gestures using flags
      #   @param flags [unsigned int]
      #   @return [void]
      [:SetGesturesEnabled, :SetGesturesEnabled, [:uint], :void],

      # @!method IsGestureDetected(gesture)
      #   IsGestureDetected : Check if a gesture have been detected
      #   @param gesture [unsigned int]
      #   @return [bool]
      [:IsGestureDetected, :IsGestureDetected, [:uint], :bool],

      # @!method GetGestureDetected()
      #   GetGestureDetected : Get latest detected gesture
      #   @return [int]
      [:GetGestureDetected, :GetGestureDetected, [], :int],

      # @!method GetGestureHoldDuration()
      #   GetGestureHoldDuration : Get gesture hold time in seconds
      #   @return [float]
      [:GetGestureHoldDuration, :GetGestureHoldDuration, [], :float],

      # @!method GetGestureDragVector()
      #   GetGestureDragVector : Get gesture drag vector
      #   @return [Vector2]
      [:GetGestureDragVector, :GetGestureDragVector, [], Vector2.by_value],

      # @!method GetGestureDragAngle()
      #   GetGestureDragAngle : Get gesture drag angle
      #   @return [float]
      [:GetGestureDragAngle, :GetGestureDragAngle, [], :float],

      # @!method GetGesturePinchVector()
      #   GetGesturePinchVector : Get gesture pinch delta
      #   @return [Vector2]
      [:GetGesturePinchVector, :GetGesturePinchVector, [], Vector2.by_value],

      # @!method GetGesturePinchAngle()
      #   GetGesturePinchAngle : Get gesture pinch angle
      #   @return [float]
      [:GetGesturePinchAngle, :GetGesturePinchAngle, [], :float],

      # @!method UpdateCamera(camera, mode)
      #   UpdateCamera : Update camera position for selected mode
      #   @param camera [Camera *]
      #   @param mode [int]
      #   @return [void]
      [:UpdateCamera, :UpdateCamera, [:pointer, :int], :void],

      # @!method UpdateCameraPro(camera, movement, rotation, zoom)
      #   UpdateCameraPro : Update camera movement/rotation
      #   @param camera [Camera *]
      #   @param movement [Vector3]
      #   @param rotation [Vector3]
      #   @param zoom [float]
      #   @return [void]
      [:UpdateCameraPro, :UpdateCameraPro, [:pointer, Vector3.by_value, Vector3.by_value, :float], :void],

      # @!method SetShapesTexture(texture, source)
      #   SetShapesTexture : Set texture and rectangle to be used on shapes drawing
      #   @param texture [Texture2D]
      #   @param source [Rectangle]
      #   @return [void]
      [:SetShapesTexture, :SetShapesTexture, [Texture2D.by_value, Rectangle.by_value], :void],

      # @!method GetShapesTexture()
      #   GetShapesTexture : Get texture that is used for shapes drawing
      #   @return [Texture2D]
      [:GetShapesTexture, :GetShapesTexture, [], Texture2D.by_value],

      # @!method GetShapesTextureRectangle()
      #   GetShapesTextureRectangle : Get texture source rectangle that is used for shapes drawing
      #   @return [Rectangle]
      [:GetShapesTextureRectangle, :GetShapesTextureRectangle, [], Rectangle.by_value],

      # @!method DrawPixel(posX, posY, color)
      #   DrawPixel : Draw a pixel using geometry [Can be slow, use with care]
      #   @param posX [int]
      #   @param posY [int]
      #   @param color [Color]
      #   @return [void]
      [:DrawPixel, :DrawPixel, [:int, :int, Color.by_value], :void],

      # @!method DrawPixelV(position, color)
      #   DrawPixelV : Draw a pixel using geometry (Vector version) [Can be slow, use with care]
      #   @param position [Vector2]
      #   @param color [Color]
      #   @return [void]
      [:DrawPixelV, :DrawPixelV, [Vector2.by_value, Color.by_value], :void],

      # @!method DrawLine(startPosX, startPosY, endPosX, endPosY, color)
      #   DrawLine : Draw a line
      #   @param startPosX [int]
      #   @param startPosY [int]
      #   @param endPosX [int]
      #   @param endPosY [int]
      #   @param color [Color]
      #   @return [void]
      [:DrawLine, :DrawLine, [:int, :int, :int, :int, Color.by_value], :void],

      # @!method DrawLineV(startPos, endPos, color)
      #   DrawLineV : Draw a line (using gl lines)
      #   @param startPos [Vector2]
      #   @param endPos [Vector2]
      #   @param color [Color]
      #   @return [void]
      [:DrawLineV, :DrawLineV, [Vector2.by_value, Vector2.by_value, Color.by_value], :void],

      # @!method DrawLineEx(startPos, endPos, thick, color)
      #   DrawLineEx : Draw a line (using triangles/quads)
      #   @param startPos [Vector2]
      #   @param endPos [Vector2]
      #   @param thick [float]
      #   @param color [Color]
      #   @return [void]
      [:DrawLineEx, :DrawLineEx, [Vector2.by_value, Vector2.by_value, :float, Color.by_value], :void],

      # @!method DrawLineStrip(points, pointCount, color)
      #   DrawLineStrip : Draw lines sequence (using gl lines)
      #   @param points [const Vector2 *]
      #   @param pointCount [int]
      #   @param color [Color]
      #   @return [void]
      [:DrawLineStrip, :DrawLineStrip, [:pointer, :int, Color.by_value], :void],

      # @!method DrawLineBezier(startPos, endPos, thick, color)
      #   DrawLineBezier : Draw line segment cubic-bezier in-out interpolation
      #   @param startPos [Vector2]
      #   @param endPos [Vector2]
      #   @param thick [float]
      #   @param color [Color]
      #   @return [void]
      [:DrawLineBezier, :DrawLineBezier, [Vector2.by_value, Vector2.by_value, :float, Color.by_value], :void],

      # @!method DrawLineDashed(startPos, endPos, dashSize, spaceSize, color)
      #   DrawLineDashed : Draw a dashed line
      #   @param startPos [Vector2]
      #   @param endPos [Vector2]
      #   @param dashSize [int]
      #   @param spaceSize [int]
      #   @param color [Color]
      #   @return [void]
      [:DrawLineDashed, :DrawLineDashed, [Vector2.by_value, Vector2.by_value, :int, :int, Color.by_value], :void],

      # @!method DrawCircle(centerX, centerY, radius, color)
      #   DrawCircle : Draw a color-filled circle
      #   @param centerX [int]
      #   @param centerY [int]
      #   @param radius [float]
      #   @param color [Color]
      #   @return [void]
      [:DrawCircle, :DrawCircle, [:int, :int, :float, Color.by_value], :void],

      # @!method DrawCircleSector(center, radius, startAngle, endAngle, segments, color)
      #   DrawCircleSector : Draw a piece of a circle
      #   @param center [Vector2]
      #   @param radius [float]
      #   @param startAngle [float]
      #   @param endAngle [float]
      #   @param segments [int]
      #   @param color [Color]
      #   @return [void]
      [:DrawCircleSector, :DrawCircleSector, [Vector2.by_value, :float, :float, :float, :int, Color.by_value], :void],

      # @!method DrawCircleSectorLines(center, radius, startAngle, endAngle, segments, color)
      #   DrawCircleSectorLines : Draw circle sector outline
      #   @param center [Vector2]
      #   @param radius [float]
      #   @param startAngle [float]
      #   @param endAngle [float]
      #   @param segments [int]
      #   @param color [Color]
      #   @return [void]
      [:DrawCircleSectorLines, :DrawCircleSectorLines, [Vector2.by_value, :float, :float, :float, :int, Color.by_value], :void],

      # @!method DrawCircleGradient(centerX, centerY, radius, inner, outer)
      #   DrawCircleGradient : Draw a gradient-filled circle
      #   @param centerX [int]
      #   @param centerY [int]
      #   @param radius [float]
      #   @param inner [Color]
      #   @param outer [Color]
      #   @return [void]
      [:DrawCircleGradient, :DrawCircleGradient, [:int, :int, :float, Color.by_value, Color.by_value], :void],

      # @!method DrawCircleV(center, radius, color)
      #   DrawCircleV : Draw a color-filled circle (Vector version)
      #   @param center [Vector2]
      #   @param radius [float]
      #   @param color [Color]
      #   @return [void]
      [:DrawCircleV, :DrawCircleV, [Vector2.by_value, :float, Color.by_value], :void],

      # @!method DrawCircleLines(centerX, centerY, radius, color)
      #   DrawCircleLines : Draw circle outline
      #   @param centerX [int]
      #   @param centerY [int]
      #   @param radius [float]
      #   @param color [Color]
      #   @return [void]
      [:DrawCircleLines, :DrawCircleLines, [:int, :int, :float, Color.by_value], :void],

      # @!method DrawCircleLinesV(center, radius, color)
      #   DrawCircleLinesV : Draw circle outline (Vector version)
      #   @param center [Vector2]
      #   @param radius [float]
      #   @param color [Color]
      #   @return [void]
      [:DrawCircleLinesV, :DrawCircleLinesV, [Vector2.by_value, :float, Color.by_value], :void],

      # @!method DrawEllipse(centerX, centerY, radiusH, radiusV, color)
      #   DrawEllipse : Draw ellipse
      #   @param centerX [int]
      #   @param centerY [int]
      #   @param radiusH [float]
      #   @param radiusV [float]
      #   @param color [Color]
      #   @return [void]
      [:DrawEllipse, :DrawEllipse, [:int, :int, :float, :float, Color.by_value], :void],

      # @!method DrawEllipseV(center, radiusH, radiusV, color)
      #   DrawEllipseV : Draw ellipse (Vector version)
      #   @param center [Vector2]
      #   @param radiusH [float]
      #   @param radiusV [float]
      #   @param color [Color]
      #   @return [void]
      [:DrawEllipseV, :DrawEllipseV, [Vector2.by_value, :float, :float, Color.by_value], :void],

      # @!method DrawEllipseLines(centerX, centerY, radiusH, radiusV, color)
      #   DrawEllipseLines : Draw ellipse outline
      #   @param centerX [int]
      #   @param centerY [int]
      #   @param radiusH [float]
      #   @param radiusV [float]
      #   @param color [Color]
      #   @return [void]
      [:DrawEllipseLines, :DrawEllipseLines, [:int, :int, :float, :float, Color.by_value], :void],

      # @!method DrawEllipseLinesV(center, radiusH, radiusV, color)
      #   DrawEllipseLinesV : Draw ellipse outline (Vector version)
      #   @param center [Vector2]
      #   @param radiusH [float]
      #   @param radiusV [float]
      #   @param color [Color]
      #   @return [void]
      [:DrawEllipseLinesV, :DrawEllipseLinesV, [Vector2.by_value, :float, :float, Color.by_value], :void],

      # @!method DrawRing(center, innerRadius, outerRadius, startAngle, endAngle, segments, color)
      #   DrawRing : Draw ring
      #   @param center [Vector2]
      #   @param innerRadius [float]
      #   @param outerRadius [float]
      #   @param startAngle [float]
      #   @param endAngle [float]
      #   @param segments [int]
      #   @param color [Color]
      #   @return [void]
      [:DrawRing, :DrawRing, [Vector2.by_value, :float, :float, :float, :float, :int, Color.by_value], :void],

      # @!method DrawRingLines(center, innerRadius, outerRadius, startAngle, endAngle, segments, color)
      #   DrawRingLines : Draw ring outline
      #   @param center [Vector2]
      #   @param innerRadius [float]
      #   @param outerRadius [float]
      #   @param startAngle [float]
      #   @param endAngle [float]
      #   @param segments [int]
      #   @param color [Color]
      #   @return [void]
      [:DrawRingLines, :DrawRingLines, [Vector2.by_value, :float, :float, :float, :float, :int, Color.by_value], :void],

      # @!method DrawRectangle(posX, posY, width, height, color)
      #   DrawRectangle : Draw a color-filled rectangle
      #   @param posX [int]
      #   @param posY [int]
      #   @param width [int]
      #   @param height [int]
      #   @param color [Color]
      #   @return [void]
      [:DrawRectangle, :DrawRectangle, [:int, :int, :int, :int, Color.by_value], :void],

      # @!method DrawRectangleV(position, size, color)
      #   DrawRectangleV : Draw a color-filled rectangle (Vector version)
      #   @param position [Vector2]
      #   @param size [Vector2]
      #   @param color [Color]
      #   @return [void]
      [:DrawRectangleV, :DrawRectangleV, [Vector2.by_value, Vector2.by_value, Color.by_value], :void],

      # @!method DrawRectangleRec(rec, color)
      #   DrawRectangleRec : Draw a color-filled rectangle
      #   @param rec [Rectangle]
      #   @param color [Color]
      #   @return [void]
      [:DrawRectangleRec, :DrawRectangleRec, [Rectangle.by_value, Color.by_value], :void],

      # @!method DrawRectanglePro(rec, origin, rotation, color)
      #   DrawRectanglePro : Draw a color-filled rectangle with pro parameters
      #   @param rec [Rectangle]
      #   @param origin [Vector2]
      #   @param rotation [float]
      #   @param color [Color]
      #   @return [void]
      [:DrawRectanglePro, :DrawRectanglePro, [Rectangle.by_value, Vector2.by_value, :float, Color.by_value], :void],

      # @!method DrawRectangleGradientV(posX, posY, width, height, top, bottom)
      #   DrawRectangleGradientV : Draw a vertical-gradient-filled rectangle
      #   @param posX [int]
      #   @param posY [int]
      #   @param width [int]
      #   @param height [int]
      #   @param top [Color]
      #   @param bottom [Color]
      #   @return [void]
      [:DrawRectangleGradientV, :DrawRectangleGradientV, [:int, :int, :int, :int, Color.by_value, Color.by_value], :void],

      # @!method DrawRectangleGradientH(posX, posY, width, height, left, right)
      #   DrawRectangleGradientH : Draw a horizontal-gradient-filled rectangle
      #   @param posX [int]
      #   @param posY [int]
      #   @param width [int]
      #   @param height [int]
      #   @param left [Color]
      #   @param right [Color]
      #   @return [void]
      [:DrawRectangleGradientH, :DrawRectangleGradientH, [:int, :int, :int, :int, Color.by_value, Color.by_value], :void],

      # @!method DrawRectangleGradientEx(rec, topLeft, bottomLeft, bottomRight, topRight)
      #   DrawRectangleGradientEx : Draw a gradient-filled rectangle with custom vertex colors
      #   @param rec [Rectangle]
      #   @param topLeft [Color]
      #   @param bottomLeft [Color]
      #   @param bottomRight [Color]
      #   @param topRight [Color]
      #   @return [void]
      [:DrawRectangleGradientEx, :DrawRectangleGradientEx, [Rectangle.by_value, Color.by_value, Color.by_value, Color.by_value, Color.by_value], :void],

      # @!method DrawRectangleLines(posX, posY, width, height, color)
      #   DrawRectangleLines : Draw rectangle outline
      #   @param posX [int]
      #   @param posY [int]
      #   @param width [int]
      #   @param height [int]
      #   @param color [Color]
      #   @return [void]
      [:DrawRectangleLines, :DrawRectangleLines, [:int, :int, :int, :int, Color.by_value], :void],

      # @!method DrawRectangleLinesEx(rec, lineThick, color)
      #   DrawRectangleLinesEx : Draw rectangle outline with extended parameters
      #   @param rec [Rectangle]
      #   @param lineThick [float]
      #   @param color [Color]
      #   @return [void]
      [:DrawRectangleLinesEx, :DrawRectangleLinesEx, [Rectangle.by_value, :float, Color.by_value], :void],

      # @!method DrawRectangleRounded(rec, roundness, segments, color)
      #   DrawRectangleRounded : Draw rectangle with rounded edges
      #   @param rec [Rectangle]
      #   @param roundness [float]
      #   @param segments [int]
      #   @param color [Color]
      #   @return [void]
      [:DrawRectangleRounded, :DrawRectangleRounded, [Rectangle.by_value, :float, :int, Color.by_value], :void],

      # @!method DrawRectangleRoundedLines(rec, roundness, segments, color)
      #   DrawRectangleRoundedLines : Draw rectangle lines with rounded edges
      #   @param rec [Rectangle]
      #   @param roundness [float]
      #   @param segments [int]
      #   @param color [Color]
      #   @return [void]
      [:DrawRectangleRoundedLines, :DrawRectangleRoundedLines, [Rectangle.by_value, :float, :int, Color.by_value], :void],

      # @!method DrawRectangleRoundedLinesEx(rec, roundness, segments, lineThick, color)
      #   DrawRectangleRoundedLinesEx : Draw rectangle with rounded edges outline
      #   @param rec [Rectangle]
      #   @param roundness [float]
      #   @param segments [int]
      #   @param lineThick [float]
      #   @param color [Color]
      #   @return [void]
      [:DrawRectangleRoundedLinesEx, :DrawRectangleRoundedLinesEx, [Rectangle.by_value, :float, :int, :float, Color.by_value], :void],

      # @!method DrawTriangle(v1, v2, v3, color)
      #   DrawTriangle : Draw a color-filled triangle (vertex in counter-clockwise order!)
      #   @param v1 [Vector2]
      #   @param v2 [Vector2]
      #   @param v3 [Vector2]
      #   @param color [Color]
      #   @return [void]
      [:DrawTriangle, :DrawTriangle, [Vector2.by_value, Vector2.by_value, Vector2.by_value, Color.by_value], :void],

      # @!method DrawTriangleLines(v1, v2, v3, color)
      #   DrawTriangleLines : Draw triangle outline (vertex in counter-clockwise order!)
      #   @param v1 [Vector2]
      #   @param v2 [Vector2]
      #   @param v3 [Vector2]
      #   @param color [Color]
      #   @return [void]
      [:DrawTriangleLines, :DrawTriangleLines, [Vector2.by_value, Vector2.by_value, Vector2.by_value, Color.by_value], :void],

      # @!method DrawTriangleFan(points, pointCount, color)
      #   DrawTriangleFan : Draw a triangle fan defined by points (first vertex is the center)
      #   @param points [const Vector2 *]
      #   @param pointCount [int]
      #   @param color [Color]
      #   @return [void]
      [:DrawTriangleFan, :DrawTriangleFan, [:pointer, :int, Color.by_value], :void],

      # @!method DrawTriangleStrip(points, pointCount, color)
      #   DrawTriangleStrip : Draw a triangle strip defined by points
      #   @param points [const Vector2 *]
      #   @param pointCount [int]
      #   @param color [Color]
      #   @return [void]
      [:DrawTriangleStrip, :DrawTriangleStrip, [:pointer, :int, Color.by_value], :void],

      # @!method DrawPoly(center, sides, radius, rotation, color)
      #   DrawPoly : Draw a regular polygon (Vector version)
      #   @param center [Vector2]
      #   @param sides [int]
      #   @param radius [float]
      #   @param rotation [float]
      #   @param color [Color]
      #   @return [void]
      [:DrawPoly, :DrawPoly, [Vector2.by_value, :int, :float, :float, Color.by_value], :void],

      # @!method DrawPolyLines(center, sides, radius, rotation, color)
      #   DrawPolyLines : Draw a polygon outline of n sides
      #   @param center [Vector2]
      #   @param sides [int]
      #   @param radius [float]
      #   @param rotation [float]
      #   @param color [Color]
      #   @return [void]
      [:DrawPolyLines, :DrawPolyLines, [Vector2.by_value, :int, :float, :float, Color.by_value], :void],

      # @!method DrawPolyLinesEx(center, sides, radius, rotation, lineThick, color)
      #   DrawPolyLinesEx : Draw a polygon outline of n sides with extended parameters
      #   @param center [Vector2]
      #   @param sides [int]
      #   @param radius [float]
      #   @param rotation [float]
      #   @param lineThick [float]
      #   @param color [Color]
      #   @return [void]
      [:DrawPolyLinesEx, :DrawPolyLinesEx, [Vector2.by_value, :int, :float, :float, :float, Color.by_value], :void],

      # @!method DrawSplineLinear(points, pointCount, thick, color)
      #   DrawSplineLinear : Draw spline: Linear, minimum 2 points
      #   @param points [const Vector2 *]
      #   @param pointCount [int]
      #   @param thick [float]
      #   @param color [Color]
      #   @return [void]
      [:DrawSplineLinear, :DrawSplineLinear, [:pointer, :int, :float, Color.by_value], :void],

      # @!method DrawSplineBasis(points, pointCount, thick, color)
      #   DrawSplineBasis : Draw spline: B-Spline, minimum 4 points
      #   @param points [const Vector2 *]
      #   @param pointCount [int]
      #   @param thick [float]
      #   @param color [Color]
      #   @return [void]
      [:DrawSplineBasis, :DrawSplineBasis, [:pointer, :int, :float, Color.by_value], :void],

      # @!method DrawSplineCatmullRom(points, pointCount, thick, color)
      #   DrawSplineCatmullRom : Draw spline: Catmull-Rom, minimum 4 points
      #   @param points [const Vector2 *]
      #   @param pointCount [int]
      #   @param thick [float]
      #   @param color [Color]
      #   @return [void]
      [:DrawSplineCatmullRom, :DrawSplineCatmullRom, [:pointer, :int, :float, Color.by_value], :void],

      # @!method DrawSplineBezierQuadratic(points, pointCount, thick, color)
      #   DrawSplineBezierQuadratic : Draw spline: Quadratic Bezier, minimum 3 points (1 control point): [p1, c2, p3, c4...]
      #   @param points [const Vector2 *]
      #   @param pointCount [int]
      #   @param thick [float]
      #   @param color [Color]
      #   @return [void]
      [:DrawSplineBezierQuadratic, :DrawSplineBezierQuadratic, [:pointer, :int, :float, Color.by_value], :void],

      # @!method DrawSplineBezierCubic(points, pointCount, thick, color)
      #   DrawSplineBezierCubic : Draw spline: Cubic Bezier, minimum 4 points (2 control points): [p1, c2, c3, p4, c5, c6...]
      #   @param points [const Vector2 *]
      #   @param pointCount [int]
      #   @param thick [float]
      #   @param color [Color]
      #   @return [void]
      [:DrawSplineBezierCubic, :DrawSplineBezierCubic, [:pointer, :int, :float, Color.by_value], :void],

      # @!method DrawSplineSegmentLinear(p1, p2, thick, color)
      #   DrawSplineSegmentLinear : Draw spline segment: Linear, 2 points
      #   @param p1 [Vector2]
      #   @param p2 [Vector2]
      #   @param thick [float]
      #   @param color [Color]
      #   @return [void]
      [:DrawSplineSegmentLinear, :DrawSplineSegmentLinear, [Vector2.by_value, Vector2.by_value, :float, Color.by_value], :void],

      # @!method DrawSplineSegmentBasis(p1, p2, p3, p4, thick, color)
      #   DrawSplineSegmentBasis : Draw spline segment: B-Spline, 4 points
      #   @param p1 [Vector2]
      #   @param p2 [Vector2]
      #   @param p3 [Vector2]
      #   @param p4 [Vector2]
      #   @param thick [float]
      #   @param color [Color]
      #   @return [void]
      [:DrawSplineSegmentBasis, :DrawSplineSegmentBasis, [Vector2.by_value, Vector2.by_value, Vector2.by_value, Vector2.by_value, :float, Color.by_value], :void],

      # @!method DrawSplineSegmentCatmullRom(p1, p2, p3, p4, thick, color)
      #   DrawSplineSegmentCatmullRom : Draw spline segment: Catmull-Rom, 4 points
      #   @param p1 [Vector2]
      #   @param p2 [Vector2]
      #   @param p3 [Vector2]
      #   @param p4 [Vector2]
      #   @param thick [float]
      #   @param color [Color]
      #   @return [void]
      [:DrawSplineSegmentCatmullRom, :DrawSplineSegmentCatmullRom, [Vector2.by_value, Vector2.by_value, Vector2.by_value, Vector2.by_value, :float, Color.by_value], :void],

      # @!method DrawSplineSegmentBezierQuadratic(p1, c2, p3, thick, color)
      #   DrawSplineSegmentBezierQuadratic : Draw spline segment: Quadratic Bezier, 2 points, 1 control point
      #   @param p1 [Vector2]
      #   @param c2 [Vector2]
      #   @param p3 [Vector2]
      #   @param thick [float]
      #   @param color [Color]
      #   @return [void]
      [:DrawSplineSegmentBezierQuadratic, :DrawSplineSegmentBezierQuadratic, [Vector2.by_value, Vector2.by_value, Vector2.by_value, :float, Color.by_value], :void],

      # @!method DrawSplineSegmentBezierCubic(p1, c2, c3, p4, thick, color)
      #   DrawSplineSegmentBezierCubic : Draw spline segment: Cubic Bezier, 2 points, 2 control points
      #   @param p1 [Vector2]
      #   @param c2 [Vector2]
      #   @param c3 [Vector2]
      #   @param p4 [Vector2]
      #   @param thick [float]
      #   @param color [Color]
      #   @return [void]
      [:DrawSplineSegmentBezierCubic, :DrawSplineSegmentBezierCubic, [Vector2.by_value, Vector2.by_value, Vector2.by_value, Vector2.by_value, :float, Color.by_value], :void],

      # @!method GetSplinePointLinear(startPos, endPos, t)
      #   GetSplinePointLinear : Get (evaluate) spline point: Linear
      #   @param startPos [Vector2]
      #   @param endPos [Vector2]
      #   @param t [float]
      #   @return [Vector2]
      [:GetSplinePointLinear, :GetSplinePointLinear, [Vector2.by_value, Vector2.by_value, :float], Vector2.by_value],

      # @!method GetSplinePointBasis(p1, p2, p3, p4, t)
      #   GetSplinePointBasis : Get (evaluate) spline point: B-Spline
      #   @param p1 [Vector2]
      #   @param p2 [Vector2]
      #   @param p3 [Vector2]
      #   @param p4 [Vector2]
      #   @param t [float]
      #   @return [Vector2]
      [:GetSplinePointBasis, :GetSplinePointBasis, [Vector2.by_value, Vector2.by_value, Vector2.by_value, Vector2.by_value, :float], Vector2.by_value],

      # @!method GetSplinePointCatmullRom(p1, p2, p3, p4, t)
      #   GetSplinePointCatmullRom : Get (evaluate) spline point: Catmull-Rom
      #   @param p1 [Vector2]
      #   @param p2 [Vector2]
      #   @param p3 [Vector2]
      #   @param p4 [Vector2]
      #   @param t [float]
      #   @return [Vector2]
      [:GetSplinePointCatmullRom, :GetSplinePointCatmullRom, [Vector2.by_value, Vector2.by_value, Vector2.by_value, Vector2.by_value, :float], Vector2.by_value],

      # @!method GetSplinePointBezierQuad(p1, c2, p3, t)
      #   GetSplinePointBezierQuad : Get (evaluate) spline point: Quadratic Bezier
      #   @param p1 [Vector2]
      #   @param c2 [Vector2]
      #   @param p3 [Vector2]
      #   @param t [float]
      #   @return [Vector2]
      [:GetSplinePointBezierQuad, :GetSplinePointBezierQuad, [Vector2.by_value, Vector2.by_value, Vector2.by_value, :float], Vector2.by_value],

      # @!method GetSplinePointBezierCubic(p1, c2, c3, p4, t)
      #   GetSplinePointBezierCubic : Get (evaluate) spline point: Cubic Bezier
      #   @param p1 [Vector2]
      #   @param c2 [Vector2]
      #   @param c3 [Vector2]
      #   @param p4 [Vector2]
      #   @param t [float]
      #   @return [Vector2]
      [:GetSplinePointBezierCubic, :GetSplinePointBezierCubic, [Vector2.by_value, Vector2.by_value, Vector2.by_value, Vector2.by_value, :float], Vector2.by_value],

      # @!method CheckCollisionRecs(rec1, rec2)
      #   CheckCollisionRecs : Check collision between two rectangles
      #   @param rec1 [Rectangle]
      #   @param rec2 [Rectangle]
      #   @return [bool]
      [:CheckCollisionRecs, :CheckCollisionRecs, [Rectangle.by_value, Rectangle.by_value], :bool],

      # @!method CheckCollisionCircles(center1, radius1, center2, radius2)
      #   CheckCollisionCircles : Check collision between two circles
      #   @param center1 [Vector2]
      #   @param radius1 [float]
      #   @param center2 [Vector2]
      #   @param radius2 [float]
      #   @return [bool]
      [:CheckCollisionCircles, :CheckCollisionCircles, [Vector2.by_value, :float, Vector2.by_value, :float], :bool],

      # @!method CheckCollisionCircleRec(center, radius, rec)
      #   CheckCollisionCircleRec : Check collision between circle and rectangle
      #   @param center [Vector2]
      #   @param radius [float]
      #   @param rec [Rectangle]
      #   @return [bool]
      [:CheckCollisionCircleRec, :CheckCollisionCircleRec, [Vector2.by_value, :float, Rectangle.by_value], :bool],

      # @!method CheckCollisionCircleLine(center, radius, p1, p2)
      #   CheckCollisionCircleLine : Check if circle collides with a line created betweeen two points [p1] and [p2]
      #   @param center [Vector2]
      #   @param radius [float]
      #   @param p1 [Vector2]
      #   @param p2 [Vector2]
      #   @return [bool]
      [:CheckCollisionCircleLine, :CheckCollisionCircleLine, [Vector2.by_value, :float, Vector2.by_value, Vector2.by_value], :bool],

      # @!method CheckCollisionPointRec(point, rec)
      #   CheckCollisionPointRec : Check if point is inside rectangle
      #   @param point [Vector2]
      #   @param rec [Rectangle]
      #   @return [bool]
      [:CheckCollisionPointRec, :CheckCollisionPointRec, [Vector2.by_value, Rectangle.by_value], :bool],

      # @!method CheckCollisionPointCircle(point, center, radius)
      #   CheckCollisionPointCircle : Check if point is inside circle
      #   @param point [Vector2]
      #   @param center [Vector2]
      #   @param radius [float]
      #   @return [bool]
      [:CheckCollisionPointCircle, :CheckCollisionPointCircle, [Vector2.by_value, Vector2.by_value, :float], :bool],

      # @!method CheckCollisionPointTriangle(point, p1, p2, p3)
      #   CheckCollisionPointTriangle : Check if point is inside a triangle
      #   @param point [Vector2]
      #   @param p1 [Vector2]
      #   @param p2 [Vector2]
      #   @param p3 [Vector2]
      #   @return [bool]
      [:CheckCollisionPointTriangle, :CheckCollisionPointTriangle, [Vector2.by_value, Vector2.by_value, Vector2.by_value, Vector2.by_value], :bool],

      # @!method CheckCollisionPointLine(point, p1, p2, threshold)
      #   CheckCollisionPointLine : Check if point belongs to line created between two points [p1] and [p2] with defined margin in pixels [threshold]
      #   @param point [Vector2]
      #   @param p1 [Vector2]
      #   @param p2 [Vector2]
      #   @param threshold [int]
      #   @return [bool]
      [:CheckCollisionPointLine, :CheckCollisionPointLine, [Vector2.by_value, Vector2.by_value, Vector2.by_value, :int], :bool],

      # @!method CheckCollisionPointPoly(point, points, pointCount)
      #   CheckCollisionPointPoly : Check if point is within a polygon described by array of vertices
      #   @param point [Vector2]
      #   @param points [const Vector2 *]
      #   @param pointCount [int]
      #   @return [bool]
      [:CheckCollisionPointPoly, :CheckCollisionPointPoly, [Vector2.by_value, :pointer, :int], :bool],

      # @!method CheckCollisionLines(startPos1, endPos1, startPos2, endPos2, collisionPoint)
      #   CheckCollisionLines : Check the collision between two lines defined by two points each, returns collision point by reference
      #   @param startPos1 [Vector2]
      #   @param endPos1 [Vector2]
      #   @param startPos2 [Vector2]
      #   @param endPos2 [Vector2]
      #   @param collisionPoint [Vector2 *]
      #   @return [bool]
      [:CheckCollisionLines, :CheckCollisionLines, [Vector2.by_value, Vector2.by_value, Vector2.by_value, Vector2.by_value, :pointer], :bool],

      # @!method GetCollisionRec(rec1, rec2)
      #   GetCollisionRec : Get collision rectangle for two rectangles collision
      #   @param rec1 [Rectangle]
      #   @param rec2 [Rectangle]
      #   @return [Rectangle]
      [:GetCollisionRec, :GetCollisionRec, [Rectangle.by_value, Rectangle.by_value], Rectangle.by_value],

      # @!method LoadImage(fileName)
      #   LoadImage : Load image from file into CPU memory (RAM)
      #   @param fileName [const char *]
      #   @return [Image]
      [:LoadImage, :LoadImage, [:pointer], Image.by_value],

      # @!method LoadImageRaw(fileName, width, height, format, headerSize)
      #   LoadImageRaw : Load image from RAW file data
      #   @param fileName [const char *]
      #   @param width [int]
      #   @param height [int]
      #   @param format [int]
      #   @param headerSize [int]
      #   @return [Image]
      [:LoadImageRaw, :LoadImageRaw, [:pointer, :int, :int, :int, :int], Image.by_value],

      # @!method LoadImageAnim(fileName, frames)
      #   LoadImageAnim : Load image sequence from file (frames appended to image.data)
      #   @param fileName [const char *]
      #   @param frames [int *]
      #   @return [Image]
      [:LoadImageAnim, :LoadImageAnim, [:pointer, :pointer], Image.by_value],

      # @!method LoadImageAnimFromMemory(fileType, fileData, dataSize, frames)
      #   LoadImageAnimFromMemory : Load image sequence from memory buffer
      #   @param fileType [const char *]
      #   @param fileData [const unsigned char *]
      #   @param dataSize [int]
      #   @param frames [int *]
      #   @return [Image]
      [:LoadImageAnimFromMemory, :LoadImageAnimFromMemory, [:pointer, :pointer, :int, :pointer], Image.by_value],

      # @!method LoadImageFromMemory(fileType, fileData, dataSize)
      #   LoadImageFromMemory : Load image from memory buffer, fileType refers to extension: i.e. '.png'
      #   @param fileType [const char *]
      #   @param fileData [const unsigned char *]
      #   @param dataSize [int]
      #   @return [Image]
      [:LoadImageFromMemory, :LoadImageFromMemory, [:pointer, :pointer, :int], Image.by_value],

      # @!method LoadImageFromTexture(texture)
      #   LoadImageFromTexture : Load image from GPU texture data
      #   @param texture [Texture2D]
      #   @return [Image]
      [:LoadImageFromTexture, :LoadImageFromTexture, [Texture2D.by_value], Image.by_value],

      # @!method LoadImageFromScreen()
      #   LoadImageFromScreen : Load image from screen buffer and (screenshot)
      #   @return [Image]
      [:LoadImageFromScreen, :LoadImageFromScreen, [], Image.by_value],

      # @!method IsImageValid(image)
      #   IsImageValid : Check if an image is valid (data and parameters)
      #   @param image [Image]
      #   @return [bool]
      [:IsImageValid, :IsImageValid, [Image.by_value], :bool],

      # @!method UnloadImage(image)
      #   UnloadImage : Unload image from CPU memory (RAM)
      #   @param image [Image]
      #   @return [void]
      [:UnloadImage, :UnloadImage, [Image.by_value], :void],

      # @!method ExportImage(image, fileName)
      #   ExportImage : Export image data to file, returns true on success
      #   @param image [Image]
      #   @param fileName [const char *]
      #   @return [bool]
      [:ExportImage, :ExportImage, [Image.by_value, :pointer], :bool],

      # @!method ExportImageToMemory(image, fileType, fileSize)
      #   ExportImageToMemory : Export image to memory buffer
      #   @param image [Image]
      #   @param fileType [const char *]
      #   @param fileSize [int *]
      #   @return [unsigned char *]
      [:ExportImageToMemory, :ExportImageToMemory, [Image.by_value, :pointer, :pointer], :pointer],

      # @!method ExportImageAsCode(image, fileName)
      #   ExportImageAsCode : Export image as code file defining an array of bytes, returns true on success
      #   @param image [Image]
      #   @param fileName [const char *]
      #   @return [bool]
      [:ExportImageAsCode, :ExportImageAsCode, [Image.by_value, :pointer], :bool],

      # @!method GenImageColor(width, height, color)
      #   GenImageColor : Generate image: plain color
      #   @param width [int]
      #   @param height [int]
      #   @param color [Color]
      #   @return [Image]
      [:GenImageColor, :GenImageColor, [:int, :int, Color.by_value], Image.by_value],

      # @!method GenImageGradientLinear(width, height, direction, start, end)
      #   GenImageGradientLinear : Generate image: linear gradient, direction in degrees [0..360], 0=Vertical gradient
      #   @param width [int]
      #   @param height [int]
      #   @param direction [int]
      #   @param start [Color]
      #   @param end [Color]
      #   @return [Image]
      [:GenImageGradientLinear, :GenImageGradientLinear, [:int, :int, :int, Color.by_value, Color.by_value], Image.by_value],

      # @!method GenImageGradientRadial(width, height, density, inner, outer)
      #   GenImageGradientRadial : Generate image: radial gradient
      #   @param width [int]
      #   @param height [int]
      #   @param density [float]
      #   @param inner [Color]
      #   @param outer [Color]
      #   @return [Image]
      [:GenImageGradientRadial, :GenImageGradientRadial, [:int, :int, :float, Color.by_value, Color.by_value], Image.by_value],

      # @!method GenImageGradientSquare(width, height, density, inner, outer)
      #   GenImageGradientSquare : Generate image: square gradient
      #   @param width [int]
      #   @param height [int]
      #   @param density [float]
      #   @param inner [Color]
      #   @param outer [Color]
      #   @return [Image]
      [:GenImageGradientSquare, :GenImageGradientSquare, [:int, :int, :float, Color.by_value, Color.by_value], Image.by_value],

      # @!method GenImageChecked(width, height, checksX, checksY, col1, col2)
      #   GenImageChecked : Generate image: checked
      #   @param width [int]
      #   @param height [int]
      #   @param checksX [int]
      #   @param checksY [int]
      #   @param col1 [Color]
      #   @param col2 [Color]
      #   @return [Image]
      [:GenImageChecked, :GenImageChecked, [:int, :int, :int, :int, Color.by_value, Color.by_value], Image.by_value],

      # @!method GenImageWhiteNoise(width, height, factor)
      #   GenImageWhiteNoise : Generate image: white noise
      #   @param width [int]
      #   @param height [int]
      #   @param factor [float]
      #   @return [Image]
      [:GenImageWhiteNoise, :GenImageWhiteNoise, [:int, :int, :float], Image.by_value],

      # @!method GenImagePerlinNoise(width, height, offsetX, offsetY, scale)
      #   GenImagePerlinNoise : Generate image: perlin noise
      #   @param width [int]
      #   @param height [int]
      #   @param offsetX [int]
      #   @param offsetY [int]
      #   @param scale [float]
      #   @return [Image]
      [:GenImagePerlinNoise, :GenImagePerlinNoise, [:int, :int, :int, :int, :float], Image.by_value],

      # @!method GenImageCellular(width, height, tileSize)
      #   GenImageCellular : Generate image: cellular algorithm, bigger tileSize means bigger cells
      #   @param width [int]
      #   @param height [int]
      #   @param tileSize [int]
      #   @return [Image]
      [:GenImageCellular, :GenImageCellular, [:int, :int, :int], Image.by_value],

      # @!method GenImageText(width, height, text)
      #   GenImageText : Generate image: grayscale image from text data
      #   @param width [int]
      #   @param height [int]
      #   @param text [const char *]
      #   @return [Image]
      [:GenImageText, :GenImageText, [:int, :int, :pointer], Image.by_value],

      # @!method ImageCopy(image)
      #   ImageCopy : Create an image duplicate (useful for transformations)
      #   @param image [Image]
      #   @return [Image]
      [:ImageCopy, :ImageCopy, [Image.by_value], Image.by_value],

      # @!method ImageFromImage(image, rec)
      #   ImageFromImage : Create an image from another image piece
      #   @param image [Image]
      #   @param rec [Rectangle]
      #   @return [Image]
      [:ImageFromImage, :ImageFromImage, [Image.by_value, Rectangle.by_value], Image.by_value],

      # @!method ImageFromChannel(image, selectedChannel)
      #   ImageFromChannel : Create an image from a selected channel of another image (GRAYSCALE)
      #   @param image [Image]
      #   @param selectedChannel [int]
      #   @return [Image]
      [:ImageFromChannel, :ImageFromChannel, [Image.by_value, :int], Image.by_value],

      # @!method ImageText(text, fontSize, color)
      #   ImageText : Create an image from text (default font)
      #   @param text [const char *]
      #   @param fontSize [int]
      #   @param color [Color]
      #   @return [Image]
      [:ImageText, :ImageText, [:pointer, :int, Color.by_value], Image.by_value],

      # @!method ImageTextEx(font, text, fontSize, spacing, tint)
      #   ImageTextEx : Create an image from text (custom sprite font)
      #   @param font [Font]
      #   @param text [const char *]
      #   @param fontSize [float]
      #   @param spacing [float]
      #   @param tint [Color]
      #   @return [Image]
      [:ImageTextEx, :ImageTextEx, [Font.by_value, :pointer, :float, :float, Color.by_value], Image.by_value],

      # @!method ImageFormat(image, newFormat)
      #   ImageFormat : Convert image data to desired format
      #   @param image [Image *]
      #   @param newFormat [int]
      #   @return [void]
      [:ImageFormat, :ImageFormat, [:pointer, :int], :void],

      # @!method ImageToPOT(image, fill)
      #   ImageToPOT : Convert image to POT (power-of-two)
      #   @param image [Image *]
      #   @param fill [Color]
      #   @return [void]
      [:ImageToPOT, :ImageToPOT, [:pointer, Color.by_value], :void],

      # @!method ImageCrop(image, crop)
      #   ImageCrop : Crop an image to a defined rectangle
      #   @param image [Image *]
      #   @param crop [Rectangle]
      #   @return [void]
      [:ImageCrop, :ImageCrop, [:pointer, Rectangle.by_value], :void],

      # @!method ImageAlphaCrop(image, threshold)
      #   ImageAlphaCrop : Crop image depending on alpha value
      #   @param image [Image *]
      #   @param threshold [float]
      #   @return [void]
      [:ImageAlphaCrop, :ImageAlphaCrop, [:pointer, :float], :void],

      # @!method ImageAlphaClear(image, color, threshold)
      #   ImageAlphaClear : Clear alpha channel to desired color
      #   @param image [Image *]
      #   @param color [Color]
      #   @param threshold [float]
      #   @return [void]
      [:ImageAlphaClear, :ImageAlphaClear, [:pointer, Color.by_value, :float], :void],

      # @!method ImageAlphaMask(image, alphaMask)
      #   ImageAlphaMask : Apply alpha mask to image
      #   @param image [Image *]
      #   @param alphaMask [Image]
      #   @return [void]
      [:ImageAlphaMask, :ImageAlphaMask, [:pointer, Image.by_value], :void],

      # @!method ImageAlphaPremultiply(image)
      #   ImageAlphaPremultiply : Premultiply alpha channel
      #   @param image [Image *]
      #   @return [void]
      [:ImageAlphaPremultiply, :ImageAlphaPremultiply, [:pointer], :void],

      # @!method ImageBlurGaussian(image, blurSize)
      #   ImageBlurGaussian : Apply Gaussian blur using a box blur approximation
      #   @param image [Image *]
      #   @param blurSize [int]
      #   @return [void]
      [:ImageBlurGaussian, :ImageBlurGaussian, [:pointer, :int], :void],

      # @!method ImageKernelConvolution(image, kernel, kernelSize)
      #   ImageKernelConvolution : Apply custom square convolution kernel to image
      #   @param image [Image *]
      #   @param kernel [const float *]
      #   @param kernelSize [int]
      #   @return [void]
      [:ImageKernelConvolution, :ImageKernelConvolution, [:pointer, :pointer, :int], :void],

      # @!method ImageResize(image, newWidth, newHeight)
      #   ImageResize : Resize image (Bicubic scaling algorithm)
      #   @param image [Image *]
      #   @param newWidth [int]
      #   @param newHeight [int]
      #   @return [void]
      [:ImageResize, :ImageResize, [:pointer, :int, :int], :void],

      # @!method ImageResizeNN(image, newWidth, newHeight)
      #   ImageResizeNN : Resize image (Nearest-Neighbor scaling algorithm)
      #   @param image [Image *]
      #   @param newWidth [int]
      #   @param newHeight [int]
      #   @return [void]
      [:ImageResizeNN, :ImageResizeNN, [:pointer, :int, :int], :void],

      # @!method ImageResizeCanvas(image, newWidth, newHeight, offsetX, offsetY, fill)
      #   ImageResizeCanvas : Resize canvas and fill with color
      #   @param image [Image *]
      #   @param newWidth [int]
      #   @param newHeight [int]
      #   @param offsetX [int]
      #   @param offsetY [int]
      #   @param fill [Color]
      #   @return [void]
      [:ImageResizeCanvas, :ImageResizeCanvas, [:pointer, :int, :int, :int, :int, Color.by_value], :void],

      # @!method ImageMipmaps(image)
      #   ImageMipmaps : Compute all mipmap levels for a provided image
      #   @param image [Image *]
      #   @return [void]
      [:ImageMipmaps, :ImageMipmaps, [:pointer], :void],

      # @!method ImageDither(image, rBpp, gBpp, bBpp, aBpp)
      #   ImageDither : Dither image data to 16bpp or lower (Floyd-Steinberg dithering)
      #   @param image [Image *]
      #   @param rBpp [int]
      #   @param gBpp [int]
      #   @param bBpp [int]
      #   @param aBpp [int]
      #   @return [void]
      [:ImageDither, :ImageDither, [:pointer, :int, :int, :int, :int], :void],

      # @!method ImageFlipVertical(image)
      #   ImageFlipVertical : Flip image vertically
      #   @param image [Image *]
      #   @return [void]
      [:ImageFlipVertical, :ImageFlipVertical, [:pointer], :void],

      # @!method ImageFlipHorizontal(image)
      #   ImageFlipHorizontal : Flip image horizontally
      #   @param image [Image *]
      #   @return [void]
      [:ImageFlipHorizontal, :ImageFlipHorizontal, [:pointer], :void],

      # @!method ImageRotate(image, degrees)
      #   ImageRotate : Rotate image by input angle in degrees (-359 to 359)
      #   @param image [Image *]
      #   @param degrees [int]
      #   @return [void]
      [:ImageRotate, :ImageRotate, [:pointer, :int], :void],

      # @!method ImageRotateCW(image)
      #   ImageRotateCW : Rotate image clockwise 90deg
      #   @param image [Image *]
      #   @return [void]
      [:ImageRotateCW, :ImageRotateCW, [:pointer], :void],

      # @!method ImageRotateCCW(image)
      #   ImageRotateCCW : Rotate image counter-clockwise 90deg
      #   @param image [Image *]
      #   @return [void]
      [:ImageRotateCCW, :ImageRotateCCW, [:pointer], :void],

      # @!method ImageColorTint(image, color)
      #   ImageColorTint : Modify image color: tint
      #   @param image [Image *]
      #   @param color [Color]
      #   @return [void]
      [:ImageColorTint, :ImageColorTint, [:pointer, Color.by_value], :void],

      # @!method ImageColorInvert(image)
      #   ImageColorInvert : Modify image color: invert
      #   @param image [Image *]
      #   @return [void]
      [:ImageColorInvert, :ImageColorInvert, [:pointer], :void],

      # @!method ImageColorGrayscale(image)
      #   ImageColorGrayscale : Modify image color: grayscale
      #   @param image [Image *]
      #   @return [void]
      [:ImageColorGrayscale, :ImageColorGrayscale, [:pointer], :void],

      # @!method ImageColorContrast(image, contrast)
      #   ImageColorContrast : Modify image color: contrast (-100 to 100)
      #   @param image [Image *]
      #   @param contrast [float]
      #   @return [void]
      [:ImageColorContrast, :ImageColorContrast, [:pointer, :float], :void],

      # @!method ImageColorBrightness(image, brightness)
      #   ImageColorBrightness : Modify image color: brightness (-255 to 255)
      #   @param image [Image *]
      #   @param brightness [int]
      #   @return [void]
      [:ImageColorBrightness, :ImageColorBrightness, [:pointer, :int], :void],

      # @!method ImageColorReplace(image, color, replace)
      #   ImageColorReplace : Modify image color: replace color
      #   @param image [Image *]
      #   @param color [Color]
      #   @param replace [Color]
      #   @return [void]
      [:ImageColorReplace, :ImageColorReplace, [:pointer, Color.by_value, Color.by_value], :void],

      # @!method LoadImageColors(image)
      #   LoadImageColors : Load color data from image as a Color array (RGBA - 32bit)
      #   @param image [Image]
      #   @return [Color *]
      [:LoadImageColors, :LoadImageColors, [Image.by_value], :pointer],

      # @!method LoadImagePalette(image, maxPaletteSize, colorCount)
      #   LoadImagePalette : Load colors palette from image as a Color array (RGBA - 32bit)
      #   @param image [Image]
      #   @param maxPaletteSize [int]
      #   @param colorCount [int *]
      #   @return [Color *]
      [:LoadImagePalette, :LoadImagePalette, [Image.by_value, :int, :pointer], :pointer],

      # @!method UnloadImageColors(colors)
      #   UnloadImageColors : Unload color data loaded with LoadImageColors()
      #   @param colors [Color *]
      #   @return [void]
      [:UnloadImageColors, :UnloadImageColors, [:pointer], :void],

      # @!method UnloadImagePalette(colors)
      #   UnloadImagePalette : Unload colors palette loaded with LoadImagePalette()
      #   @param colors [Color *]
      #   @return [void]
      [:UnloadImagePalette, :UnloadImagePalette, [:pointer], :void],

      # @!method GetImageAlphaBorder(image, threshold)
      #   GetImageAlphaBorder : Get image alpha border rectangle
      #   @param image [Image]
      #   @param threshold [float]
      #   @return [Rectangle]
      [:GetImageAlphaBorder, :GetImageAlphaBorder, [Image.by_value, :float], Rectangle.by_value],

      # @!method GetImageColor(image, x, y)
      #   GetImageColor : Get image pixel color at (x, y) position
      #   @param image [Image]
      #   @param x [int]
      #   @param y [int]
      #   @return [Color]
      [:GetImageColor, :GetImageColor, [Image.by_value, :int, :int], Color.by_value],

      # @!method ImageClearBackground(dst, color)
      #   ImageClearBackground : Clear image background with given color
      #   @param dst [Image *]
      #   @param color [Color]
      #   @return [void]
      [:ImageClearBackground, :ImageClearBackground, [:pointer, Color.by_value], :void],

      # @!method ImageDrawPixel(dst, posX, posY, color)
      #   ImageDrawPixel : Draw pixel within an image
      #   @param dst [Image *]
      #   @param posX [int]
      #   @param posY [int]
      #   @param color [Color]
      #   @return [void]
      [:ImageDrawPixel, :ImageDrawPixel, [:pointer, :int, :int, Color.by_value], :void],

      # @!method ImageDrawPixelV(dst, position, color)
      #   ImageDrawPixelV : Draw pixel within an image (Vector version)
      #   @param dst [Image *]
      #   @param position [Vector2]
      #   @param color [Color]
      #   @return [void]
      [:ImageDrawPixelV, :ImageDrawPixelV, [:pointer, Vector2.by_value, Color.by_value], :void],

      # @!method ImageDrawLine(dst, startPosX, startPosY, endPosX, endPosY, color)
      #   ImageDrawLine : Draw line within an image
      #   @param dst [Image *]
      #   @param startPosX [int]
      #   @param startPosY [int]
      #   @param endPosX [int]
      #   @param endPosY [int]
      #   @param color [Color]
      #   @return [void]
      [:ImageDrawLine, :ImageDrawLine, [:pointer, :int, :int, :int, :int, Color.by_value], :void],

      # @!method ImageDrawLineV(dst, start, end, color)
      #   ImageDrawLineV : Draw line within an image (Vector version)
      #   @param dst [Image *]
      #   @param start [Vector2]
      #   @param end [Vector2]
      #   @param color [Color]
      #   @return [void]
      [:ImageDrawLineV, :ImageDrawLineV, [:pointer, Vector2.by_value, Vector2.by_value, Color.by_value], :void],

      # @!method ImageDrawLineEx(dst, start, end, thick, color)
      #   ImageDrawLineEx : Draw a line defining thickness within an image
      #   @param dst [Image *]
      #   @param start [Vector2]
      #   @param end [Vector2]
      #   @param thick [int]
      #   @param color [Color]
      #   @return [void]
      [:ImageDrawLineEx, :ImageDrawLineEx, [:pointer, Vector2.by_value, Vector2.by_value, :int, Color.by_value], :void],

      # @!method ImageDrawCircle(dst, centerX, centerY, radius, color)
      #   ImageDrawCircle : Draw a filled circle within an image
      #   @param dst [Image *]
      #   @param centerX [int]
      #   @param centerY [int]
      #   @param radius [int]
      #   @param color [Color]
      #   @return [void]
      [:ImageDrawCircle, :ImageDrawCircle, [:pointer, :int, :int, :int, Color.by_value], :void],

      # @!method ImageDrawCircleV(dst, center, radius, color)
      #   ImageDrawCircleV : Draw a filled circle within an image (Vector version)
      #   @param dst [Image *]
      #   @param center [Vector2]
      #   @param radius [int]
      #   @param color [Color]
      #   @return [void]
      [:ImageDrawCircleV, :ImageDrawCircleV, [:pointer, Vector2.by_value, :int, Color.by_value], :void],

      # @!method ImageDrawCircleLines(dst, centerX, centerY, radius, color)
      #   ImageDrawCircleLines : Draw circle outline within an image
      #   @param dst [Image *]
      #   @param centerX [int]
      #   @param centerY [int]
      #   @param radius [int]
      #   @param color [Color]
      #   @return [void]
      [:ImageDrawCircleLines, :ImageDrawCircleLines, [:pointer, :int, :int, :int, Color.by_value], :void],

      # @!method ImageDrawCircleLinesV(dst, center, radius, color)
      #   ImageDrawCircleLinesV : Draw circle outline within an image (Vector version)
      #   @param dst [Image *]
      #   @param center [Vector2]
      #   @param radius [int]
      #   @param color [Color]
      #   @return [void]
      [:ImageDrawCircleLinesV, :ImageDrawCircleLinesV, [:pointer, Vector2.by_value, :int, Color.by_value], :void],

      # @!method ImageDrawRectangle(dst, posX, posY, width, height, color)
      #   ImageDrawRectangle : Draw rectangle within an image
      #   @param dst [Image *]
      #   @param posX [int]
      #   @param posY [int]
      #   @param width [int]
      #   @param height [int]
      #   @param color [Color]
      #   @return [void]
      [:ImageDrawRectangle, :ImageDrawRectangle, [:pointer, :int, :int, :int, :int, Color.by_value], :void],

      # @!method ImageDrawRectangleV(dst, position, size, color)
      #   ImageDrawRectangleV : Draw rectangle within an image (Vector version)
      #   @param dst [Image *]
      #   @param position [Vector2]
      #   @param size [Vector2]
      #   @param color [Color]
      #   @return [void]
      [:ImageDrawRectangleV, :ImageDrawRectangleV, [:pointer, Vector2.by_value, Vector2.by_value, Color.by_value], :void],

      # @!method ImageDrawRectangleRec(dst, rec, color)
      #   ImageDrawRectangleRec : Draw rectangle within an image
      #   @param dst [Image *]
      #   @param rec [Rectangle]
      #   @param color [Color]
      #   @return [void]
      [:ImageDrawRectangleRec, :ImageDrawRectangleRec, [:pointer, Rectangle.by_value, Color.by_value], :void],

      # @!method ImageDrawRectangleLines(dst, rec, thick, color)
      #   ImageDrawRectangleLines : Draw rectangle lines within an image
      #   @param dst [Image *]
      #   @param rec [Rectangle]
      #   @param thick [int]
      #   @param color [Color]
      #   @return [void]
      [:ImageDrawRectangleLines, :ImageDrawRectangleLines, [:pointer, Rectangle.by_value, :int, Color.by_value], :void],

      # @!method ImageDrawTriangle(dst, v1, v2, v3, color)
      #   ImageDrawTriangle : Draw triangle within an image
      #   @param dst [Image *]
      #   @param v1 [Vector2]
      #   @param v2 [Vector2]
      #   @param v3 [Vector2]
      #   @param color [Color]
      #   @return [void]
      [:ImageDrawTriangle, :ImageDrawTriangle, [:pointer, Vector2.by_value, Vector2.by_value, Vector2.by_value, Color.by_value], :void],

      # @!method ImageDrawTriangleEx(dst, v1, v2, v3, c1, c2, c3)
      #   ImageDrawTriangleEx : Draw triangle with interpolated colors within an image
      #   @param dst [Image *]
      #   @param v1 [Vector2]
      #   @param v2 [Vector2]
      #   @param v3 [Vector2]
      #   @param c1 [Color]
      #   @param c2 [Color]
      #   @param c3 [Color]
      #   @return [void]
      [:ImageDrawTriangleEx, :ImageDrawTriangleEx, [:pointer, Vector2.by_value, Vector2.by_value, Vector2.by_value, Color.by_value, Color.by_value, Color.by_value], :void],

      # @!method ImageDrawTriangleLines(dst, v1, v2, v3, color)
      #   ImageDrawTriangleLines : Draw triangle outline within an image
      #   @param dst [Image *]
      #   @param v1 [Vector2]
      #   @param v2 [Vector2]
      #   @param v3 [Vector2]
      #   @param color [Color]
      #   @return [void]
      [:ImageDrawTriangleLines, :ImageDrawTriangleLines, [:pointer, Vector2.by_value, Vector2.by_value, Vector2.by_value, Color.by_value], :void],

      # @!method ImageDrawTriangleFan(dst, points, pointCount, color)
      #   ImageDrawTriangleFan : Draw a triangle fan defined by points within an image (first vertex is the center)
      #   @param dst [Image *]
      #   @param points [const Vector2 *]
      #   @param pointCount [int]
      #   @param color [Color]
      #   @return [void]
      [:ImageDrawTriangleFan, :ImageDrawTriangleFan, [:pointer, :pointer, :int, Color.by_value], :void],

      # @!method ImageDrawTriangleStrip(dst, points, pointCount, color)
      #   ImageDrawTriangleStrip : Draw a triangle strip defined by points within an image
      #   @param dst [Image *]
      #   @param points [const Vector2 *]
      #   @param pointCount [int]
      #   @param color [Color]
      #   @return [void]
      [:ImageDrawTriangleStrip, :ImageDrawTriangleStrip, [:pointer, :pointer, :int, Color.by_value], :void],

      # @!method ImageDraw(dst, src, srcRec, dstRec, tint)
      #   ImageDraw : Draw a source image within a destination image (tint applied to source)
      #   @param dst [Image *]
      #   @param src [Image]
      #   @param srcRec [Rectangle]
      #   @param dstRec [Rectangle]
      #   @param tint [Color]
      #   @return [void]
      [:ImageDraw, :ImageDraw, [:pointer, Image.by_value, Rectangle.by_value, Rectangle.by_value, Color.by_value], :void],

      # @!method ImageDrawText(dst, text, posX, posY, fontSize, color)
      #   ImageDrawText : Draw text (using default font) within an image (destination)
      #   @param dst [Image *]
      #   @param text [const char *]
      #   @param posX [int]
      #   @param posY [int]
      #   @param fontSize [int]
      #   @param color [Color]
      #   @return [void]
      [:ImageDrawText, :ImageDrawText, [:pointer, :pointer, :int, :int, :int, Color.by_value], :void],

      # @!method ImageDrawTextEx(dst, font, text, position, fontSize, spacing, tint)
      #   ImageDrawTextEx : Draw text (custom sprite font) within an image (destination)
      #   @param dst [Image *]
      #   @param font [Font]
      #   @param text [const char *]
      #   @param position [Vector2]
      #   @param fontSize [float]
      #   @param spacing [float]
      #   @param tint [Color]
      #   @return [void]
      [:ImageDrawTextEx, :ImageDrawTextEx, [:pointer, Font.by_value, :pointer, Vector2.by_value, :float, :float, Color.by_value], :void],

      # @!method LoadTexture(fileName)
      #   LoadTexture : Load texture from file into GPU memory (VRAM)
      #   @param fileName [const char *]
      #   @return [Texture2D]
      [:LoadTexture, :LoadTexture, [:pointer], Texture2D.by_value],

      # @!method LoadTextureFromImage(image)
      #   LoadTextureFromImage : Load texture from image data
      #   @param image [Image]
      #   @return [Texture2D]
      [:LoadTextureFromImage, :LoadTextureFromImage, [Image.by_value], Texture2D.by_value],

      # @!method LoadTextureCubemap(image, layout)
      #   LoadTextureCubemap : Load cubemap from image, multiple image cubemap layouts supported
      #   @param image [Image]
      #   @param layout [int]
      #   @return [TextureCubemap]
      [:LoadTextureCubemap, :LoadTextureCubemap, [Image.by_value, :int], TextureCubemap.by_value],

      # @!method LoadRenderTexture(width, height)
      #   LoadRenderTexture : Load texture for rendering (framebuffer)
      #   @param width [int]
      #   @param height [int]
      #   @return [RenderTexture2D]
      [:LoadRenderTexture, :LoadRenderTexture, [:int, :int], RenderTexture2D.by_value],

      # @!method IsTextureValid(texture)
      #   IsTextureValid : Check if a texture is valid (loaded in GPU)
      #   @param texture [Texture2D]
      #   @return [bool]
      [:IsTextureValid, :IsTextureValid, [Texture2D.by_value], :bool],

      # @!method UnloadTexture(texture)
      #   UnloadTexture : Unload texture from GPU memory (VRAM)
      #   @param texture [Texture2D]
      #   @return [void]
      [:UnloadTexture, :UnloadTexture, [Texture2D.by_value], :void],

      # @!method IsRenderTextureValid(target)
      #   IsRenderTextureValid : Check if a render texture is valid (loaded in GPU)
      #   @param target [RenderTexture2D]
      #   @return [bool]
      [:IsRenderTextureValid, :IsRenderTextureValid, [RenderTexture2D.by_value], :bool],

      # @!method UnloadRenderTexture(target)
      #   UnloadRenderTexture : Unload render texture from GPU memory (VRAM)
      #   @param target [RenderTexture2D]
      #   @return [void]
      [:UnloadRenderTexture, :UnloadRenderTexture, [RenderTexture2D.by_value], :void],

      # @!method UpdateTexture(texture, pixels)
      #   UpdateTexture : Update GPU texture with new data (pixels should be able to fill texture)
      #   @param texture [Texture2D]
      #   @param pixels [const void *]
      #   @return [void]
      [:UpdateTexture, :UpdateTexture, [Texture2D.by_value, :pointer], :void],

      # @!method UpdateTextureRec(texture, rec, pixels)
      #   UpdateTextureRec : Update GPU texture rectangle with new data (pixels and rec should fit in texture)
      #   @param texture [Texture2D]
      #   @param rec [Rectangle]
      #   @param pixels [const void *]
      #   @return [void]
      [:UpdateTextureRec, :UpdateTextureRec, [Texture2D.by_value, Rectangle.by_value, :pointer], :void],

      # @!method GenTextureMipmaps(texture)
      #   GenTextureMipmaps : Generate GPU mipmaps for a texture
      #   @param texture [Texture2D *]
      #   @return [void]
      [:GenTextureMipmaps, :GenTextureMipmaps, [:pointer], :void],

      # @!method SetTextureFilter(texture, filter)
      #   SetTextureFilter : Set texture scaling filter mode
      #   @param texture [Texture2D]
      #   @param filter [int]
      #   @return [void]
      [:SetTextureFilter, :SetTextureFilter, [Texture2D.by_value, :int], :void],

      # @!method SetTextureWrap(texture, wrap)
      #   SetTextureWrap : Set texture wrapping mode
      #   @param texture [Texture2D]
      #   @param wrap [int]
      #   @return [void]
      [:SetTextureWrap, :SetTextureWrap, [Texture2D.by_value, :int], :void],

      # @!method DrawTexture(texture, posX, posY, tint)
      #   DrawTexture : Draw a Texture2D
      #   @param texture [Texture2D]
      #   @param posX [int]
      #   @param posY [int]
      #   @param tint [Color]
      #   @return [void]
      [:DrawTexture, :DrawTexture, [Texture2D.by_value, :int, :int, Color.by_value], :void],

      # @!method DrawTextureV(texture, position, tint)
      #   DrawTextureV : Draw a Texture2D with position defined as Vector2
      #   @param texture [Texture2D]
      #   @param position [Vector2]
      #   @param tint [Color]
      #   @return [void]
      [:DrawTextureV, :DrawTextureV, [Texture2D.by_value, Vector2.by_value, Color.by_value], :void],

      # @!method DrawTextureEx(texture, position, rotation, scale, tint)
      #   DrawTextureEx : Draw a Texture2D with extended parameters
      #   @param texture [Texture2D]
      #   @param position [Vector2]
      #   @param rotation [float]
      #   @param scale [float]
      #   @param tint [Color]
      #   @return [void]
      [:DrawTextureEx, :DrawTextureEx, [Texture2D.by_value, Vector2.by_value, :float, :float, Color.by_value], :void],

      # @!method DrawTextureRec(texture, source, position, tint)
      #   DrawTextureRec : Draw a part of a texture defined by a rectangle
      #   @param texture [Texture2D]
      #   @param source [Rectangle]
      #   @param position [Vector2]
      #   @param tint [Color]
      #   @return [void]
      [:DrawTextureRec, :DrawTextureRec, [Texture2D.by_value, Rectangle.by_value, Vector2.by_value, Color.by_value], :void],

      # @!method DrawTexturePro(texture, source, dest, origin, rotation, tint)
      #   DrawTexturePro : Draw a part of a texture defined by a rectangle with 'pro' parameters
      #   @param texture [Texture2D]
      #   @param source [Rectangle]
      #   @param dest [Rectangle]
      #   @param origin [Vector2]
      #   @param rotation [float]
      #   @param tint [Color]
      #   @return [void]
      [:DrawTexturePro, :DrawTexturePro, [Texture2D.by_value, Rectangle.by_value, Rectangle.by_value, Vector2.by_value, :float, Color.by_value], :void],

      # @!method DrawTextureNPatch(texture, nPatchInfo, dest, origin, rotation, tint)
      #   DrawTextureNPatch : Draws a texture (or part of it) that stretches or shrinks nicely
      #   @param texture [Texture2D]
      #   @param nPatchInfo [NPatchInfo]
      #   @param dest [Rectangle]
      #   @param origin [Vector2]
      #   @param rotation [float]
      #   @param tint [Color]
      #   @return [void]
      [:DrawTextureNPatch, :DrawTextureNPatch, [Texture2D.by_value, NPatchInfo.by_value, Rectangle.by_value, Vector2.by_value, :float, Color.by_value], :void],

      # @!method ColorIsEqual(col1, col2)
      #   ColorIsEqual : Check if two colors are equal
      #   @param col1 [Color]
      #   @param col2 [Color]
      #   @return [bool]
      [:ColorIsEqual, :ColorIsEqual, [Color.by_value, Color.by_value], :bool],

      # @!method Fade(color, alpha)
      #   Fade : Get color with alpha applied, alpha goes from 0.0f to 1.0f
      #   @param color [Color]
      #   @param alpha [float]
      #   @return [Color]
      [:Fade, :Fade, [Color.by_value, :float], Color.by_value],

      # @!method ColorToInt(color)
      #   ColorToInt : Get hexadecimal value for a Color (0xRRGGBBAA)
      #   @param color [Color]
      #   @return [int]
      [:ColorToInt, :ColorToInt, [Color.by_value], :int],

      # @!method ColorNormalize(color)
      #   ColorNormalize : Get Color normalized as float [0..1]
      #   @param color [Color]
      #   @return [Vector4]
      [:ColorNormalize, :ColorNormalize, [Color.by_value], Vector4.by_value],

      # @!method ColorFromNormalized(normalized)
      #   ColorFromNormalized : Get Color from normalized values [0..1]
      #   @param normalized [Vector4]
      #   @return [Color]
      [:ColorFromNormalized, :ColorFromNormalized, [Vector4.by_value], Color.by_value],

      # @!method ColorToHSV(color)
      #   ColorToHSV : Get HSV values for a Color, hue [0..360], saturation/value [0..1]
      #   @param color [Color]
      #   @return [Vector3]
      [:ColorToHSV, :ColorToHSV, [Color.by_value], Vector3.by_value],

      # @!method ColorFromHSV(hue, saturation, value)
      #   ColorFromHSV : Get a Color from HSV values, hue [0..360], saturation/value [0..1]
      #   @param hue [float]
      #   @param saturation [float]
      #   @param value [float]
      #   @return [Color]
      [:ColorFromHSV, :ColorFromHSV, [:float, :float, :float], Color.by_value],

      # @!method ColorTint(color, tint)
      #   ColorTint : Get color multiplied with another color
      #   @param color [Color]
      #   @param tint [Color]
      #   @return [Color]
      [:ColorTint, :ColorTint, [Color.by_value, Color.by_value], Color.by_value],

      # @!method ColorBrightness(color, factor)
      #   ColorBrightness : Get color with brightness correction, brightness factor goes from -1.0f to 1.0f
      #   @param color [Color]
      #   @param factor [float]
      #   @return [Color]
      [:ColorBrightness, :ColorBrightness, [Color.by_value, :float], Color.by_value],

      # @!method ColorContrast(color, contrast)
      #   ColorContrast : Get color with contrast correction, contrast values between -1.0f and 1.0f
      #   @param color [Color]
      #   @param contrast [float]
      #   @return [Color]
      [:ColorContrast, :ColorContrast, [Color.by_value, :float], Color.by_value],

      # @!method ColorAlpha(color, alpha)
      #   ColorAlpha : Get color with alpha applied, alpha goes from 0.0f to 1.0f
      #   @param color [Color]
      #   @param alpha [float]
      #   @return [Color]
      [:ColorAlpha, :ColorAlpha, [Color.by_value, :float], Color.by_value],

      # @!method ColorAlphaBlend(dst, src, tint)
      #   ColorAlphaBlend : Get src alpha-blended into dst color with tint
      #   @param dst [Color]
      #   @param src [Color]
      #   @param tint [Color]
      #   @return [Color]
      [:ColorAlphaBlend, :ColorAlphaBlend, [Color.by_value, Color.by_value, Color.by_value], Color.by_value],

      # @!method ColorLerp(color1, color2, factor)
      #   ColorLerp : Get color lerp interpolation between two colors, factor [0.0f..1.0f]
      #   @param color1 [Color]
      #   @param color2 [Color]
      #   @param factor [float]
      #   @return [Color]
      [:ColorLerp, :ColorLerp, [Color.by_value, Color.by_value, :float], Color.by_value],

      # @!method GetColor(hexValue)
      #   GetColor : Get Color structure from hexadecimal value
      #   @param hexValue [unsigned int]
      #   @return [Color]
      [:GetColor, :GetColor, [:uint], Color.by_value],

      # @!method GetPixelColor(srcPtr, format)
      #   GetPixelColor : Get Color from a source pixel pointer of certain format
      #   @param srcPtr [void *]
      #   @param format [int]
      #   @return [Color]
      [:GetPixelColor, :GetPixelColor, [:pointer, :int], Color.by_value],

      # @!method SetPixelColor(dstPtr, color, format)
      #   SetPixelColor : Set color formatted into destination pixel pointer
      #   @param dstPtr [void *]
      #   @param color [Color]
      #   @param format [int]
      #   @return [void]
      [:SetPixelColor, :SetPixelColor, [:pointer, Color.by_value, :int], :void],

      # @!method GetPixelDataSize(width, height, format)
      #   GetPixelDataSize : Get pixel data size in bytes for certain format
      #   @param width [int]
      #   @param height [int]
      #   @param format [int]
      #   @return [int]
      [:GetPixelDataSize, :GetPixelDataSize, [:int, :int, :int], :int],

      # @!method GetFontDefault()
      #   GetFontDefault : Get the default Font
      #   @return [Font]
      [:GetFontDefault, :GetFontDefault, [], Font.by_value],

      # @!method LoadFont(fileName)
      #   LoadFont : Load font from file into GPU memory (VRAM)
      #   @param fileName [const char *]
      #   @return [Font]
      [:LoadFont, :LoadFont, [:pointer], Font.by_value],

      # @!method LoadFontEx(fileName, fontSize, codepoints, codepointCount)
      #   LoadFontEx : Load font from file with extended parameters, use NULL for codepoints and 0 for codepointCount to load the default character set, font size is provided in pixels height
      #   @param fileName [const char *]
      #   @param fontSize [int]
      #   @param codepoints [const int *]
      #   @param codepointCount [int]
      #   @return [Font]
      [:LoadFontEx, :LoadFontEx, [:pointer, :int, :pointer, :int], Font.by_value],

      # @!method LoadFontFromImage(image, key, firstChar)
      #   LoadFontFromImage : Load font from Image (XNA style)
      #   @param image [Image]
      #   @param key [Color]
      #   @param firstChar [int]
      #   @return [Font]
      [:LoadFontFromImage, :LoadFontFromImage, [Image.by_value, Color.by_value, :int], Font.by_value],

      # @!method LoadFontFromMemory(fileType, fileData, dataSize, fontSize, codepoints, codepointCount)
      #   LoadFontFromMemory : Load font from memory buffer, fileType refers to extension: i.e. '.ttf'
      #   @param fileType [const char *]
      #   @param fileData [const unsigned char *]
      #   @param dataSize [int]
      #   @param fontSize [int]
      #   @param codepoints [const int *]
      #   @param codepointCount [int]
      #   @return [Font]
      [:LoadFontFromMemory, :LoadFontFromMemory, [:pointer, :pointer, :int, :int, :pointer, :int], Font.by_value],

      # @!method IsFontValid(font)
      #   IsFontValid : Check if a font is valid (font data loaded, WARNING: GPU texture not checked)
      #   @param font [Font]
      #   @return [bool]
      [:IsFontValid, :IsFontValid, [Font.by_value], :bool],

      # @!method LoadFontData(fileData, dataSize, fontSize, codepoints, codepointCount, type, glyphCount)
      #   LoadFontData : Load font data for further use
      #   @param fileData [const unsigned char *]
      #   @param dataSize [int]
      #   @param fontSize [int]
      #   @param codepoints [const int *]
      #   @param codepointCount [int]
      #   @param type [int]
      #   @param glyphCount [int *]
      #   @return [GlyphInfo *]
      [:LoadFontData, :LoadFontData, [:pointer, :int, :int, :pointer, :int, :int, :pointer], :pointer],

      # @!method GenImageFontAtlas(glyphs, glyphRecs, glyphCount, fontSize, padding, packMethod)
      #   GenImageFontAtlas : Generate image font atlas using chars info
      #   @param glyphs [const GlyphInfo *]
      #   @param glyphRecs [Rectangle **]
      #   @param glyphCount [int]
      #   @param fontSize [int]
      #   @param padding [int]
      #   @param packMethod [int]
      #   @return [Image]
      [:GenImageFontAtlas, :GenImageFontAtlas, [:pointer, :pointer, :int, :int, :int, :int], Image.by_value],

      # @!method UnloadFontData(glyphs, glyphCount)
      #   UnloadFontData : Unload font chars info data (RAM)
      #   @param glyphs [GlyphInfo *]
      #   @param glyphCount [int]
      #   @return [void]
      [:UnloadFontData, :UnloadFontData, [:pointer, :int], :void],

      # @!method UnloadFont(font)
      #   UnloadFont : Unload font from GPU memory (VRAM)
      #   @param font [Font]
      #   @return [void]
      [:UnloadFont, :UnloadFont, [Font.by_value], :void],

      # @!method ExportFontAsCode(font, fileName)
      #   ExportFontAsCode : Export font as code file, returns true on success
      #   @param font [Font]
      #   @param fileName [const char *]
      #   @return [bool]
      [:ExportFontAsCode, :ExportFontAsCode, [Font.by_value, :pointer], :bool],

      # @!method DrawFPS(posX, posY)
      #   DrawFPS : Draw current FPS
      #   @param posX [int]
      #   @param posY [int]
      #   @return [void]
      [:DrawFPS, :DrawFPS, [:int, :int], :void],

      # @!method DrawText(text, posX, posY, fontSize, color)
      #   DrawText : Draw text (using default font)
      #   @param text [const char *]
      #   @param posX [int]
      #   @param posY [int]
      #   @param fontSize [int]
      #   @param color [Color]
      #   @return [void]
      [:DrawText, :DrawText, [:pointer, :int, :int, :int, Color.by_value], :void],

      # @!method DrawTextEx(font, text, position, fontSize, spacing, tint)
      #   DrawTextEx : Draw text using font and additional parameters
      #   @param font [Font]
      #   @param text [const char *]
      #   @param position [Vector2]
      #   @param fontSize [float]
      #   @param spacing [float]
      #   @param tint [Color]
      #   @return [void]
      [:DrawTextEx, :DrawTextEx, [Font.by_value, :pointer, Vector2.by_value, :float, :float, Color.by_value], :void],

      # @!method DrawTextPro(font, text, position, origin, rotation, fontSize, spacing, tint)
      #   DrawTextPro : Draw text using Font and pro parameters (rotation)
      #   @param font [Font]
      #   @param text [const char *]
      #   @param position [Vector2]
      #   @param origin [Vector2]
      #   @param rotation [float]
      #   @param fontSize [float]
      #   @param spacing [float]
      #   @param tint [Color]
      #   @return [void]
      [:DrawTextPro, :DrawTextPro, [Font.by_value, :pointer, Vector2.by_value, Vector2.by_value, :float, :float, :float, Color.by_value], :void],

      # @!method DrawTextCodepoint(font, codepoint, position, fontSize, tint)
      #   DrawTextCodepoint : Draw one character (codepoint)
      #   @param font [Font]
      #   @param codepoint [int]
      #   @param position [Vector2]
      #   @param fontSize [float]
      #   @param tint [Color]
      #   @return [void]
      [:DrawTextCodepoint, :DrawTextCodepoint, [Font.by_value, :int, Vector2.by_value, :float, Color.by_value], :void],

      # @!method DrawTextCodepoints(font, codepoints, codepointCount, position, fontSize, spacing, tint)
      #   DrawTextCodepoints : Draw multiple character (codepoint)
      #   @param font [Font]
      #   @param codepoints [const int *]
      #   @param codepointCount [int]
      #   @param position [Vector2]
      #   @param fontSize [float]
      #   @param spacing [float]
      #   @param tint [Color]
      #   @return [void]
      [:DrawTextCodepoints, :DrawTextCodepoints, [Font.by_value, :pointer, :int, Vector2.by_value, :float, :float, Color.by_value], :void],

      # @!method SetTextLineSpacing(spacing)
      #   SetTextLineSpacing : Set vertical line spacing when drawing with line-breaks
      #   @param spacing [int]
      #   @return [void]
      [:SetTextLineSpacing, :SetTextLineSpacing, [:int], :void],

      # @!method MeasureText(text, fontSize)
      #   MeasureText : Measure string width for default font
      #   @param text [const char *]
      #   @param fontSize [int]
      #   @return [int]
      [:MeasureText, :MeasureText, [:pointer, :int], :int],

      # @!method MeasureTextEx(font, text, fontSize, spacing)
      #   MeasureTextEx : Measure string size for Font
      #   @param font [Font]
      #   @param text [const char *]
      #   @param fontSize [float]
      #   @param spacing [float]
      #   @return [Vector2]
      [:MeasureTextEx, :MeasureTextEx, [Font.by_value, :pointer, :float, :float], Vector2.by_value],

      # @!method GetGlyphIndex(font, codepoint)
      #   GetGlyphIndex : Get glyph index position in font for a codepoint (unicode character), fallback to '?' if not found
      #   @param font [Font]
      #   @param codepoint [int]
      #   @return [int]
      [:GetGlyphIndex, :GetGlyphIndex, [Font.by_value, :int], :int],

      # @!method GetGlyphInfo(font, codepoint)
      #   GetGlyphInfo : Get glyph font info data for a codepoint (unicode character), fallback to '?' if not found
      #   @param font [Font]
      #   @param codepoint [int]
      #   @return [GlyphInfo]
      [:GetGlyphInfo, :GetGlyphInfo, [Font.by_value, :int], GlyphInfo.by_value],

      # @!method GetGlyphAtlasRec(font, codepoint)
      #   GetGlyphAtlasRec : Get glyph rectangle in font atlas for a codepoint (unicode character), fallback to '?' if not found
      #   @param font [Font]
      #   @param codepoint [int]
      #   @return [Rectangle]
      [:GetGlyphAtlasRec, :GetGlyphAtlasRec, [Font.by_value, :int], Rectangle.by_value],

      # @!method LoadUTF8(codepoints, length)
      #   LoadUTF8 : Load UTF-8 text encoded from codepoints array
      #   @param codepoints [const int *]
      #   @param length [int]
      #   @return [char *]
      [:LoadUTF8, :LoadUTF8, [:pointer, :int], :pointer],

      # @!method UnloadUTF8(text)
      #   UnloadUTF8 : Unload UTF-8 text encoded from codepoints array
      #   @param text [char *]
      #   @return [void]
      [:UnloadUTF8, :UnloadUTF8, [:pointer], :void],

      # @!method LoadCodepoints(text, count)
      #   LoadCodepoints : Load all codepoints from a UTF-8 text string, codepoints count returned by parameter
      #   @param text [const char *]
      #   @param count [int *]
      #   @return [int *]
      [:LoadCodepoints, :LoadCodepoints, [:pointer, :pointer], :pointer],

      # @!method UnloadCodepoints(codepoints)
      #   UnloadCodepoints : Unload codepoints data from memory
      #   @param codepoints [int *]
      #   @return [void]
      [:UnloadCodepoints, :UnloadCodepoints, [:pointer], :void],

      # @!method GetCodepointCount(text)
      #   GetCodepointCount : Get total number of codepoints in a UTF-8 encoded string
      #   @param text [const char *]
      #   @return [int]
      [:GetCodepointCount, :GetCodepointCount, [:pointer], :int],

      # @!method GetCodepoint(text, codepointSize)
      #   GetCodepoint : Get next codepoint in a UTF-8 encoded string, 0x3f('?') is returned on failure
      #   @param text [const char *]
      #   @param codepointSize [int *]
      #   @return [int]
      [:GetCodepoint, :GetCodepoint, [:pointer, :pointer], :int],

      # @!method GetCodepointNext(text, codepointSize)
      #   GetCodepointNext : Get next codepoint in a UTF-8 encoded string, 0x3f('?') is returned on failure
      #   @param text [const char *]
      #   @param codepointSize [int *]
      #   @return [int]
      [:GetCodepointNext, :GetCodepointNext, [:pointer, :pointer], :int],

      # @!method GetCodepointPrevious(text, codepointSize)
      #   GetCodepointPrevious : Get previous codepoint in a UTF-8 encoded string, 0x3f('?') is returned on failure
      #   @param text [const char *]
      #   @param codepointSize [int *]
      #   @return [int]
      [:GetCodepointPrevious, :GetCodepointPrevious, [:pointer, :pointer], :int],

      # @!method CodepointToUTF8(codepoint, utf8Size)
      #   CodepointToUTF8 : Encode one codepoint into UTF-8 byte array (array length returned as parameter)
      #   @param codepoint [int]
      #   @param utf8Size [int *]
      #   @return [const char *]
      [:CodepointToUTF8, :CodepointToUTF8, [:int, :pointer], :pointer],

      # @!method LoadTextLines(text, count)
      #   LoadTextLines : Load text as separate lines ('\n')
      #   @param text [const char *]
      #   @param count [int *]
      #   @return [char **]
      [:LoadTextLines, :LoadTextLines, [:pointer, :pointer], :pointer],

      # @!method UnloadTextLines(text, lineCount)
      #   UnloadTextLines : Unload text lines
      #   @param text [char **]
      #   @param lineCount [int]
      #   @return [void]
      [:UnloadTextLines, :UnloadTextLines, [:pointer, :int], :void],

      # @!method TextCopy(dst, src)
      #   TextCopy : Copy one string to another, returns bytes copied
      #   @param dst [char *]
      #   @param src [const char *]
      #   @return [int]
      [:TextCopy, :TextCopy, [:pointer, :pointer], :int],

      # @!method TextIsEqual(text1, text2)
      #   TextIsEqual : Check if two text string are equal
      #   @param text1 [const char *]
      #   @param text2 [const char *]
      #   @return [bool]
      [:TextIsEqual, :TextIsEqual, [:pointer, :pointer], :bool],

      # @!method TextLength(text)
      #   TextLength : Get text length, checks for '\0' ending
      #   @param text [const char *]
      #   @return [unsigned int]
      [:TextLength, :TextLength, [:pointer], :uint],

      # @!method TextFormat(text, ...)
      #   TextFormat : Text formatting with variables (sprintf() style)
      #   @param text [const char *]
      #   @param args [...]
      #   @return [const char *]
      [:TextFormat, :TextFormat, [:pointer, :varargs], :pointer],

      # @!method TextSubtext(text, position, length)
      #   TextSubtext : Get a piece of a text string
      #   @param text [const char *]
      #   @param position [int]
      #   @param length [int]
      #   @return [const char *]
      [:TextSubtext, :TextSubtext, [:pointer, :int, :int], :pointer],

      # @!method TextRemoveSpaces(text)
      #   TextRemoveSpaces : Remove text spaces, concat words
      #   @param text [const char *]
      #   @return [const char *]
      [:TextRemoveSpaces, :TextRemoveSpaces, [:pointer], :pointer],

      # @!method GetTextBetween(text, begin, end)
      #   GetTextBetween : Get text between two strings
      #   @param text [const char *]
      #   @param begin [const char *]
      #   @param end [const char *]
      #   @return [char *]
      [:GetTextBetween, :GetTextBetween, [:pointer, :pointer, :pointer], :pointer],

      # @!method TextReplace(text, search, replacement)
      #   TextReplace : Replace text string (WARNING: memory must be freed!)
      #   @param text [const char *]
      #   @param search [const char *]
      #   @param replacement [const char *]
      #   @return [char *]
      [:TextReplace, :TextReplace, [:pointer, :pointer, :pointer], :pointer],

      # @!method TextReplaceBetween(text, begin, end, replacement)
      #   TextReplaceBetween : Replace text between two specific strings (WARNING: memory must be freed!)
      #   @param text [const char *]
      #   @param begin [const char *]
      #   @param end [const char *]
      #   @param replacement [const char *]
      #   @return [char *]
      [:TextReplaceBetween, :TextReplaceBetween, [:pointer, :pointer, :pointer, :pointer], :pointer],

      # @!method TextInsert(text, insert, position)
      #   TextInsert : Insert text in a position (WARNING: memory must be freed!)
      #   @param text [const char *]
      #   @param insert [const char *]
      #   @param position [int]
      #   @return [char *]
      [:TextInsert, :TextInsert, [:pointer, :pointer, :int], :pointer],

      # @!method TextJoin(textList, count, delimiter)
      #   TextJoin : Join text strings with delimiter
      #   @param textList [char **]
      #   @param count [int]
      #   @param delimiter [const char *]
      #   @return [char *]
      [:TextJoin, :TextJoin, [:pointer, :int, :pointer], :pointer],

      # @!method TextSplit(text, delimiter, count)
      #   TextSplit : Split text into multiple strings, using MAX_TEXTSPLIT_COUNT static strings
      #   @param text [const char *]
      #   @param delimiter [char]
      #   @param count [int *]
      #   @return [char **]
      [:TextSplit, :TextSplit, [:pointer, :char, :pointer], :pointer],

      # @!method TextAppend(text, append, position)
      #   TextAppend : Append text at specific position and move cursor
      #   @param text [char *]
      #   @param append [const char *]
      #   @param position [int *]
      #   @return [void]
      [:TextAppend, :TextAppend, [:pointer, :pointer, :pointer], :void],

      # @!method TextFindIndex(text, search)
      #   TextFindIndex : Find first text occurrence within a string, -1 if not found
      #   @param text [const char *]
      #   @param search [const char *]
      #   @return [int]
      [:TextFindIndex, :TextFindIndex, [:pointer, :pointer], :int],

      # @!method TextToUpper(text)
      #   TextToUpper : Get upper case version of provided string
      #   @param text [const char *]
      #   @return [char *]
      [:TextToUpper, :TextToUpper, [:pointer], :pointer],

      # @!method TextToLower(text)
      #   TextToLower : Get lower case version of provided string
      #   @param text [const char *]
      #   @return [char *]
      [:TextToLower, :TextToLower, [:pointer], :pointer],

      # @!method TextToPascal(text)
      #   TextToPascal : Get Pascal case notation version of provided string
      #   @param text [const char *]
      #   @return [char *]
      [:TextToPascal, :TextToPascal, [:pointer], :pointer],

      # @!method TextToSnake(text)
      #   TextToSnake : Get Snake case notation version of provided string
      #   @param text [const char *]
      #   @return [char *]
      [:TextToSnake, :TextToSnake, [:pointer], :pointer],

      # @!method TextToCamel(text)
      #   TextToCamel : Get Camel case notation version of provided string
      #   @param text [const char *]
      #   @return [char *]
      [:TextToCamel, :TextToCamel, [:pointer], :pointer],

      # @!method TextToInteger(text)
      #   TextToInteger : Get integer value from text
      #   @param text [const char *]
      #   @return [int]
      [:TextToInteger, :TextToInteger, [:pointer], :int],

      # @!method TextToFloat(text)
      #   TextToFloat : Get float value from text
      #   @param text [const char *]
      #   @return [float]
      [:TextToFloat, :TextToFloat, [:pointer], :float],

      # @!method DrawLine3D(startPos, endPos, color)
      #   DrawLine3D : Draw a line in 3D world space
      #   @param startPos [Vector3]
      #   @param endPos [Vector3]
      #   @param color [Color]
      #   @return [void]
      [:DrawLine3D, :DrawLine3D, [Vector3.by_value, Vector3.by_value, Color.by_value], :void],

      # @!method DrawPoint3D(position, color)
      #   DrawPoint3D : Draw a point in 3D space, actually a small line
      #   @param position [Vector3]
      #   @param color [Color]
      #   @return [void]
      [:DrawPoint3D, :DrawPoint3D, [Vector3.by_value, Color.by_value], :void],

      # @!method DrawCircle3D(center, radius, rotationAxis, rotationAngle, color)
      #   DrawCircle3D : Draw a circle in 3D world space
      #   @param center [Vector3]
      #   @param radius [float]
      #   @param rotationAxis [Vector3]
      #   @param rotationAngle [float]
      #   @param color [Color]
      #   @return [void]
      [:DrawCircle3D, :DrawCircle3D, [Vector3.by_value, :float, Vector3.by_value, :float, Color.by_value], :void],

      # @!method DrawTriangle3D(v1, v2, v3, color)
      #   DrawTriangle3D : Draw a color-filled triangle (vertex in counter-clockwise order!)
      #   @param v1 [Vector3]
      #   @param v2 [Vector3]
      #   @param v3 [Vector3]
      #   @param color [Color]
      #   @return [void]
      [:DrawTriangle3D, :DrawTriangle3D, [Vector3.by_value, Vector3.by_value, Vector3.by_value, Color.by_value], :void],

      # @!method DrawTriangleStrip3D(points, pointCount, color)
      #   DrawTriangleStrip3D : Draw a triangle strip defined by points
      #   @param points [const Vector3 *]
      #   @param pointCount [int]
      #   @param color [Color]
      #   @return [void]
      [:DrawTriangleStrip3D, :DrawTriangleStrip3D, [:pointer, :int, Color.by_value], :void],

      # @!method DrawCube(position, width, height, length, color)
      #   DrawCube : Draw cube
      #   @param position [Vector3]
      #   @param width [float]
      #   @param height [float]
      #   @param length [float]
      #   @param color [Color]
      #   @return [void]
      [:DrawCube, :DrawCube, [Vector3.by_value, :float, :float, :float, Color.by_value], :void],

      # @!method DrawCubeV(position, size, color)
      #   DrawCubeV : Draw cube (Vector version)
      #   @param position [Vector3]
      #   @param size [Vector3]
      #   @param color [Color]
      #   @return [void]
      [:DrawCubeV, :DrawCubeV, [Vector3.by_value, Vector3.by_value, Color.by_value], :void],

      # @!method DrawCubeWires(position, width, height, length, color)
      #   DrawCubeWires : Draw cube wires
      #   @param position [Vector3]
      #   @param width [float]
      #   @param height [float]
      #   @param length [float]
      #   @param color [Color]
      #   @return [void]
      [:DrawCubeWires, :DrawCubeWires, [Vector3.by_value, :float, :float, :float, Color.by_value], :void],

      # @!method DrawCubeWiresV(position, size, color)
      #   DrawCubeWiresV : Draw cube wires (Vector version)
      #   @param position [Vector3]
      #   @param size [Vector3]
      #   @param color [Color]
      #   @return [void]
      [:DrawCubeWiresV, :DrawCubeWiresV, [Vector3.by_value, Vector3.by_value, Color.by_value], :void],

      # @!method DrawSphere(centerPos, radius, color)
      #   DrawSphere : Draw sphere
      #   @param centerPos [Vector3]
      #   @param radius [float]
      #   @param color [Color]
      #   @return [void]
      [:DrawSphere, :DrawSphere, [Vector3.by_value, :float, Color.by_value], :void],

      # @!method DrawSphereEx(centerPos, radius, rings, slices, color)
      #   DrawSphereEx : Draw sphere with extended parameters
      #   @param centerPos [Vector3]
      #   @param radius [float]
      #   @param rings [int]
      #   @param slices [int]
      #   @param color [Color]
      #   @return [void]
      [:DrawSphereEx, :DrawSphereEx, [Vector3.by_value, :float, :int, :int, Color.by_value], :void],

      # @!method DrawSphereWires(centerPos, radius, rings, slices, color)
      #   DrawSphereWires : Draw sphere wires
      #   @param centerPos [Vector3]
      #   @param radius [float]
      #   @param rings [int]
      #   @param slices [int]
      #   @param color [Color]
      #   @return [void]
      [:DrawSphereWires, :DrawSphereWires, [Vector3.by_value, :float, :int, :int, Color.by_value], :void],

      # @!method DrawCylinder(position, radiusTop, radiusBottom, height, slices, color)
      #   DrawCylinder : Draw a cylinder/cone
      #   @param position [Vector3]
      #   @param radiusTop [float]
      #   @param radiusBottom [float]
      #   @param height [float]
      #   @param slices [int]
      #   @param color [Color]
      #   @return [void]
      [:DrawCylinder, :DrawCylinder, [Vector3.by_value, :float, :float, :float, :int, Color.by_value], :void],

      # @!method DrawCylinderEx(startPos, endPos, startRadius, endRadius, sides, color)
      #   DrawCylinderEx : Draw a cylinder with base at startPos and top at endPos
      #   @param startPos [Vector3]
      #   @param endPos [Vector3]
      #   @param startRadius [float]
      #   @param endRadius [float]
      #   @param sides [int]
      #   @param color [Color]
      #   @return [void]
      [:DrawCylinderEx, :DrawCylinderEx, [Vector3.by_value, Vector3.by_value, :float, :float, :int, Color.by_value], :void],

      # @!method DrawCylinderWires(position, radiusTop, radiusBottom, height, slices, color)
      #   DrawCylinderWires : Draw a cylinder/cone wires
      #   @param position [Vector3]
      #   @param radiusTop [float]
      #   @param radiusBottom [float]
      #   @param height [float]
      #   @param slices [int]
      #   @param color [Color]
      #   @return [void]
      [:DrawCylinderWires, :DrawCylinderWires, [Vector3.by_value, :float, :float, :float, :int, Color.by_value], :void],

      # @!method DrawCylinderWiresEx(startPos, endPos, startRadius, endRadius, sides, color)
      #   DrawCylinderWiresEx : Draw a cylinder wires with base at startPos and top at endPos
      #   @param startPos [Vector3]
      #   @param endPos [Vector3]
      #   @param startRadius [float]
      #   @param endRadius [float]
      #   @param sides [int]
      #   @param color [Color]
      #   @return [void]
      [:DrawCylinderWiresEx, :DrawCylinderWiresEx, [Vector3.by_value, Vector3.by_value, :float, :float, :int, Color.by_value], :void],

      # @!method DrawCapsule(startPos, endPos, radius, slices, rings, color)
      #   DrawCapsule : Draw a capsule with the center of its sphere caps at startPos and endPos
      #   @param startPos [Vector3]
      #   @param endPos [Vector3]
      #   @param radius [float]
      #   @param slices [int]
      #   @param rings [int]
      #   @param color [Color]
      #   @return [void]
      [:DrawCapsule, :DrawCapsule, [Vector3.by_value, Vector3.by_value, :float, :int, :int, Color.by_value], :void],

      # @!method DrawCapsuleWires(startPos, endPos, radius, slices, rings, color)
      #   DrawCapsuleWires : Draw capsule wireframe with the center of its sphere caps at startPos and endPos
      #   @param startPos [Vector3]
      #   @param endPos [Vector3]
      #   @param radius [float]
      #   @param slices [int]
      #   @param rings [int]
      #   @param color [Color]
      #   @return [void]
      [:DrawCapsuleWires, :DrawCapsuleWires, [Vector3.by_value, Vector3.by_value, :float, :int, :int, Color.by_value], :void],

      # @!method DrawPlane(centerPos, size, color)
      #   DrawPlane : Draw a plane XZ
      #   @param centerPos [Vector3]
      #   @param size [Vector2]
      #   @param color [Color]
      #   @return [void]
      [:DrawPlane, :DrawPlane, [Vector3.by_value, Vector2.by_value, Color.by_value], :void],

      # @!method DrawRay(ray, color)
      #   DrawRay : Draw a ray line
      #   @param ray [Ray]
      #   @param color [Color]
      #   @return [void]
      [:DrawRay, :DrawRay, [Ray.by_value, Color.by_value], :void],

      # @!method DrawGrid(slices, spacing)
      #   DrawGrid : Draw a grid (centered at (0, 0, 0))
      #   @param slices [int]
      #   @param spacing [float]
      #   @return [void]
      [:DrawGrid, :DrawGrid, [:int, :float], :void],

      # @!method LoadModel(fileName)
      #   LoadModel : Load model from files (meshes and materials)
      #   @param fileName [const char *]
      #   @return [Model]
      [:LoadModel, :LoadModel, [:pointer], Model.by_value],

      # @!method LoadModelFromMesh(mesh)
      #   LoadModelFromMesh : Load model from generated mesh (default material)
      #   @param mesh [Mesh]
      #   @return [Model]
      [:LoadModelFromMesh, :LoadModelFromMesh, [Mesh.by_value], Model.by_value],

      # @!method IsModelValid(model)
      #   IsModelValid : Check if a model is valid (loaded in GPU, VAO/VBOs)
      #   @param model [Model]
      #   @return [bool]
      [:IsModelValid, :IsModelValid, [Model.by_value], :bool],

      # @!method UnloadModel(model)
      #   UnloadModel : Unload model (including meshes) from memory (RAM and/or VRAM)
      #   @param model [Model]
      #   @return [void]
      [:UnloadModel, :UnloadModel, [Model.by_value], :void],

      # @!method GetModelBoundingBox(model)
      #   GetModelBoundingBox : Compute model bounding box limits (considers all meshes)
      #   @param model [Model]
      #   @return [BoundingBox]
      [:GetModelBoundingBox, :GetModelBoundingBox, [Model.by_value], BoundingBox.by_value],

      # @!method DrawModel(model, position, scale, tint)
      #   DrawModel : Draw a model (with texture if set)
      #   @param model [Model]
      #   @param position [Vector3]
      #   @param scale [float]
      #   @param tint [Color]
      #   @return [void]
      [:DrawModel, :DrawModel, [Model.by_value, Vector3.by_value, :float, Color.by_value], :void],

      # @!method internalDrawModelEx(model, position, rotationAxis, rotationAngle, scale, tint)
      #   internalDrawModelEx : Draw a model with extended parameters
      #   @param model [Model]
      #   @param position [Vector3]
      #   @param rotationAxis [Vector3]
      #   @param rotationAngle [float]
      #   @param scale [Vector3]
      #   @param tint [Color]
      #   @return [void]
      [:internalDrawModelEx, :DrawModelEx, [Model.by_value, Vector3.by_value, Vector3.by_value, :float, Vector3.by_value, Color.by_value], :void],

      # @!method DrawModelWires(model, position, scale, tint)
      #   DrawModelWires : Draw a model wires (with texture if set)
      #   @param model [Model]
      #   @param position [Vector3]
      #   @param scale [float]
      #   @param tint [Color]
      #   @return [void]
      [:DrawModelWires, :DrawModelWires, [Model.by_value, Vector3.by_value, :float, Color.by_value], :void],

      # @!method DrawModelWiresEx(model, position, rotationAxis, rotationAngle, scale, tint)
      #   DrawModelWiresEx : Draw a model wires (with texture if set) with extended parameters
      #   @param model [Model]
      #   @param position [Vector3]
      #   @param rotationAxis [Vector3]
      #   @param rotationAngle [float]
      #   @param scale [Vector3]
      #   @param tint [Color]
      #   @return [void]
      [:DrawModelWiresEx, :DrawModelWiresEx, [Model.by_value, Vector3.by_value, Vector3.by_value, :float, Vector3.by_value, Color.by_value], :void],

      # @!method DrawModelPoints(model, position, scale, tint)
      #   DrawModelPoints : Draw a model as points
      #   @param model [Model]
      #   @param position [Vector3]
      #   @param scale [float]
      #   @param tint [Color]
      #   @return [void]
      [:DrawModelPoints, :DrawModelPoints, [Model.by_value, Vector3.by_value, :float, Color.by_value], :void],

      # @!method DrawModelPointsEx(model, position, rotationAxis, rotationAngle, scale, tint)
      #   DrawModelPointsEx : Draw a model as points with extended parameters
      #   @param model [Model]
      #   @param position [Vector3]
      #   @param rotationAxis [Vector3]
      #   @param rotationAngle [float]
      #   @param scale [Vector3]
      #   @param tint [Color]
      #   @return [void]
      [:DrawModelPointsEx, :DrawModelPointsEx, [Model.by_value, Vector3.by_value, Vector3.by_value, :float, Vector3.by_value, Color.by_value], :void],

      # @!method DrawBoundingBox(box, color)
      #   DrawBoundingBox : Draw bounding box (wires)
      #   @param box [BoundingBox]
      #   @param color [Color]
      #   @return [void]
      [:DrawBoundingBox, :DrawBoundingBox, [BoundingBox.by_value, Color.by_value], :void],

      # @!method DrawBillboard(camera, texture, position, scale, tint)
      #   DrawBillboard : Draw a billboard texture
      #   @param camera [Camera]
      #   @param texture [Texture2D]
      #   @param position [Vector3]
      #   @param scale [float]
      #   @param tint [Color]
      #   @return [void]
      [:DrawBillboard, :DrawBillboard, [Camera.by_value, Texture2D.by_value, Vector3.by_value, :float, Color.by_value], :void],

      # @!method DrawBillboardRec(camera, texture, source, position, size, tint)
      #   DrawBillboardRec : Draw a billboard texture defined by source
      #   @param camera [Camera]
      #   @param texture [Texture2D]
      #   @param source [Rectangle]
      #   @param position [Vector3]
      #   @param size [Vector2]
      #   @param tint [Color]
      #   @return [void]
      [:DrawBillboardRec, :DrawBillboardRec, [Camera.by_value, Texture2D.by_value, Rectangle.by_value, Vector3.by_value, Vector2.by_value, Color.by_value], :void],

      # @!method DrawBillboardPro(camera, texture, source, position, up, size, origin, rotation, tint)
      #   DrawBillboardPro : Draw a billboard texture defined by source and rotation
      #   @param camera [Camera]
      #   @param texture [Texture2D]
      #   @param source [Rectangle]
      #   @param position [Vector3]
      #   @param up [Vector3]
      #   @param size [Vector2]
      #   @param origin [Vector2]
      #   @param rotation [float]
      #   @param tint [Color]
      #   @return [void]
      [:DrawBillboardPro, :DrawBillboardPro, [Camera.by_value, Texture2D.by_value, Rectangle.by_value, Vector3.by_value, Vector3.by_value, Vector2.by_value, Vector2.by_value, :float, Color.by_value], :void],

      # @!method UploadMesh(mesh, dynamic)
      #   UploadMesh : Upload mesh vertex data in GPU and provide VAO/VBO ids
      #   @param mesh [Mesh *]
      #   @param dynamic [bool]
      #   @return [void]
      [:UploadMesh, :UploadMesh, [:pointer, :bool], :void],

      # @!method UpdateMeshBuffer(mesh, index, data, dataSize, offset)
      #   UpdateMeshBuffer : Update mesh vertex data in GPU for a specific buffer index
      #   @param mesh [Mesh]
      #   @param index [int]
      #   @param data [const void *]
      #   @param dataSize [int]
      #   @param offset [int]
      #   @return [void]
      [:UpdateMeshBuffer, :UpdateMeshBuffer, [Mesh.by_value, :int, :pointer, :int, :int], :void],

      # @!method UnloadMesh(mesh)
      #   UnloadMesh : Unload mesh data from CPU and GPU
      #   @param mesh [Mesh]
      #   @return [void]
      [:UnloadMesh, :UnloadMesh, [Mesh.by_value], :void],

      # @!method DrawMesh(mesh, material, transform)
      #   DrawMesh : Draw a 3d mesh with material and transform
      #   @param mesh [Mesh]
      #   @param material [Material]
      #   @param transform [Matrix]
      #   @return [void]
      [:DrawMesh, :DrawMesh, [Mesh.by_value, Material.by_value, Matrix.by_value], :void],

      # @!method DrawMeshInstanced(mesh, material, transforms, instances)
      #   DrawMeshInstanced : Draw multiple mesh instances with material and different transforms
      #   @param mesh [Mesh]
      #   @param material [Material]
      #   @param transforms [const Matrix *]
      #   @param instances [int]
      #   @return [void]
      [:DrawMeshInstanced, :DrawMeshInstanced, [Mesh.by_value, Material.by_value, :pointer, :int], :void],

      # @!method GetMeshBoundingBox(mesh)
      #   GetMeshBoundingBox : Compute mesh bounding box limits
      #   @param mesh [Mesh]
      #   @return [BoundingBox]
      [:GetMeshBoundingBox, :GetMeshBoundingBox, [Mesh.by_value], BoundingBox.by_value],

      # @!method GenMeshTangents(mesh)
      #   GenMeshTangents : Compute mesh tangents
      #   @param mesh [Mesh *]
      #   @return [void]
      [:GenMeshTangents, :GenMeshTangents, [:pointer], :void],

      # @!method ExportMesh(mesh, fileName)
      #   ExportMesh : Export mesh data to file, returns true on success
      #   @param mesh [Mesh]
      #   @param fileName [const char *]
      #   @return [bool]
      [:ExportMesh, :ExportMesh, [Mesh.by_value, :pointer], :bool],

      # @!method ExportMeshAsCode(mesh, fileName)
      #   ExportMeshAsCode : Export mesh as code file (.h) defining multiple arrays of vertex attributes
      #   @param mesh [Mesh]
      #   @param fileName [const char *]
      #   @return [bool]
      [:ExportMeshAsCode, :ExportMeshAsCode, [Mesh.by_value, :pointer], :bool],

      # @!method GenMeshPoly(sides, radius)
      #   GenMeshPoly : Generate polygonal mesh
      #   @param sides [int]
      #   @param radius [float]
      #   @return [Mesh]
      [:GenMeshPoly, :GenMeshPoly, [:int, :float], Mesh.by_value],

      # @!method GenMeshPlane(width, length, resX, resZ)
      #   GenMeshPlane : Generate plane mesh (with subdivisions)
      #   @param width [float]
      #   @param length [float]
      #   @param resX [int]
      #   @param resZ [int]
      #   @return [Mesh]
      [:GenMeshPlane, :GenMeshPlane, [:float, :float, :int, :int], Mesh.by_value],

      # @!method GenMeshCube(width, height, length)
      #   GenMeshCube : Generate cuboid mesh
      #   @param width [float]
      #   @param height [float]
      #   @param length [float]
      #   @return [Mesh]
      [:GenMeshCube, :GenMeshCube, [:float, :float, :float], Mesh.by_value],

      # @!method GenMeshSphere(radius, rings, slices)
      #   GenMeshSphere : Generate sphere mesh (standard sphere)
      #   @param radius [float]
      #   @param rings [int]
      #   @param slices [int]
      #   @return [Mesh]
      [:GenMeshSphere, :GenMeshSphere, [:float, :int, :int], Mesh.by_value],

      # @!method GenMeshHemiSphere(radius, rings, slices)
      #   GenMeshHemiSphere : Generate half-sphere mesh (no bottom cap)
      #   @param radius [float]
      #   @param rings [int]
      #   @param slices [int]
      #   @return [Mesh]
      [:GenMeshHemiSphere, :GenMeshHemiSphere, [:float, :int, :int], Mesh.by_value],

      # @!method GenMeshCylinder(radius, height, slices)
      #   GenMeshCylinder : Generate cylinder mesh
      #   @param radius [float]
      #   @param height [float]
      #   @param slices [int]
      #   @return [Mesh]
      [:GenMeshCylinder, :GenMeshCylinder, [:float, :float, :int], Mesh.by_value],

      # @!method GenMeshCone(radius, height, slices)
      #   GenMeshCone : Generate cone/pyramid mesh
      #   @param radius [float]
      #   @param height [float]
      #   @param slices [int]
      #   @return [Mesh]
      [:GenMeshCone, :GenMeshCone, [:float, :float, :int], Mesh.by_value],

      # @!method GenMeshTorus(radius, size, radSeg, sides)
      #   GenMeshTorus : Generate torus mesh
      #   @param radius [float]
      #   @param size [float]
      #   @param radSeg [int]
      #   @param sides [int]
      #   @return [Mesh]
      [:GenMeshTorus, :GenMeshTorus, [:float, :float, :int, :int], Mesh.by_value],

      # @!method GenMeshKnot(radius, size, radSeg, sides)
      #   GenMeshKnot : Generate trefoil knot mesh
      #   @param radius [float]
      #   @param size [float]
      #   @param radSeg [int]
      #   @param sides [int]
      #   @return [Mesh]
      [:GenMeshKnot, :GenMeshKnot, [:float, :float, :int, :int], Mesh.by_value],

      # @!method GenMeshHeightmap(heightmap, size)
      #   GenMeshHeightmap : Generate heightmap mesh from image data
      #   @param heightmap [Image]
      #   @param size [Vector3]
      #   @return [Mesh]
      [:GenMeshHeightmap, :GenMeshHeightmap, [Image.by_value, Vector3.by_value], Mesh.by_value],

      # @!method GenMeshCubicmap(cubicmap, cubeSize)
      #   GenMeshCubicmap : Generate cubes-based map mesh from image data
      #   @param cubicmap [Image]
      #   @param cubeSize [Vector3]
      #   @return [Mesh]
      [:GenMeshCubicmap, :GenMeshCubicmap, [Image.by_value, Vector3.by_value], Mesh.by_value],

      # @!method LoadMaterials(fileName, materialCount)
      #   LoadMaterials : Load materials from model file
      #   @param fileName [const char *]
      #   @param materialCount [int *]
      #   @return [Material *]
      [:LoadMaterials, :LoadMaterials, [:pointer, :pointer], :pointer],

      # @!method LoadMaterialDefault()
      #   LoadMaterialDefault : Load default material (Supports: DIFFUSE, SPECULAR, NORMAL maps)
      #   @return [Material]
      [:LoadMaterialDefault, :LoadMaterialDefault, [], Material.by_value],

      # @!method IsMaterialValid(material)
      #   IsMaterialValid : Check if a material is valid (shader assigned, map textures loaded in GPU)
      #   @param material [Material]
      #   @return [bool]
      [:IsMaterialValid, :IsMaterialValid, [Material.by_value], :bool],

      # @!method UnloadMaterial(material)
      #   UnloadMaterial : Unload material from GPU memory (VRAM)
      #   @param material [Material]
      #   @return [void]
      [:UnloadMaterial, :UnloadMaterial, [Material.by_value], :void],

      # @!method SetMaterialTexture(material, mapType, texture)
      #   SetMaterialTexture : Set texture for a material map type (MATERIAL_MAP_DIFFUSE, MATERIAL_MAP_SPECULAR...)
      #   @param material [Material *]
      #   @param mapType [int]
      #   @param texture [Texture2D]
      #   @return [void]
      [:SetMaterialTexture, :SetMaterialTexture, [:pointer, :int, Texture2D.by_value], :void],

      # @!method SetModelMeshMaterial(model, meshId, materialId)
      #   SetModelMeshMaterial : Set material for a mesh
      #   @param model [Model *]
      #   @param meshId [int]
      #   @param materialId [int]
      #   @return [void]
      [:SetModelMeshMaterial, :SetModelMeshMaterial, [:pointer, :int, :int], :void],

      # @!method LoadModelAnimations(fileName, animCount)
      #   LoadModelAnimations : Load model animations from file
      #   @param fileName [const char *]
      #   @param animCount [int *]
      #   @return [ModelAnimation *]
      [:LoadModelAnimations, :LoadModelAnimations, [:pointer, :pointer], :pointer],

      # @!method UpdateModelAnimation(model, anim, frame)
      #   UpdateModelAnimation : Update model animation pose (CPU)
      #   @param model [Model]
      #   @param anim [ModelAnimation]
      #   @param frame [int]
      #   @return [void]
      [:UpdateModelAnimation, :UpdateModelAnimation, [Model.by_value, ModelAnimation.by_value, :int], :void],

      # @!method UpdateModelAnimationBones(model, anim, frame)
      #   UpdateModelAnimationBones : Update model animation mesh bone matrices (GPU skinning)
      #   @param model [Model]
      #   @param anim [ModelAnimation]
      #   @param frame [int]
      #   @return [void]
      [:UpdateModelAnimationBones, :UpdateModelAnimationBones, [Model.by_value, ModelAnimation.by_value, :int], :void],

      # @!method UnloadModelAnimation(anim)
      #   UnloadModelAnimation : Unload animation data
      #   @param anim [ModelAnimation]
      #   @return [void]
      [:UnloadModelAnimation, :UnloadModelAnimation, [ModelAnimation.by_value], :void],

      # @!method UnloadModelAnimations(animations, animCount)
      #   UnloadModelAnimations : Unload animation array data
      #   @param animations [ModelAnimation *]
      #   @param animCount [int]
      #   @return [void]
      [:UnloadModelAnimations, :UnloadModelAnimations, [:pointer, :int], :void],

      # @!method IsModelAnimationValid(model, anim)
      #   IsModelAnimationValid : Check model animation skeleton match
      #   @param model [Model]
      #   @param anim [ModelAnimation]
      #   @return [bool]
      [:IsModelAnimationValid, :IsModelAnimationValid, [Model.by_value, ModelAnimation.by_value], :bool],

      # @!method CheckCollisionSpheres(center1, radius1, center2, radius2)
      #   CheckCollisionSpheres : Check collision between two spheres
      #   @param center1 [Vector3]
      #   @param radius1 [float]
      #   @param center2 [Vector3]
      #   @param radius2 [float]
      #   @return [bool]
      [:CheckCollisionSpheres, :CheckCollisionSpheres, [Vector3.by_value, :float, Vector3.by_value, :float], :bool],

      # @!method CheckCollisionBoxes(box1, box2)
      #   CheckCollisionBoxes : Check collision between two bounding boxes
      #   @param box1 [BoundingBox]
      #   @param box2 [BoundingBox]
      #   @return [bool]
      [:CheckCollisionBoxes, :CheckCollisionBoxes, [BoundingBox.by_value, BoundingBox.by_value], :bool],

      # @!method CheckCollisionBoxSphere(box, center, radius)
      #   CheckCollisionBoxSphere : Check collision between box and sphere
      #   @param box [BoundingBox]
      #   @param center [Vector3]
      #   @param radius [float]
      #   @return [bool]
      [:CheckCollisionBoxSphere, :CheckCollisionBoxSphere, [BoundingBox.by_value, Vector3.by_value, :float], :bool],

      # @!method GetRayCollisionSphere(ray, center, radius)
      #   GetRayCollisionSphere : Get collision info between ray and sphere
      #   @param ray [Ray]
      #   @param center [Vector3]
      #   @param radius [float]
      #   @return [RayCollision]
      [:GetRayCollisionSphere, :GetRayCollisionSphere, [Ray.by_value, Vector3.by_value, :float], RayCollision.by_value],

      # @!method GetRayCollisionBox(ray, box)
      #   GetRayCollisionBox : Get collision info between ray and box
      #   @param ray [Ray]
      #   @param box [BoundingBox]
      #   @return [RayCollision]
      [:GetRayCollisionBox, :GetRayCollisionBox, [Ray.by_value, BoundingBox.by_value], RayCollision.by_value],

      # @!method GetRayCollisionMesh(ray, mesh, transform)
      #   GetRayCollisionMesh : Get collision info between ray and mesh
      #   @param ray [Ray]
      #   @param mesh [Mesh]
      #   @param transform [Matrix]
      #   @return [RayCollision]
      [:GetRayCollisionMesh, :GetRayCollisionMesh, [Ray.by_value, Mesh.by_value, Matrix.by_value], RayCollision.by_value],

      # @!method GetRayCollisionTriangle(ray, p1, p2, p3)
      #   GetRayCollisionTriangle : Get collision info between ray and triangle
      #   @param ray [Ray]
      #   @param p1 [Vector3]
      #   @param p2 [Vector3]
      #   @param p3 [Vector3]
      #   @return [RayCollision]
      [:GetRayCollisionTriangle, :GetRayCollisionTriangle, [Ray.by_value, Vector3.by_value, Vector3.by_value, Vector3.by_value], RayCollision.by_value],

      # @!method GetRayCollisionQuad(ray, p1, p2, p3, p4)
      #   GetRayCollisionQuad : Get collision info between ray and quad
      #   @param ray [Ray]
      #   @param p1 [Vector3]
      #   @param p2 [Vector3]
      #   @param p3 [Vector3]
      #   @param p4 [Vector3]
      #   @return [RayCollision]
      [:GetRayCollisionQuad, :GetRayCollisionQuad, [Ray.by_value, Vector3.by_value, Vector3.by_value, Vector3.by_value, Vector3.by_value], RayCollision.by_value],

      # @!method InitAudioDevice()
      #   InitAudioDevice : Initialize audio device and context
      #   @return [void]
      [:InitAudioDevice, :InitAudioDevice, [], :void],

      # @!method CloseAudioDevice()
      #   CloseAudioDevice : Close the audio device and context
      #   @return [void]
      [:CloseAudioDevice, :CloseAudioDevice, [], :void],

      # @!method IsAudioDeviceReady()
      #   IsAudioDeviceReady : Check if audio device has been initialized successfully
      #   @return [bool]
      [:IsAudioDeviceReady, :IsAudioDeviceReady, [], :bool],

      # @!method SetMasterVolume(volume)
      #   SetMasterVolume : Set master volume (listener)
      #   @param volume [float]
      #   @return [void]
      [:SetMasterVolume, :SetMasterVolume, [:float], :void],

      # @!method GetMasterVolume()
      #   GetMasterVolume : Get master volume (listener)
      #   @return [float]
      [:GetMasterVolume, :GetMasterVolume, [], :float],

      # @!method LoadWave(fileName)
      #   LoadWave : Load wave data from file
      #   @param fileName [const char *]
      #   @return [Wave]
      [:LoadWave, :LoadWave, [:pointer], Wave.by_value],

      # @!method LoadWaveFromMemory(fileType, fileData, dataSize)
      #   LoadWaveFromMemory : Load wave from memory buffer, fileType refers to extension: i.e. '.wav'
      #   @param fileType [const char *]
      #   @param fileData [const unsigned char *]
      #   @param dataSize [int]
      #   @return [Wave]
      [:LoadWaveFromMemory, :LoadWaveFromMemory, [:pointer, :pointer, :int], Wave.by_value],

      # @!method IsWaveValid(wave)
      #   IsWaveValid : Checks if wave data is valid (data loaded and parameters)
      #   @param wave [Wave]
      #   @return [bool]
      [:IsWaveValid, :IsWaveValid, [Wave.by_value], :bool],

      # @!method LoadSound(fileName)
      #   LoadSound : Load sound from file
      #   @param fileName [const char *]
      #   @return [Sound]
      [:LoadSound, :LoadSound, [:pointer], Sound.by_value],

      # @!method LoadSoundFromWave(wave)
      #   LoadSoundFromWave : Load sound from wave data
      #   @param wave [Wave]
      #   @return [Sound]
      [:LoadSoundFromWave, :LoadSoundFromWave, [Wave.by_value], Sound.by_value],

      # @!method LoadSoundAlias(source)
      #   LoadSoundAlias : Create a new sound that shares the same sample data as the source sound, does not own the sound data
      #   @param source [Sound]
      #   @return [Sound]
      [:LoadSoundAlias, :LoadSoundAlias, [Sound.by_value], Sound.by_value],

      # @!method IsSoundValid(sound)
      #   IsSoundValid : Checks if a sound is valid (data loaded and buffers initialized)
      #   @param sound [Sound]
      #   @return [bool]
      [:IsSoundValid, :IsSoundValid, [Sound.by_value], :bool],

      # @!method UpdateSound(sound, data, sampleCount)
      #   UpdateSound : Update sound buffer with new data (data and frame count should fit in sound)
      #   @param sound [Sound]
      #   @param data [const void *]
      #   @param sampleCount [int]
      #   @return [void]
      [:UpdateSound, :UpdateSound, [Sound.by_value, :pointer, :int], :void],

      # @!method UnloadWave(wave)
      #   UnloadWave : Unload wave data
      #   @param wave [Wave]
      #   @return [void]
      [:UnloadWave, :UnloadWave, [Wave.by_value], :void],

      # @!method UnloadSound(sound)
      #   UnloadSound : Unload sound
      #   @param sound [Sound]
      #   @return [void]
      [:UnloadSound, :UnloadSound, [Sound.by_value], :void],

      # @!method UnloadSoundAlias(alias)
      #   UnloadSoundAlias : Unload a sound alias (does not deallocate sample data)
      #   @param alias [Sound]
      #   @return [void]
      [:UnloadSoundAlias, :UnloadSoundAlias, [Sound.by_value], :void],

      # @!method ExportWave(wave, fileName)
      #   ExportWave : Export wave data to file, returns true on success
      #   @param wave [Wave]
      #   @param fileName [const char *]
      #   @return [bool]
      [:ExportWave, :ExportWave, [Wave.by_value, :pointer], :bool],

      # @!method ExportWaveAsCode(wave, fileName)
      #   ExportWaveAsCode : Export wave sample data to code (.h), returns true on success
      #   @param wave [Wave]
      #   @param fileName [const char *]
      #   @return [bool]
      [:ExportWaveAsCode, :ExportWaveAsCode, [Wave.by_value, :pointer], :bool],

      # @!method PlaySound(sound)
      #   PlaySound : Play a sound
      #   @param sound [Sound]
      #   @return [void]
      [:PlaySound, :PlaySound, [Sound.by_value], :void],

      # @!method StopSound(sound)
      #   StopSound : Stop playing a sound
      #   @param sound [Sound]
      #   @return [void]
      [:StopSound, :StopSound, [Sound.by_value], :void],

      # @!method PauseSound(sound)
      #   PauseSound : Pause a sound
      #   @param sound [Sound]
      #   @return [void]
      [:PauseSound, :PauseSound, [Sound.by_value], :void],

      # @!method ResumeSound(sound)
      #   ResumeSound : Resume a paused sound
      #   @param sound [Sound]
      #   @return [void]
      [:ResumeSound, :ResumeSound, [Sound.by_value], :void],

      # @!method IsSoundPlaying(sound)
      #   IsSoundPlaying : Check if a sound is currently playing
      #   @param sound [Sound]
      #   @return [bool]
      [:IsSoundPlaying, :IsSoundPlaying, [Sound.by_value], :bool],

      # @!method SetSoundVolume(sound, volume)
      #   SetSoundVolume : Set volume for a sound (1.0 is max level)
      #   @param sound [Sound]
      #   @param volume [float]
      #   @return [void]
      [:SetSoundVolume, :SetSoundVolume, [Sound.by_value, :float], :void],

      # @!method SetSoundPitch(sound, pitch)
      #   SetSoundPitch : Set pitch for a sound (1.0 is base level)
      #   @param sound [Sound]
      #   @param pitch [float]
      #   @return [void]
      [:SetSoundPitch, :SetSoundPitch, [Sound.by_value, :float], :void],

      # @!method SetSoundPan(sound, pan)
      #   SetSoundPan : Set pan for a sound (0.5 is center)
      #   @param sound [Sound]
      #   @param pan [float]
      #   @return [void]
      [:SetSoundPan, :SetSoundPan, [Sound.by_value, :float], :void],

      # @!method WaveCopy(wave)
      #   WaveCopy : Copy a wave to a new wave
      #   @param wave [Wave]
      #   @return [Wave]
      [:WaveCopy, :WaveCopy, [Wave.by_value], Wave.by_value],

      # @!method WaveCrop(wave, initFrame, finalFrame)
      #   WaveCrop : Crop a wave to defined frames range
      #   @param wave [Wave *]
      #   @param initFrame [int]
      #   @param finalFrame [int]
      #   @return [void]
      [:WaveCrop, :WaveCrop, [:pointer, :int, :int], :void],

      # @!method WaveFormat(wave, sampleRate, sampleSize, channels)
      #   WaveFormat : Convert wave data to desired format
      #   @param wave [Wave *]
      #   @param sampleRate [int]
      #   @param sampleSize [int]
      #   @param channels [int]
      #   @return [void]
      [:WaveFormat, :WaveFormat, [:pointer, :int, :int, :int], :void],

      # @!method LoadWaveSamples(wave)
      #   LoadWaveSamples : Load samples data from wave as a 32bit float data array
      #   @param wave [Wave]
      #   @return [float *]
      [:LoadWaveSamples, :LoadWaveSamples, [Wave.by_value], :pointer],

      # @!method UnloadWaveSamples(samples)
      #   UnloadWaveSamples : Unload samples data loaded with LoadWaveSamples()
      #   @param samples [float *]
      #   @return [void]
      [:UnloadWaveSamples, :UnloadWaveSamples, [:pointer], :void],

      # @!method LoadMusicStream(fileName)
      #   LoadMusicStream : Load music stream from file
      #   @param fileName [const char *]
      #   @return [Music]
      [:LoadMusicStream, :LoadMusicStream, [:pointer], Music.by_value],

      # @!method LoadMusicStreamFromMemory(fileType, data, dataSize)
      #   LoadMusicStreamFromMemory : Load music stream from data
      #   @param fileType [const char *]
      #   @param data [const unsigned char *]
      #   @param dataSize [int]
      #   @return [Music]
      [:LoadMusicStreamFromMemory, :LoadMusicStreamFromMemory, [:pointer, :pointer, :int], Music.by_value],

      # @!method IsMusicValid(music)
      #   IsMusicValid : Checks if a music stream is valid (context and buffers initialized)
      #   @param music [Music]
      #   @return [bool]
      [:IsMusicValid, :IsMusicValid, [Music.by_value], :bool],

      # @!method UnloadMusicStream(music)
      #   UnloadMusicStream : Unload music stream
      #   @param music [Music]
      #   @return [void]
      [:UnloadMusicStream, :UnloadMusicStream, [Music.by_value], :void],

      # @!method PlayMusicStream(music)
      #   PlayMusicStream : Start music playing
      #   @param music [Music]
      #   @return [void]
      [:PlayMusicStream, :PlayMusicStream, [Music.by_value], :void],

      # @!method IsMusicStreamPlaying(music)
      #   IsMusicStreamPlaying : Check if music is playing
      #   @param music [Music]
      #   @return [bool]
      [:IsMusicStreamPlaying, :IsMusicStreamPlaying, [Music.by_value], :bool],

      # @!method UpdateMusicStream(music)
      #   UpdateMusicStream : Updates buffers for music streaming
      #   @param music [Music]
      #   @return [void]
      [:UpdateMusicStream, :UpdateMusicStream, [Music.by_value], :void],

      # @!method StopMusicStream(music)
      #   StopMusicStream : Stop music playing
      #   @param music [Music]
      #   @return [void]
      [:StopMusicStream, :StopMusicStream, [Music.by_value], :void],

      # @!method PauseMusicStream(music)
      #   PauseMusicStream : Pause music playing
      #   @param music [Music]
      #   @return [void]
      [:PauseMusicStream, :PauseMusicStream, [Music.by_value], :void],

      # @!method ResumeMusicStream(music)
      #   ResumeMusicStream : Resume playing paused music
      #   @param music [Music]
      #   @return [void]
      [:ResumeMusicStream, :ResumeMusicStream, [Music.by_value], :void],

      # @!method SeekMusicStream(music, position)
      #   SeekMusicStream : Seek music to a position (in seconds)
      #   @param music [Music]
      #   @param position [float]
      #   @return [void]
      [:SeekMusicStream, :SeekMusicStream, [Music.by_value, :float], :void],

      # @!method SetMusicVolume(music, volume)
      #   SetMusicVolume : Set volume for music (1.0 is max level)
      #   @param music [Music]
      #   @param volume [float]
      #   @return [void]
      [:SetMusicVolume, :SetMusicVolume, [Music.by_value, :float], :void],

      # @!method SetMusicPitch(music, pitch)
      #   SetMusicPitch : Set pitch for a music (1.0 is base level)
      #   @param music [Music]
      #   @param pitch [float]
      #   @return [void]
      [:SetMusicPitch, :SetMusicPitch, [Music.by_value, :float], :void],

      # @!method SetMusicPan(music, pan)
      #   SetMusicPan : Set pan for a music (0.5 is center)
      #   @param music [Music]
      #   @param pan [float]
      #   @return [void]
      [:SetMusicPan, :SetMusicPan, [Music.by_value, :float], :void],

      # @!method GetMusicTimeLength(music)
      #   GetMusicTimeLength : Get music time length (in seconds)
      #   @param music [Music]
      #   @return [float]
      [:GetMusicTimeLength, :GetMusicTimeLength, [Music.by_value], :float],

      # @!method GetMusicTimePlayed(music)
      #   GetMusicTimePlayed : Get current music time played (in seconds)
      #   @param music [Music]
      #   @return [float]
      [:GetMusicTimePlayed, :GetMusicTimePlayed, [Music.by_value], :float],

      # @!method LoadAudioStream(sampleRate, sampleSize, channels)
      #   LoadAudioStream : Load audio stream (to stream raw audio pcm data)
      #   @param sampleRate [unsigned int]
      #   @param sampleSize [unsigned int]
      #   @param channels [unsigned int]
      #   @return [AudioStream]
      [:LoadAudioStream, :LoadAudioStream, [:uint, :uint, :uint], AudioStream.by_value],

      # @!method IsAudioStreamValid(stream)
      #   IsAudioStreamValid : Checks if an audio stream is valid (buffers initialized)
      #   @param stream [AudioStream]
      #   @return [bool]
      [:IsAudioStreamValid, :IsAudioStreamValid, [AudioStream.by_value], :bool],

      # @!method UnloadAudioStream(stream)
      #   UnloadAudioStream : Unload audio stream and free memory
      #   @param stream [AudioStream]
      #   @return [void]
      [:UnloadAudioStream, :UnloadAudioStream, [AudioStream.by_value], :void],

      # @!method UpdateAudioStream(stream, data, frameCount)
      #   UpdateAudioStream : Update audio stream buffers with data
      #   @param stream [AudioStream]
      #   @param data [const void *]
      #   @param frameCount [int]
      #   @return [void]
      [:UpdateAudioStream, :UpdateAudioStream, [AudioStream.by_value, :pointer, :int], :void],

      # @!method IsAudioStreamProcessed(stream)
      #   IsAudioStreamProcessed : Check if any audio stream buffers requires refill
      #   @param stream [AudioStream]
      #   @return [bool]
      [:IsAudioStreamProcessed, :IsAudioStreamProcessed, [AudioStream.by_value], :bool],

      # @!method PlayAudioStream(stream)
      #   PlayAudioStream : Play audio stream
      #   @param stream [AudioStream]
      #   @return [void]
      [:PlayAudioStream, :PlayAudioStream, [AudioStream.by_value], :void],

      # @!method PauseAudioStream(stream)
      #   PauseAudioStream : Pause audio stream
      #   @param stream [AudioStream]
      #   @return [void]
      [:PauseAudioStream, :PauseAudioStream, [AudioStream.by_value], :void],

      # @!method ResumeAudioStream(stream)
      #   ResumeAudioStream : Resume audio stream
      #   @param stream [AudioStream]
      #   @return [void]
      [:ResumeAudioStream, :ResumeAudioStream, [AudioStream.by_value], :void],

      # @!method IsAudioStreamPlaying(stream)
      #   IsAudioStreamPlaying : Check if audio stream is playing
      #   @param stream [AudioStream]
      #   @return [bool]
      [:IsAudioStreamPlaying, :IsAudioStreamPlaying, [AudioStream.by_value], :bool],

      # @!method StopAudioStream(stream)
      #   StopAudioStream : Stop audio stream
      #   @param stream [AudioStream]
      #   @return [void]
      [:StopAudioStream, :StopAudioStream, [AudioStream.by_value], :void],

      # @!method SetAudioStreamVolume(stream, volume)
      #   SetAudioStreamVolume : Set volume for audio stream (1.0 is max level)
      #   @param stream [AudioStream]
      #   @param volume [float]
      #   @return [void]
      [:SetAudioStreamVolume, :SetAudioStreamVolume, [AudioStream.by_value, :float], :void],

      # @!method SetAudioStreamPitch(stream, pitch)
      #   SetAudioStreamPitch : Set pitch for audio stream (1.0 is base level)
      #   @param stream [AudioStream]
      #   @param pitch [float]
      #   @return [void]
      [:SetAudioStreamPitch, :SetAudioStreamPitch, [AudioStream.by_value, :float], :void],

      # @!method SetAudioStreamPan(stream, pan)
      #   SetAudioStreamPan : Set pan for audio stream (0.5 is centered)
      #   @param stream [AudioStream]
      #   @param pan [float]
      #   @return [void]
      [:SetAudioStreamPan, :SetAudioStreamPan, [AudioStream.by_value, :float], :void],

      # @!method SetAudioStreamBufferSizeDefault(size)
      #   SetAudioStreamBufferSizeDefault : Default size for new audio streams
      #   @param size [int]
      #   @return [void]
      [:SetAudioStreamBufferSizeDefault, :SetAudioStreamBufferSizeDefault, [:int], :void],

      # @!method SetAudioStreamCallback(stream, callback)
      #   SetAudioStreamCallback : Audio thread callback to request new data
      #   @param stream [AudioStream]
      #   @param callback [AudioCallback]
      #   @return [void]
      [:SetAudioStreamCallback, :SetAudioStreamCallback, [AudioStream.by_value, :AudioCallback], :void],

      # @!method AttachAudioStreamProcessor(stream, processor)
      #   AttachAudioStreamProcessor : Attach audio stream processor to stream, receives frames x 2 samples as 'float' (stereo)
      #   @param stream [AudioStream]
      #   @param processor [AudioCallback]
      #   @return [void]
      [:AttachAudioStreamProcessor, :AttachAudioStreamProcessor, [AudioStream.by_value, :AudioCallback], :void],

      # @!method DetachAudioStreamProcessor(stream, processor)
      #   DetachAudioStreamProcessor : Detach audio stream processor from stream
      #   @param stream [AudioStream]
      #   @param processor [AudioCallback]
      #   @return [void]
      [:DetachAudioStreamProcessor, :DetachAudioStreamProcessor, [AudioStream.by_value, :AudioCallback], :void],

      # @!method AttachAudioMixedProcessor(processor)
      #   AttachAudioMixedProcessor : Attach audio stream processor to the entire audio pipeline, receives frames x 2 samples as 'float' (stereo)
      #   @param processor [AudioCallback]
      #   @return [void]
      [:AttachAudioMixedProcessor, :AttachAudioMixedProcessor, [:AudioCallback], :void],

      # @!method DetachAudioMixedProcessor(processor)
      #   DetachAudioMixedProcessor : Detach audio stream processor from the entire audio pipeline
      #   @param processor [AudioCallback]
      #   @return [void]
      [:DetachAudioMixedProcessor, :DetachAudioMixedProcessor, [:AudioCallback], :void],
    ]
    entries.each do |entry|
      api_name = if method_naming == :snake_case
                   snake_case_name = entry[0].to_s.gsub(/([A-Z]+)([A-Z0-9][a-z])/, '\1_\2').gsub(/([a-z\d])([A-Z0-9])/, '\1_\2').downcase
                   snake_case_name.gsub!('vector_3', 'vector3_') if snake_case_name.include?('vector_3')
                   snake_case_name.gsub!('vector_2', 'vector2_') if snake_case_name.include?('vector_2')
                   snake_case_name.chop! if snake_case_name.end_with?('_')
                   snake_case_name.to_sym
                 else
                   entry[0]
                 end
      attach_function api_name, entry[1], entry[2], entry[3]
    rescue FFI::NotFoundError => e
      warn "[Warning] Failed to import #{entry[0]} (#{e})."
    end
  end
end
